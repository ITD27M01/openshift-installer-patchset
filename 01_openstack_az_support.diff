diff --git a/data/data/openstack/bootstrap/main.tf b/data/data/openstack/bootstrap/main.tf
index 906a82225..cd83412a8 100644
--- a/data/data/openstack/bootstrap/main.tf
+++ b/data/data/openstack/bootstrap/main.tf
@@ -33,6 +33,8 @@ resource "openstack_compute_instance_v2" "bootstrap" {
   flavor_id = data.openstack_compute_flavor_v2.bootstrap_flavor.id
   image_id  = var.base_image_id
 
+  availability_zone = var.availability_zone
+
   user_data = var.bootstrap_shim_ignition
 
   network {
diff --git a/data/data/openstack/bootstrap/variables.tf b/data/data/openstack/bootstrap/variables.tf
index 709262af3..ca9c662be 100644
--- a/data/data/openstack/bootstrap/variables.tf
+++ b/data/data/openstack/bootstrap/variables.tf
@@ -62,3 +62,8 @@ variable "nodes_subnet_id" {
 variable "cluster_domain" {
   type = string
 }
+
+variable "availability_zone" {
+  type        = string
+  description = "Name of availability zone to deploy cluster to."
+}
diff --git a/data/data/openstack/main.tf b/data/data/openstack/main.tf
index 841d2c83f..99a89d7b1 100644
--- a/data/data/openstack/main.tf
+++ b/data/data/openstack/main.tf
@@ -33,6 +33,7 @@ module "bootstrap" {
   api_int_ip              = var.openstack_api_int_ip
   node_dns_ip             = var.openstack_node_dns_ip
   external_network        = var.openstack_external_network
+  availability_zone       = var.openstack_availability_zone
   cluster_domain          = var.cluster_domain
   nodes_subnet_id         = module.topology.nodes_subnet_id
   private_network_id      = module.topology.private_network_id
@@ -43,18 +44,19 @@ module "bootstrap" {
 module "masters" {
   source = "./masters"
 
-  base_image_id   = data.openstack_images_image_v2.base_image.id
-  cluster_id      = var.cluster_id
-  flavor_name     = var.openstack_master_flavor_name
-  instance_count  = var.master_count
-  master_port_ids = module.topology.master_port_ids
-  user_data_ign   = var.ignition_master
-  master_sg_ids = concat(
+  availability_zone = var.openstack_availability_zone
+  base_image_id     = data.openstack_images_image_v2.base_image.id
+  cluster_id        = var.cluster_id
+  flavor_name       = var.openstack_master_flavor_name
+  instance_count    = var.master_count
+  master_port_ids   = module.topology.master_port_ids
+  user_data_ign     = var.ignition_master
+  master_sg_ids     = concat(
     var.openstack_master_extra_sg_ids,
     [module.topology.master_sg_id],
   )
-  root_volume_size = var.openstack_master_root_volume_size
-  root_volume_type = var.openstack_master_root_volume_type
+  root_volume_size  = var.openstack_master_root_volume_size
+  root_volume_type  = var.openstack_master_root_volume_type
 }
 
 module "topology" {
@@ -63,6 +65,7 @@ module "topology" {
   cidr_block          = var.machine_cidr
   cluster_id          = var.cluster_id
   cluster_domain      = var.cluster_domain
+  availability_zone   = var.openstack_availability_zone
   external_network    = var.openstack_external_network
   external_network_id = var.openstack_external_network_id
   masters_count       = var.master_count
diff --git a/data/data/openstack/masters/main.tf b/data/data/openstack/masters/main.tf
index c39f45054..d09d7c6fc 100644
--- a/data/data/openstack/masters/main.tf
+++ b/data/data/openstack/masters/main.tf
@@ -40,6 +40,8 @@ resource "openstack_compute_instance_v2" "master_conf" {
   name = "${var.cluster_id}-master-${count.index}"
   count = var.instance_count
 
+  availability_zone = var.availability_zone
+
   flavor_id = data.openstack_compute_flavor_v2.masters_flavor.id
   image_id = var.root_volume_size == null ? var.base_image_id : null
   security_groups = var.master_sg_ids
diff --git a/data/data/openstack/masters/variables.tf b/data/data/openstack/masters/variables.tf
index 7fdd06ff2..de77d2733 100644
--- a/data/data/openstack/masters/variables.tf
+++ b/data/data/openstack/masters/variables.tf
@@ -40,3 +40,8 @@ variable "root_volume_type" {
   type        = string
   description = "The type of volume for the root block device."
 }
+
+variable "availability_zone" {
+  type        = string
+  description = "Name of availability zone to deploy cluster to."
+}
diff --git a/data/data/openstack/topology/private-network.tf b/data/data/openstack/topology/private-network.tf
index a726a3e1f..9c7f12aa7 100644
--- a/data/data/openstack/topology/private-network.tf
+++ b/data/data/openstack/topology/private-network.tf
@@ -9,9 +9,10 @@ data "openstack_networking_network_v2" "external_network" {
 }
 
 resource "openstack_networking_network_v2" "openshift-private" {
-  name           = "${var.cluster_id}-openshift"
-  admin_state_up = "true"
-  tags           = ["openshiftClusterID=${var.cluster_id}"]
+  name                    = "${var.cluster_id}-openshift"
+  admin_state_up          = "true"
+  tags                    = ["openshiftClusterID=${var.cluster_id}"]
+  availability_zone_hints =  ["${var.availability_zone}"]
 }
 
 resource "openstack_networking_subnet_v2" "nodes" {
diff --git a/data/data/openstack/topology/variables.tf b/data/data/openstack/topology/variables.tf
index 267da9cc7..4bb6ffd57 100644
--- a/data/data/openstack/topology/variables.tf
+++ b/data/data/openstack/topology/variables.tf
@@ -56,3 +56,8 @@ variable "trunk_support" {
 variable "octavia_support" {
   type = "string"
 }
+
+variable "availability_zone" {
+  type        = string
+  description = "Name of availability zone to deploy cluster to."
+}
diff --git a/data/data/openstack/variables-openstack.tf b/data/data/openstack/variables-openstack.tf
index 279d58966..2e257d3c8 100644
--- a/data/data/openstack/variables-openstack.tf
+++ b/data/data/openstack/variables-openstack.tf
@@ -335,3 +335,8 @@ Contains 0 if the OpenStack Octavia endpoint is missing and 1 if it exists.
 EOF
 
 }
+
+variable "openstack_availability_zone" {
+  type        = string
+  description = "Name of availability zone to deploy cluster to."
+}
diff --git a/pkg/asset/cluster/tfvars.go b/pkg/asset/cluster/tfvars.go
index 2c5492d74..80edd165f 100644
--- a/pkg/asset/cluster/tfvars.go
+++ b/pkg/asset/cluster/tfvars.go
@@ -368,6 +368,7 @@ func (t *TerraformVariables) Generate(parents asset.Parents) error {
 		data, err = openstacktfvars.TFVars(
 			masters[0].Spec.ProviderSpec.Value.Object.(*openstackprovider.OpenstackProviderSpec),
 			installConfig.Config.Platform.OpenStack.Cloud,
+			installConfig.Config.Platform.OpenStack.AvailabilityZone,
 			installConfig.Config.Platform.OpenStack.ExternalNetwork,
 			installConfig.Config.Platform.OpenStack.ExternalDNS,
 			installConfig.Config.Platform.OpenStack.LbFloatingIP,
diff --git a/pkg/asset/installconfig/openstack/openstack.go b/pkg/asset/installconfig/openstack/openstack.go
index ee2f6c080..8ef890010 100644
--- a/pkg/asset/installconfig/openstack/openstack.go
+++ b/pkg/asset/installconfig/openstack/openstack.go
@@ -125,6 +125,34 @@ func Platform() (*openstack.Platform, error) {
 		return nil, err
 	}
 
+	availabilityZoneNames, err := validValuesFetcher.GetAvailabilityZoneNames(cloud)
+	if err != nil {
+		return nil, err
+	}
+	sort.Strings(availabilityZoneNames)
+	var availabilityZone string
+	err = survey.Ask([]*survey.Question{
+		{
+			Prompt: &survey.Select{
+				Message: "AvailabilityZone",
+				Help:    "The OpenStack availability zone to use for control-plane and compute nodes.",
+				Options: availabilityZoneNames,
+			},
+			Validate: survey.ComposeValidators(survey.Required, func(ans interface{}) error {
+				value := ans.(string)
+				i := sort.SearchStrings(availabilityZoneNames, value)
+				if i == len(availabilityZoneNames) || availabilityZoneNames[i] != value {
+					return errors.Errorf("invalid availability zone name %q, should be one of %+v", value, strings.Join(availabilityZoneNames, ", "))
+				}
+				return nil
+			}),
+		},
+	}, &availabilityZone)
+	if err != nil {
+		return nil, err
+	}
+
+
 	netExts, err := validValuesFetcher.GetNetworkExtensionsAliases(cloud)
 	if err != nil {
 		return nil, err
diff --git a/pkg/asset/machines/openstack/machines.go b/pkg/asset/machines/openstack/machines.go
index adedfbc28..df63db193 100644
--- a/pkg/asset/machines/openstack/machines.go
+++ b/pkg/asset/machines/openstack/machines.go
@@ -44,7 +44,7 @@ func Machines(clusterID string, config *types.InstallConfig, pool *types.Machine
 	}
 	var machines []machineapi.Machine
 	for idx := int64(0); idx < total; idx++ {
-		az := ""
+		az := config.Platform.OpenStack.AvailabilityZone
 		trunk := config.Platform.OpenStack.TrunkSupport
 		provider, err := provider(clusterID, platform, mpool, osImage, az, role, userDataSecret, trunk)
 		if err != nil {
diff --git a/pkg/asset/machines/openstack/machinesets.go b/pkg/asset/machines/openstack/machinesets.go
index c215e38de..e762b903b 100644
--- a/pkg/asset/machines/openstack/machinesets.go
+++ b/pkg/asset/machines/openstack/machinesets.go
@@ -31,7 +31,7 @@ func MachineSets(clusterID string, config *types.InstallConfig, pool *types.Mach
 
 	// TODO(flaper87): Add support for availability zones
 	var machinesets []*clusterapi.MachineSet
-	az := ""
+	az := config.Platform.OpenStack.AvailabilityZone
 	trunk := config.Platform.OpenStack.TrunkSupport
 	provider, err := provider(clusterID, platform, mpool, osImage, az, role, userDataSecret, trunk)
 	if err != nil {
diff --git a/pkg/tfvars/openstack/openstack.go b/pkg/tfvars/openstack/openstack.go
index 734070f46..4ac740848 100644
--- a/pkg/tfvars/openstack/openstack.go
+++ b/pkg/tfvars/openstack/openstack.go
@@ -18,6 +18,7 @@ import (
 type config struct {
 	BaseImageName          string   `json:"openstack_base_image_name,omitempty"`
 	BaseImageLocalFilePath string   `json:"openstack_base_image_local_file_path,omitempty"`
+	AvailabilityZone       string   `json:"openstack_availability_zone,omitempty"`
 	ExternalNetwork        string   `json:"openstack_external_network,omitempty"`
 	Cloud                  string   `json:"openstack_credentials_cloud,omitempty"`
 	FlavorName             string   `json:"openstack_master_flavor_name,omitempty"`
@@ -34,19 +35,20 @@ type config struct {
 }
 
 // TFVars generates OpenStack-specific Terraform variables.
-func TFVars(masterConfig *v1alpha1.OpenstackProviderSpec, cloud string, externalNetwork string, externalDNS []string, lbFloatingIP string, apiVIP string, dnsVIP string, ingressVIP string, trunkSupport string, octaviaSupport string, baseImage string, infraID string, userCA string, bootstrapIgn string) ([]byte, error) {
+func TFVars(masterConfig *v1alpha1.OpenstackProviderSpec, cloud string, availabilityZone string, externalNetwork string, externalDNS []string, lbFloatingIP string, apiVIP string, dnsVIP string, ingressVIP string, trunkSupport string, octaviaSupport string, baseImage string, infraID string, userCA string, bootstrapIgn string) ([]byte, error) {
 
 	cfg := &config{
-		ExternalNetwork: externalNetwork,
-		Cloud:           cloud,
-		FlavorName:      masterConfig.Flavor,
-		LbFloatingIP:    lbFloatingIP,
-		APIVIP:          apiVIP,
-		DNSVIP:          dnsVIP,
-		IngressVIP:      ingressVIP,
-		ExternalDNS:     externalDNS,
-		TrunkSupport:    trunkSupport,
-		OctaviaSupport:  octaviaSupport,
+		ExternalNetwork:  externalNetwork,
+		Cloud:            cloud,
+		AvailabilityZone: availabilityZone,
+		FlavorName:       masterConfig.Flavor,
+		LbFloatingIP:     lbFloatingIP,
+		APIVIP:           apiVIP,
+		DNSVIP:           dnsVIP,
+		IngressVIP:       ingressVIP,
+		ExternalDNS:      externalDNS,
+		TrunkSupport:     trunkSupport,
+		OctaviaSupport:   octaviaSupport,
 	}
 
 	// Normally baseImage contains a URL that we will use to create a new Glance image, but for testing
diff --git a/pkg/types/openstack/machinepool.go b/pkg/types/openstack/machinepool.go
index b05437932..473c41d2d 100644
--- a/pkg/types/openstack/machinepool.go
+++ b/pkg/types/openstack/machinepool.go
@@ -7,6 +7,10 @@ type MachinePool struct {
 	// eg. m1.large
 	FlavorName string `json:"type"`
 
+	// AvailabilityZone defines the OpenStack Nova AvailabilityZone.
+	// eg. nova
+	AvailabilityZone string `json:"availabilityZone,omitempty"`
+
 	// RootVolume defines the root volume for instances in the machine pool.
 	// The instances use ephemeral disks if not set.
 	// +optional
diff --git a/pkg/types/openstack/platform.go b/pkg/types/openstack/platform.go
index 13dcb5d6e..cc5dc5216 100644
--- a/pkg/types/openstack/platform.go
+++ b/pkg/types/openstack/platform.go
@@ -7,6 +7,9 @@ type Platform struct {
 	// Deprecated: this value is not used by the installer.
 	Region string `json:"region"`
 
+	// AvailabilityZone specifies the OpenStack availability zone where the cluster will be created.
+	AvailabilityZone string `json:"availabilityZone,omitempty"`
+
 	// DefaultMachinePlatform is the default configuration used when
 	// installing on OpenStack for machine pools which do not define their own
 	// platform configuration.
diff --git a/pkg/types/openstack/validation/platform.go b/pkg/types/openstack/validation/platform.go
index 3253aa3ee..44feb1268 100644
--- a/pkg/types/openstack/validation/platform.go
+++ b/pkg/types/openstack/validation/platform.go
@@ -31,6 +31,12 @@ func ValidatePlatform(p *openstack.Platform, n *types.Networking, fldPath *field
 		} else if !isValidValue(p.FlavorName, validFlavors) {
 			allErrs = append(allErrs, field.NotSupported(fldPath.Child("computeFlavor"), p.FlavorName, validFlavors))
 		}
+		validAvailabilityZones, err := fetcher.GetAvailabilityZoneNames(p.Cloud)
+		if err != nil {
+			allErrs = append(allErrs, field.InternalError(fldPath.Child("availabilityZone"), errors.New("could not retrieve valid availability zones")))
+		} else if !isValidValue(p.AvailabilityZone, validAvailabilityZones) {
+			allErrs = append(allErrs, field.NotSupported(fldPath.Child("availabilityZone"), p.AvailabilityZone, validAvailabilityZones))
+		}
 		netExts, err := fetcher.GetNetworkExtensionsAliases(p.Cloud)
 		if err != nil {
 			allErrs = append(allErrs, field.InternalError(fldPath.Child("trunkSupport"), errors.New("could not retrieve networking extension aliases")))
diff --git a/pkg/types/openstack/validation/realvalidvaluesfetcher.go b/pkg/types/openstack/validation/realvalidvaluesfetcher.go
index d58cb5136..419e409e2 100644
--- a/pkg/types/openstack/validation/realvalidvaluesfetcher.go
+++ b/pkg/types/openstack/validation/realvalidvaluesfetcher.go
@@ -5,6 +5,7 @@ import (
 
 	"github.com/gophercloud/gophercloud/openstack/common/extensions"
 	"github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones"
 	"github.com/gophercloud/gophercloud/openstack/identity/v3/tokens"
 	netext "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions"
 	"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/layer3/floatingips"
@@ -98,6 +99,39 @@ func (f realValidValuesFetcher) GetFlavorNames(cloud string) ([]string, error) {
 	return flavorNames, nil
 }
 
+// GetAvailabilityZoneNames gets a list of valid availability zone names.
+func (f realValidValuesFetcher) GetAvailabilityZoneNames(cloud string) ([]string, error) {
+	opts := &clientconfig.ClientOpts{
+		Cloud: cloud,
+	}
+
+	conn, err := clientconfig.NewServiceClient("compute", opts)
+	if err != nil {
+		return nil, err
+	}
+
+	allPages, err := availabilityzones.List(conn).AllPages()
+	if err != nil {
+		return nil, err
+	}
+
+	allAvailabilityZones, err := availabilityzones.ExtractAvailabilityZones(allPages)
+	if err != nil {
+		return nil, err
+	}
+
+	if len(allAvailabilityZones) == 0 {
+		return nil, errors.New("no OpenStack availability zones were found")
+	}
+
+	availabilityZoneNames := make([]string, len(allAvailabilityZones))
+	for i, availabilityZone := range allAvailabilityZones {
+		availabilityZoneNames[i] = availabilityZone.ZoneName
+	}
+
+	return availabilityZoneNames, nil
+}
+
 func (f realValidValuesFetcher) GetNetworkExtensionsAliases(cloud string) ([]string, error) {
 	opts := &clientconfig.ClientOpts{
 		Cloud: cloud,
diff --git a/pkg/types/openstack/validation/validvaluesfetcher.go b/pkg/types/openstack/validation/validvaluesfetcher.go
index 1b7d0a31b..a2778bef4 100644
--- a/pkg/types/openstack/validation/validvaluesfetcher.go
+++ b/pkg/types/openstack/validation/validvaluesfetcher.go
@@ -10,6 +10,8 @@ type ValidValuesFetcher interface {
 	GetNetworkNames(cloud string) ([]string, error)
 	// GetFlavorNames gets the valid flavor names.
 	GetFlavorNames(cloud string) ([]string, error)
+	// GetAvailabilityZoneNames gets the valid availability zone names.
+	GetAvailabilityZoneNames(cloud string) ([]string, error)
 	// GetNetworkExtensionsAliases gets the aliases for all the networking enabled extensions
 	GetNetworkExtensionsAliases(cloud string) ([]string, error)
 	// GetServiceCatalog gets the catalog service names
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/doc.go
new file mode 100644
index 000000000..97f1b033d
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/doc.go
@@ -0,0 +1,105 @@
+/*
+Package aggregates manages information about the host aggregates in the
+OpenStack cloud.
+
+Example of Create Aggregate
+
+	opts := aggregates.CreateOpts{
+		Name:             "name",
+		AvailabilityZone: "london",
+	}
+
+	aggregate, err := aggregates.Create(computeClient, opts).Extract()
+	if err != nil {
+		panic(err)
+	}
+	fmt.Printf("%+v\n", aggregate)
+
+Example of Show Aggregate Details
+
+	aggregateID := 42
+	aggregate, err := aggregates.Get(computeClient, aggregateID).Extract()
+	if err != nil {
+		panic(err)
+	}
+	fmt.Printf("%+v\n", aggregate)
+
+Example of Delete Aggregate
+
+	aggregateID := 32
+	err := aggregates.Delete(computeClient, aggregateID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+Example of Update Aggregate
+
+	aggregateID := 42
+	opts := aggregates.UpdateOpts{
+		Name:             "new_name",
+		AvailabilityZone: "nova2",
+	}
+
+	aggregate, err := aggregates.Update(computeClient, aggregateID, opts).Extract()
+	if err != nil {
+		panic(err)
+	}
+	fmt.Printf("%+v\n", aggregate)
+
+Example of Retrieving list of all aggregates
+
+	allPages, err := aggregates.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allAggregates, err := aggregates.ExtractAggregates(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, aggregate := range allAggregates {
+		fmt.Printf("%+v\n", aggregate)
+	}
+
+Example of Add Host
+
+	aggregateID := 22
+	opts := aggregates.AddHostOpts{
+		Host: "newhost-cmp1",
+	}
+
+	aggregate, err := aggregates.AddHost(computeClient, aggregateID, opts).Extract()
+	if err != nil {
+		panic(err)
+	}
+	fmt.Printf("%+v\n", aggregate)
+
+Example of Remove Host
+
+	aggregateID := 22
+	opts := aggregates.RemoveHostOpts{
+		Host: "newhost-cmp1",
+	}
+
+	aggregate, err := aggregates.RemoveHost(computeClient, aggregateID, opts).Extract()
+	if err != nil {
+		panic(err)
+	}
+	fmt.Printf("%+v\n", aggregate)
+
+Example of Create or Update Metadata
+
+	aggregateID := 22
+	opts := aggregates.SetMetadata{
+		Metadata: map[string]string{"key": "value"},
+	}
+
+	aggregate, err := aggregates.SetMetadata(computeClient, aggregateID, opts).Extract()
+	if err != nil {
+		panic(err)
+	}
+	fmt.Printf("%+v\n", aggregate)
+
+*/
+package aggregates
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/requests.go
new file mode 100644
index 000000000..c37531c56
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/requests.go
@@ -0,0 +1,162 @@
+package aggregates
+
+import (
+	"strconv"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List makes a request against the API to list aggregates.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, aggregatesListURL(client), func(r pagination.PageResult) pagination.Page {
+		return AggregatesPage{pagination.SinglePageBase(r)}
+	})
+}
+
+type CreateOpts struct {
+	// The name of the host aggregate.
+	Name string `json:"name" required:"true"`
+
+	// The availability zone of the host aggregate.
+	// You should use a custom availability zone rather than
+	// the default returned by the os-availability-zone API.
+	// The availability zone must not include ‘:’ in its name.
+	AvailabilityZone string `json:"availability_zone,omitempty"`
+}
+
+func (opts CreateOpts) ToAggregatesCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "aggregate")
+}
+
+// Create makes a request against the API to create an aggregate.
+func Create(client *gophercloud.ServiceClient, opts CreateOpts) (r CreateResult) {
+	b, err := opts.ToAggregatesCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(aggregatesCreateURL(client), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Delete makes a request against the API to delete an aggregate.
+func Delete(client *gophercloud.ServiceClient, aggregateID int) (r DeleteResult) {
+	v := strconv.Itoa(aggregateID)
+	_, r.Err = client.Delete(aggregatesDeleteURL(client, v), &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Get makes a request against the API to get details for a specific aggregate.
+func Get(client *gophercloud.ServiceClient, aggregateID int) (r GetResult) {
+	v := strconv.Itoa(aggregateID)
+	_, r.Err = client.Get(aggregatesGetURL(client, v), &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+type UpdateOpts struct {
+	// The name of the host aggregate.
+	Name string `json:"name,omitempty"`
+
+	// The availability zone of the host aggregate.
+	// You should use a custom availability zone rather than
+	// the default returned by the os-availability-zone API.
+	// The availability zone must not include ‘:’ in its name.
+	AvailabilityZone string `json:"availability_zone,omitempty"`
+}
+
+func (opts UpdateOpts) ToAggregatesUpdateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "aggregate")
+}
+
+// Update makes a request against the API to update a specific aggregate.
+func Update(client *gophercloud.ServiceClient, aggregateID int, opts UpdateOpts) (r UpdateResult) {
+	v := strconv.Itoa(aggregateID)
+
+	b, err := opts.ToAggregatesUpdateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Put(aggregatesUpdateURL(client, v), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+type AddHostOpts struct {
+	// The name of the host.
+	Host string `json:"host" required:"true"`
+}
+
+func (opts AddHostOpts) ToAggregatesAddHostMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "add_host")
+}
+
+// AddHost makes a request against the API to add host to a specific aggregate.
+func AddHost(client *gophercloud.ServiceClient, aggregateID int, opts AddHostOpts) (r ActionResult) {
+	v := strconv.Itoa(aggregateID)
+
+	b, err := opts.ToAggregatesAddHostMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(aggregatesAddHostURL(client, v), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+type RemoveHostOpts struct {
+	// The name of the host.
+	Host string `json:"host" required:"true"`
+}
+
+func (opts RemoveHostOpts) ToAggregatesRemoveHostMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "remove_host")
+}
+
+// RemoveHost makes a request against the API to remove host from a specific aggregate.
+func RemoveHost(client *gophercloud.ServiceClient, aggregateID int, opts RemoveHostOpts) (r ActionResult) {
+	v := strconv.Itoa(aggregateID)
+
+	b, err := opts.ToAggregatesRemoveHostMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(aggregatesRemoveHostURL(client, v), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+type SetMetadataOpts struct {
+	Metadata map[string]interface{} `json:"metadata" required:"true"`
+}
+
+func (opts SetMetadataOpts) ToSetMetadataMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "set_metadata")
+}
+
+// SetMetadata makes a request against the API to set metadata to a specific aggregate.
+func SetMetadata(client *gophercloud.ServiceClient, aggregateID int, opts SetMetadataOpts) (r ActionResult) {
+	v := strconv.Itoa(aggregateID)
+
+	b, err := opts.ToSetMetadataMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(aggregatesSetMetadataURL(client, v), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/results.go
new file mode 100644
index 000000000..2ab0cf22f
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/results.go
@@ -0,0 +1,117 @@
+package aggregates
+
+import (
+	"encoding/json"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// Aggregate represents a host aggregate in the OpenStack cloud.
+type Aggregate struct {
+	// The availability zone of the host aggregate.
+	AvailabilityZone string `json:"availability_zone"`
+
+	// A list of host ids in this aggregate.
+	Hosts []string `json:"hosts"`
+
+	// The ID of the host aggregate.
+	ID int `json:"id"`
+
+	// Metadata key and value pairs associate with the aggregate.
+	Metadata map[string]string `json:"metadata"`
+
+	// Name of the aggregate.
+	Name string `json:"name"`
+
+	// The date and time when the resource was created.
+	CreatedAt time.Time `json:"-"`
+
+	// The date and time when the resource was updated,
+	// if the resource has not been updated, this field will show as null.
+	UpdatedAt time.Time `json:"-"`
+
+	// The date and time when the resource was deleted,
+	// if the resource has not been deleted yet, this field will be null.
+	DeletedAt time.Time `json:"-"`
+
+	// A boolean indicates whether this aggregate is deleted or not,
+	// if it has not been deleted, false will appear.
+	Deleted bool `json:"deleted"`
+}
+
+// UnmarshalJSON to override default
+func (r *Aggregate) UnmarshalJSON(b []byte) error {
+	type tmp Aggregate
+	var s struct {
+		tmp
+		CreatedAt gophercloud.JSONRFC3339MilliNoZ `json:"created_at"`
+		UpdatedAt gophercloud.JSONRFC3339MilliNoZ `json:"updated_at"`
+		DeletedAt gophercloud.JSONRFC3339MilliNoZ `json:"deleted_at"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+	*r = Aggregate(s.tmp)
+
+	r.CreatedAt = time.Time(s.CreatedAt)
+	r.UpdatedAt = time.Time(s.UpdatedAt)
+	r.DeletedAt = time.Time(s.DeletedAt)
+
+	return nil
+}
+
+// AggregatesPage represents a single page of all Aggregates from a List
+// request.
+type AggregatesPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a page of Aggregates contains any results.
+func (page AggregatesPage) IsEmpty() (bool, error) {
+	aggregates, err := ExtractAggregates(page)
+	return len(aggregates) == 0, err
+}
+
+// ExtractAggregates interprets a page of results as a slice of Aggregates.
+func ExtractAggregates(p pagination.Page) ([]Aggregate, error) {
+	var a struct {
+		Aggregates []Aggregate `json:"aggregates"`
+	}
+	err := (p.(AggregatesPage)).ExtractInto(&a)
+	return a.Aggregates, err
+}
+
+type aggregatesResult struct {
+	gophercloud.Result
+}
+
+func (r aggregatesResult) Extract() (*Aggregate, error) {
+	var s struct {
+		Aggregate *Aggregate `json:"aggregate"`
+	}
+	err := r.ExtractInto(&s)
+	return s.Aggregate, err
+}
+
+type CreateResult struct {
+	aggregatesResult
+}
+
+type GetResult struct {
+	aggregatesResult
+}
+
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
+
+type UpdateResult struct {
+	aggregatesResult
+}
+
+type ActionResult struct {
+	aggregatesResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/testing/fixtures.go
new file mode 100644
index 000000000..9ae71d223
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/testing/fixtures.go
@@ -0,0 +1,344 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"strconv"
+	"testing"
+	"time"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// AggregateListBody is sample response to the List call
+const AggregateListBody = `
+{
+    "aggregates": [
+        {
+            "name": "test-aggregate1",
+            "availability_zone": null,
+            "deleted": false,
+            "created_at": "2017-12-22T10:12:06.000000",
+            "updated_at": null,
+            "hosts": [],
+            "deleted_at": null,
+            "id": 1,
+            "metadata": {}
+        },
+        {
+            "name": "test-aggregate2",
+            "availability_zone": "test-az",
+            "deleted": false,
+            "created_at": "2017-12-22T10:16:07.000000",
+            "updated_at": null,
+            "hosts": [
+                "cmp0"
+            ],
+            "deleted_at": null,
+            "id": 4,
+            "metadata": {
+                "availability_zone": "test-az"
+            }
+        }
+    ]
+}
+`
+
+const AggregateCreateBody = `
+{
+    "aggregate": {
+        "availability_zone": "london",
+        "created_at": "2016-12-27T22:51:32.000000",
+        "deleted": false,
+        "deleted_at": null,
+        "id": 32,
+        "name": "name",
+        "updated_at": null
+    }
+}
+`
+
+const AggregateGetBody = `
+{
+    "aggregate": {
+            "name": "test-aggregate2",
+            "availability_zone": "test-az",
+            "deleted": false,
+            "created_at": "2017-12-22T10:16:07.000000",
+            "updated_at": null,
+            "hosts": [
+                "cmp0"
+            ],
+            "deleted_at": null,
+            "id": 4,
+            "metadata": {
+                "availability_zone": "test-az"
+            }
+        }
+}
+`
+
+const AggregateUpdateBody = `
+{
+    "aggregate": {
+            "name": "test-aggregate2",
+            "availability_zone": "nova2",
+            "deleted": false,
+            "created_at": "2017-12-22T10:12:06.000000",
+            "updated_at": "2017-12-23T10:18:00.000000",
+            "hosts": [],
+            "deleted_at": null,
+            "id": 1,
+            "metadata": {
+                "availability_zone": "nova2"
+            }
+        }
+}
+`
+
+const AggregateAddHostBody = `
+{
+    "aggregate": {
+            "name": "test-aggregate2",
+            "availability_zone": "test-az",
+            "deleted": false,
+            "created_at": "2017-12-22T10:16:07.000000",
+            "updated_at": null,
+            "hosts": [
+                "cmp0",
+				"cmp1"
+            ],
+            "deleted_at": null,
+            "id": 4,
+            "metadata": {
+                "availability_zone": "test-az"
+            }
+        }
+}
+`
+
+const AggregateRemoveHostBody = `
+{
+    "aggregate": {
+            "name": "test-aggregate2",
+            "availability_zone": "nova2",
+            "deleted": false,
+            "created_at": "2017-12-22T10:12:06.000000",
+            "updated_at": "2017-12-23T10:18:00.000000",
+            "hosts": [],
+            "deleted_at": null,
+            "id": 1,
+            "metadata": {
+                "availability_zone": "nova2"
+            }
+        }
+}
+`
+
+const AggregateSetMetadataBody = `
+{
+    "aggregate": {
+            "name": "test-aggregate2",
+            "availability_zone": "test-az",
+            "deleted": false,
+            "created_at": "2017-12-22T10:16:07.000000",
+            "updated_at": "2017-12-23T10:18:00.000000",
+            "hosts": [
+                "cmp0"
+            ],
+            "deleted_at": null,
+            "id": 4,
+            "metadata": {
+                "availability_zone": "test-az",
+				"key": "value"
+            }
+        }
+}
+`
+
+var (
+	// First aggregate from the AggregateListBody
+	FirstFakeAggregate = aggregates.Aggregate{
+		AvailabilityZone: "",
+		Hosts:            []string{},
+		ID:               1,
+		Metadata:         map[string]string{},
+		Name:             "test-aggregate1",
+		CreatedAt:        time.Date(2017, 12, 22, 10, 12, 6, 0, time.UTC),
+		UpdatedAt:        time.Time{},
+		DeletedAt:        time.Time{},
+		Deleted:          false,
+	}
+
+	// Second aggregate from the AggregateListBody
+	SecondFakeAggregate = aggregates.Aggregate{
+		AvailabilityZone: "test-az",
+		Hosts:            []string{"cmp0"},
+		ID:               4,
+		Metadata:         map[string]string{"availability_zone": "test-az"},
+		Name:             "test-aggregate2",
+		CreatedAt:        time.Date(2017, 12, 22, 10, 16, 7, 0, time.UTC),
+		UpdatedAt:        time.Time{},
+		DeletedAt:        time.Time{},
+		Deleted:          false,
+	}
+
+	// Aggregate from the AggregateCreateBody
+	CreatedAggregate = aggregates.Aggregate{
+		AvailabilityZone: "london",
+		Hosts:            nil,
+		ID:               32,
+		Metadata:         nil,
+		Name:             "name",
+		CreatedAt:        time.Date(2016, 12, 27, 22, 51, 32, 0, time.UTC),
+		UpdatedAt:        time.Time{},
+		DeletedAt:        time.Time{},
+		Deleted:          false,
+	}
+
+	// Aggregate ID to delete
+	AggregateIDtoDelete = 1
+
+	// Aggregate ID to get, from the AggregateGetBody
+	AggregateIDtoGet = SecondFakeAggregate.ID
+
+	// Aggregate ID to update
+	AggregateIDtoUpdate = FirstFakeAggregate.ID
+
+	// Updated aggregate
+	UpdatedAggregate = aggregates.Aggregate{
+		AvailabilityZone: "nova2",
+		Hosts:            []string{},
+		ID:               1,
+		Metadata:         map[string]string{"availability_zone": "nova2"},
+		Name:             "test-aggregate2",
+		CreatedAt:        time.Date(2017, 12, 22, 10, 12, 6, 0, time.UTC),
+		UpdatedAt:        time.Date(2017, 12, 23, 10, 18, 0, 0, time.UTC),
+		DeletedAt:        time.Time{},
+		Deleted:          false,
+	}
+
+	AggregateWithAddedHost = aggregates.Aggregate{
+		AvailabilityZone: "test-az",
+		Hosts:            []string{"cmp0", "cmp1"},
+		ID:               4,
+		Metadata:         map[string]string{"availability_zone": "test-az"},
+		Name:             "test-aggregate2",
+		CreatedAt:        time.Date(2017, 12, 22, 10, 16, 7, 0, time.UTC),
+		UpdatedAt:        time.Time{},
+		DeletedAt:        time.Time{},
+		Deleted:          false,
+	}
+
+	AggregateWithRemovedHost = aggregates.Aggregate{
+		AvailabilityZone: "nova2",
+		Hosts:            []string{},
+		ID:               1,
+		Metadata:         map[string]string{"availability_zone": "nova2"},
+		Name:             "test-aggregate2",
+		CreatedAt:        time.Date(2017, 12, 22, 10, 12, 6, 0, time.UTC),
+		UpdatedAt:        time.Date(2017, 12, 23, 10, 18, 0, 0, time.UTC),
+		DeletedAt:        time.Time{},
+		Deleted:          false,
+	}
+
+	AggregateWithUpdatedMetadata = aggregates.Aggregate{
+		AvailabilityZone: "test-az",
+		Hosts:            []string{"cmp0"},
+		ID:               4,
+		Metadata:         map[string]string{"availability_zone": "test-az", "key": "value"},
+		Name:             "test-aggregate2",
+		CreatedAt:        time.Date(2017, 12, 22, 10, 16, 7, 0, time.UTC),
+		UpdatedAt:        time.Date(2017, 12, 23, 10, 18, 0, 0, time.UTC),
+		DeletedAt:        time.Time{},
+		Deleted:          false,
+	}
+)
+
+// HandleListSuccessfully configures the test server to respond to a List request.
+func HandleListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-aggregates", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, AggregateListBody)
+	})
+}
+
+func HandleCreateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-aggregates", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, AggregateCreateBody)
+	})
+}
+
+func HandleDeleteSuccessfully(t *testing.T) {
+	v := strconv.Itoa(AggregateIDtoDelete)
+	th.Mux.HandleFunc("/os-aggregates/"+v, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.WriteHeader(http.StatusOK)
+	})
+}
+
+func HandleGetSuccessfully(t *testing.T) {
+	v := strconv.Itoa(AggregateIDtoGet)
+	th.Mux.HandleFunc("/os-aggregates/"+v, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, AggregateGetBody)
+	})
+}
+
+func HandleUpdateSuccessfully(t *testing.T) {
+	v := strconv.Itoa(AggregateIDtoUpdate)
+	th.Mux.HandleFunc("/os-aggregates/"+v, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "PUT")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, AggregateUpdateBody)
+	})
+}
+
+func HandleAddHostSuccessfully(t *testing.T) {
+	v := strconv.Itoa(AggregateWithAddedHost.ID)
+	th.Mux.HandleFunc("/os-aggregates/"+v+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, AggregateAddHostBody)
+	})
+}
+
+func HandleRemoveHostSuccessfully(t *testing.T) {
+	v := strconv.Itoa(AggregateWithRemovedHost.ID)
+	th.Mux.HandleFunc("/os-aggregates/"+v+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, AggregateRemoveHostBody)
+	})
+}
+
+func HandleSetMetadataSuccessfully(t *testing.T) {
+	v := strconv.Itoa(AggregateWithUpdatedMetadata.ID)
+	th.Mux.HandleFunc("/os-aggregates/"+v+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, AggregateSetMetadataBody)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/testing/requests_test.go
new file mode 100644
index 000000000..bfd18614c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/testing/requests_test.go
@@ -0,0 +1,149 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestListAggregates(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleListSuccessfully(t)
+
+	pages := 0
+	err := aggregates.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		pages++
+
+		actual, err := aggregates.ExtractAggregates(page)
+		if err != nil {
+			return false, err
+		}
+
+		if len(actual) != 2 {
+			t.Fatalf("Expected 2 aggregates, got %d", len(actual))
+		}
+		th.CheckDeepEquals(t, FirstFakeAggregate, actual[0])
+		th.CheckDeepEquals(t, SecondFakeAggregate, actual[1])
+
+		return true, nil
+	})
+
+	th.AssertNoErr(t, err)
+
+	if pages != 1 {
+		t.Errorf("Expected 1 page, saw %d", pages)
+	}
+}
+
+func TestCreateAggregates(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleCreateSuccessfully(t)
+
+	expected := CreatedAggregate
+
+	opts := aggregates.CreateOpts{
+		Name:             "name",
+		AvailabilityZone: "london",
+	}
+
+	actual, err := aggregates.Create(client.ServiceClient(), opts).Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertDeepEquals(t, &expected, actual)
+}
+
+func TestDeleteAggregates(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleDeleteSuccessfully(t)
+
+	err := aggregates.Delete(client.ServiceClient(), AggregateIDtoDelete).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestGetAggregates(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSuccessfully(t)
+
+	expected := SecondFakeAggregate
+
+	actual, err := aggregates.Get(client.ServiceClient(), AggregateIDtoGet).Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertDeepEquals(t, &expected, actual)
+}
+
+func TestUpdateAggregate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleUpdateSuccessfully(t)
+
+	expected := UpdatedAggregate
+
+	opts := aggregates.UpdateOpts{
+		Name:             "test-aggregates2",
+		AvailabilityZone: "nova2",
+	}
+
+	actual, err := aggregates.Update(client.ServiceClient(), expected.ID, opts).Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertDeepEquals(t, &expected, actual)
+}
+
+func TestAddHostAggregate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleAddHostSuccessfully(t)
+
+	expected := AggregateWithAddedHost
+
+	opts := aggregates.AddHostOpts{
+		Host: "cmp1",
+	}
+
+	actual, err := aggregates.AddHost(client.ServiceClient(), expected.ID, opts).Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertDeepEquals(t, &expected, actual)
+}
+
+func TestRemoveHostAggregate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleRemoveHostSuccessfully(t)
+
+	expected := AggregateWithRemovedHost
+
+	opts := aggregates.RemoveHostOpts{
+		Host: "cmp1",
+	}
+
+	actual, err := aggregates.RemoveHost(client.ServiceClient(), expected.ID, opts).Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertDeepEquals(t, &expected, actual)
+}
+
+func TestSetMetadataAggregate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleSetMetadataSuccessfully(t)
+
+	expected := AggregateWithUpdatedMetadata
+
+	opts := aggregates.SetMetadataOpts{
+		Metadata: map[string]interface{}{"key": "value"},
+	}
+
+	actual, err := aggregates.SetMetadata(client.ServiceClient(), expected.ID, opts).Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertDeepEquals(t, &expected, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/urls.go
new file mode 100644
index 000000000..bb30c7fc9
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates/urls.go
@@ -0,0 +1,35 @@
+package aggregates
+
+import "github.com/gophercloud/gophercloud"
+
+func aggregatesListURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL("os-aggregates")
+}
+
+func aggregatesCreateURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL("os-aggregates")
+}
+
+func aggregatesDeleteURL(c *gophercloud.ServiceClient, aggregateID string) string {
+	return c.ServiceURL("os-aggregates", aggregateID)
+}
+
+func aggregatesGetURL(c *gophercloud.ServiceClient, aggregateID string) string {
+	return c.ServiceURL("os-aggregates", aggregateID)
+}
+
+func aggregatesUpdateURL(c *gophercloud.ServiceClient, aggregateID string) string {
+	return c.ServiceURL("os-aggregates", aggregateID)
+}
+
+func aggregatesAddHostURL(c *gophercloud.ServiceClient, aggregateID string) string {
+	return c.ServiceURL("os-aggregates", aggregateID, "action")
+}
+
+func aggregatesRemoveHostURL(c *gophercloud.ServiceClient, aggregateID string) string {
+	return c.ServiceURL("os-aggregates", aggregateID, "action")
+}
+
+func aggregatesSetMetadataURL(c *gophercloud.ServiceClient, aggregateID string) string {
+	return c.ServiceURL("os-aggregates", aggregateID, "action")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/doc.go
new file mode 100644
index 000000000..3653122bf
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/doc.go
@@ -0,0 +1,52 @@
+/*
+Package attachinterfaces provides the ability to retrieve and manage network
+interfaces through Nova.
+
+Example of Listing a Server's Interfaces
+
+	serverID := "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f"
+	allPages, err := attachinterfaces.List(computeClient, serverID).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allInterfaces, err := attachinterfaces.ExtractInterfaces(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, interface := range allInterfaces {
+		fmt.Printf("%+v\n", interface)
+	}
+
+Example to Get a Server's Interface
+
+	portID = "0dde1598-b374-474e-986f-5b8dd1df1d4e"
+	serverID := "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f"
+	interface, err := attachinterfaces.Get(computeClient, serverID, portID).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Create a new Interface attachment on the Server
+
+	networkID := "8a5fe506-7e9f-4091-899b-96336909d93c"
+	serverID := "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f"
+	attachOpts := attachinterfaces.CreateOpts{
+		NetworkID: networkID,
+	}
+	interface, err := attachinterfaces.Create(computeClient, serverID, attachOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Delete an Interface attachment from the Server
+
+	portID = "0dde1598-b374-474e-986f-5b8dd1df1d4e"
+	serverID := "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f"
+	err := attachinterfaces.Delete(computeClient, serverID, portID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package attachinterfaces
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/requests.go
new file mode 100644
index 000000000..874f7a61e
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/requests.go
@@ -0,0 +1,72 @@
+package attachinterfaces
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List makes a request against the nova API to list the server's interfaces.
+func List(client *gophercloud.ServiceClient, serverID string) pagination.Pager {
+	return pagination.NewPager(client, listInterfaceURL(client, serverID), func(r pagination.PageResult) pagination.Page {
+		return InterfacePage{pagination.SinglePageBase(r)}
+	})
+}
+
+// Get requests details on a single interface attachment by the server and port IDs.
+func Get(client *gophercloud.ServiceClient, serverID, portID string) (r GetResult) {
+	_, r.Err = client.Get(getInterfaceURL(client, serverID, portID), &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// CreateOptsBuilder allows extensions to add additional parameters to the
+// Create request.
+type CreateOptsBuilder interface {
+	ToAttachInterfacesCreateMap() (map[string]interface{}, error)
+}
+
+// CreateOpts specifies parameters of a new interface attachment.
+type CreateOpts struct {
+	// PortID is the ID of the port for which you want to create an interface.
+	// The NetworkID and PortID parameters are mutually exclusive.
+	// If you do not specify the PortID parameter, the OpenStack Networking API
+	// v2.0 allocates a port and creates an interface for it on the network.
+	PortID string `json:"port_id,omitempty"`
+
+	// NetworkID is the ID of the network for which you want to create an interface.
+	// The NetworkID and PortID parameters are mutually exclusive.
+	// If you do not specify the NetworkID parameter, the OpenStack Networking
+	// API v2.0 uses the network information cache that is associated with the instance.
+	NetworkID string `json:"net_id,omitempty"`
+
+	// Slice of FixedIPs. If you request a specific FixedIP address without a
+	// NetworkID, the request returns a Bad Request (400) response code.
+	// Note: this uses the FixedIP struct, but only the IPAddress field can be used.
+	FixedIPs []FixedIP `json:"fixed_ips,omitempty"`
+}
+
+// ToAttachInterfacesCreateMap constructs a request body from CreateOpts.
+func (opts CreateOpts) ToAttachInterfacesCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "interfaceAttachment")
+}
+
+// Create requests the creation of a new interface attachment on the server.
+func Create(client *gophercloud.ServiceClient, serverID string, opts CreateOptsBuilder) (r CreateResult) {
+	b, err := opts.ToAttachInterfacesCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(createInterfaceURL(client, serverID), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Delete makes a request against the nova API to detach a single interface from the server.
+// It needs server and port IDs to make a such request.
+func Delete(client *gophercloud.ServiceClient, serverID, portID string) (r DeleteResult) {
+	_, r.Err = client.Delete(deleteInterfaceURL(client, serverID, portID), nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/results.go
new file mode 100644
index 000000000..7d15e1ecb
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/results.go
@@ -0,0 +1,80 @@
+package attachinterfaces
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+type attachInterfaceResult struct {
+	gophercloud.Result
+}
+
+// Extract interprets any attachInterfaceResult as an Interface, if possible.
+func (r attachInterfaceResult) Extract() (*Interface, error) {
+	var s struct {
+		Interface *Interface `json:"interfaceAttachment"`
+	}
+	err := r.ExtractInto(&s)
+	return s.Interface, err
+}
+
+// GetResult is the response from a Get operation. Call its Extract
+// method to interpret it as an Interface.
+type GetResult struct {
+	attachInterfaceResult
+}
+
+// CreateResult is the response from a Create operation. Call its Extract
+// method to interpret it as an Interface.
+type CreateResult struct {
+	attachInterfaceResult
+}
+
+// DeleteResult is the response from a Delete operation. Call its ExtractErr
+// method to determine if the call succeeded or failed.
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
+
+// FixedIP represents a Fixed IP Address.
+// This struct is also used when creating an attachment,
+// but it is not possible to specify a SubnetID.
+type FixedIP struct {
+	SubnetID  string `json:"subnet_id,omitempty"`
+	IPAddress string `json:"ip_address"`
+}
+
+// Interface represents a network interface on a server.
+type Interface struct {
+	PortState string    `json:"port_state"`
+	FixedIPs  []FixedIP `json:"fixed_ips"`
+	PortID    string    `json:"port_id"`
+	NetID     string    `json:"net_id"`
+	MACAddr   string    `json:"mac_addr"`
+}
+
+// InterfacePage abstracts the raw results of making a List() request against
+// the API.
+//
+// As OpenStack extensions may freely alter the response bodies of structures
+// returned to the client, you may only safely access the data provided through
+// the ExtractInterfaces call.
+type InterfacePage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty returns true if an InterfacePage contains no interfaces.
+func (r InterfacePage) IsEmpty() (bool, error) {
+	interfaces, err := ExtractInterfaces(r)
+	return len(interfaces) == 0, err
+}
+
+// ExtractInterfaces interprets the results of a single page from a List() call,
+// producing a slice of Interface structs.
+func ExtractInterfaces(r pagination.Page) ([]Interface, error) {
+	var s struct {
+		Interfaces []Interface `json:"interfaceAttachments"`
+	}
+	err := (r.(InterfacePage)).ExtractInto(&s)
+	return s.Interfaces, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/doc.go
new file mode 100644
index 000000000..cfc07ad55
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/doc.go
@@ -0,0 +1,2 @@
+// attachinterfaces unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/fixtures.go
new file mode 100644
index 000000000..e701a93fc
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/fixtures.go
@@ -0,0 +1,162 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ListInterfacesExpected represents an expected repsonse from a ListInterfaces request.
+var ListInterfacesExpected = []attachinterfaces.Interface{
+	{
+		PortState: "ACTIVE",
+		FixedIPs: []attachinterfaces.FixedIP{
+			{
+				SubnetID:  "d7906db4-a566-4546-b1f4-5c7fa70f0bf3",
+				IPAddress: "10.0.0.7",
+			},
+			{
+				SubnetID:  "45906d64-a548-4276-h1f8-kcffa80fjbnl",
+				IPAddress: "10.0.0.8",
+			},
+		},
+		PortID:  "0dde1598-b374-474e-986f-5b8dd1df1d4e",
+		NetID:   "8a5fe506-7e9f-4091-899b-96336909d93c",
+		MACAddr: "fa:16:3e:38:2d:80",
+	},
+}
+
+// GetInterfaceExpected represents an expected repsonse from a GetInterface request.
+var GetInterfaceExpected = attachinterfaces.Interface{
+	PortState: "ACTIVE",
+	FixedIPs: []attachinterfaces.FixedIP{
+		{
+			SubnetID:  "d7906db4-a566-4546-b1f4-5c7fa70f0bf3",
+			IPAddress: "10.0.0.7",
+		},
+		{
+			SubnetID:  "45906d64-a548-4276-h1f8-kcffa80fjbnl",
+			IPAddress: "10.0.0.8",
+		},
+	},
+	PortID:  "0dde1598-b374-474e-986f-5b8dd1df1d4e",
+	NetID:   "8a5fe506-7e9f-4091-899b-96336909d93c",
+	MACAddr: "fa:16:3e:38:2d:80",
+}
+
+// CreateInterfacesExpected represents an expected repsonse from a CreateInterface request.
+var CreateInterfacesExpected = attachinterfaces.Interface{
+	PortState: "ACTIVE",
+	FixedIPs: []attachinterfaces.FixedIP{
+		{
+			SubnetID:  "d7906db4-a566-4546-b1f4-5c7fa70f0bf3",
+			IPAddress: "10.0.0.7",
+		},
+	},
+	PortID:  "0dde1598-b374-474e-986f-5b8dd1df1d4e",
+	NetID:   "8a5fe506-7e9f-4091-899b-96336909d93c",
+	MACAddr: "fa:16:3e:38:2d:80",
+}
+
+// HandleInterfaceListSuccessfully sets up the test server to respond to a ListInterfaces request.
+func HandleInterfaceListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/b07e7a3b-d951-4efc-a4f9-ac9f001afb7f/os-interface", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, `{
+			"interfaceAttachments": [
+				{
+					"port_state":"ACTIVE",
+					"fixed_ips": [
+						{
+							"subnet_id": "d7906db4-a566-4546-b1f4-5c7fa70f0bf3",
+							"ip_address": "10.0.0.7"
+						},
+						{
+							"subnet_id": "45906d64-a548-4276-h1f8-kcffa80fjbnl",
+							"ip_address": "10.0.0.8"
+						}
+					],
+					"port_id": "0dde1598-b374-474e-986f-5b8dd1df1d4e",
+					"net_id": "8a5fe506-7e9f-4091-899b-96336909d93c",
+					"mac_addr": "fa:16:3e:38:2d:80"
+				}
+			]
+		}`)
+	})
+}
+
+// HandleInterfaceGetSuccessfully sets up the test server to respond to a GetInterface request.
+func HandleInterfaceGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/b07e7a3b-d951-4efc-a4f9-ac9f001afb7f/os-interface/0dde1598-b374-474e-986f-5b8dd1df1d4e", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, `{
+			"interfaceAttachment":
+				{
+					"port_state":"ACTIVE",
+					"fixed_ips": [
+						{
+							"subnet_id": "d7906db4-a566-4546-b1f4-5c7fa70f0bf3",
+							"ip_address": "10.0.0.7"
+						},
+						{
+							"subnet_id": "45906d64-a548-4276-h1f8-kcffa80fjbnl",
+							"ip_address": "10.0.0.8"
+						}
+					],
+					"port_id": "0dde1598-b374-474e-986f-5b8dd1df1d4e",
+					"net_id": "8a5fe506-7e9f-4091-899b-96336909d93c",
+					"mac_addr": "fa:16:3e:38:2d:80"
+				}
+		}`)
+	})
+}
+
+// HandleInterfaceCreateSuccessfully sets up the test server to respond to a CreateInterface request.
+func HandleInterfaceCreateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/b07e7a3b-d951-4efc-a4f9-ac9f001afb7f/os-interface", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{
+			  "interfaceAttachment": {
+				"net_id": "8a5fe506-7e9f-4091-899b-96336909d93c"
+			  }
+		}`)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, `{
+			"interfaceAttachment":
+				{
+					"port_state":"ACTIVE",
+					"fixed_ips": [
+						{
+							"subnet_id": "d7906db4-a566-4546-b1f4-5c7fa70f0bf3",
+							"ip_address": "10.0.0.7"
+						}
+					],
+					"port_id": "0dde1598-b374-474e-986f-5b8dd1df1d4e",
+					"net_id": "8a5fe506-7e9f-4091-899b-96336909d93c",
+					"mac_addr": "fa:16:3e:38:2d:80"
+				}
+		}`)
+	})
+}
+
+// HandleInterfaceDeleteSuccessfully sets up the test server to respond to a DeleteInterface request.
+func HandleInterfaceDeleteSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/b07e7a3b-d951-4efc-a4f9-ac9f001afb7f/os-interface/0dde1598-b374-474e-986f-5b8dd1df1d4e", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/requests_test.go
new file mode 100644
index 000000000..1ffbd61e7
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/testing/requests_test.go
@@ -0,0 +1,89 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestListInterface(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleInterfaceListSuccessfully(t)
+
+	expected := ListInterfacesExpected
+	pages := 0
+	err := attachinterfaces.List(client.ServiceClient(), "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f").EachPage(func(page pagination.Page) (bool, error) {
+		pages++
+
+		actual, err := attachinterfaces.ExtractInterfaces(page)
+		th.AssertNoErr(t, err)
+
+		if len(actual) != 1 {
+			t.Fatalf("Expected 1 interface, got %d", len(actual))
+		}
+		th.CheckDeepEquals(t, expected, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.CheckEquals(t, 1, pages)
+}
+
+func TestListInterfacesAllPages(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleInterfaceListSuccessfully(t)
+
+	allPages, err := attachinterfaces.List(client.ServiceClient(), "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f").AllPages()
+	th.AssertNoErr(t, err)
+	_, err = attachinterfaces.ExtractInterfaces(allPages)
+	th.AssertNoErr(t, err)
+}
+
+func TestGetInterface(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleInterfaceGetSuccessfully(t)
+
+	expected := GetInterfaceExpected
+
+	serverID := "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f"
+	interfaceID := "0dde1598-b374-474e-986f-5b8dd1df1d4e"
+
+	actual, err := attachinterfaces.Get(client.ServiceClient(), serverID, interfaceID).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &expected, actual)
+}
+
+func TestCreateInterface(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleInterfaceCreateSuccessfully(t)
+
+	expected := CreateInterfacesExpected
+
+	serverID := "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f"
+	networkID := "8a5fe506-7e9f-4091-899b-96336909d93c"
+
+	actual, err := attachinterfaces.Create(client.ServiceClient(), serverID, attachinterfaces.CreateOpts{
+		NetworkID: networkID,
+	}).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &expected, actual)
+}
+
+func TestDeleteInterface(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleInterfaceDeleteSuccessfully(t)
+
+	serverID := "b07e7a3b-d951-4efc-a4f9-ac9f001afb7f"
+	portID := "0dde1598-b374-474e-986f-5b8dd1df1d4e"
+
+	err := attachinterfaces.Delete(client.ServiceClient(), serverID, portID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/urls.go
new file mode 100644
index 000000000..50292e8b5
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/attachinterfaces/urls.go
@@ -0,0 +1,18 @@
+package attachinterfaces
+
+import "github.com/gophercloud/gophercloud"
+
+func listInterfaceURL(client *gophercloud.ServiceClient, serverID string) string {
+	return client.ServiceURL("servers", serverID, "os-interface")
+}
+
+func getInterfaceURL(client *gophercloud.ServiceClient, serverID, portID string) string {
+	return client.ServiceURL("servers", serverID, "os-interface", portID)
+}
+
+func createInterfaceURL(client *gophercloud.ServiceClient, serverID string) string {
+	return client.ServiceURL("servers", serverID, "os-interface")
+}
+func deleteInterfaceURL(client *gophercloud.ServiceClient, serverID, portID string) string {
+	return client.ServiceURL("servers", serverID, "os-interface", portID)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/doc.go
new file mode 100644
index 000000000..29b554d21
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/doc.go
@@ -0,0 +1,61 @@
+/*
+Package availabilityzones provides the ability to get lists and detailed
+availability zone information and to extend a server result with
+availability zone information.
+
+Example of Extend server result with Availability Zone Information:
+
+	type ServerWithAZ struct {
+		servers.Server
+		availabilityzones.ServerAvailabilityZoneExt
+	}
+
+	var allServers []ServerWithAZ
+
+	allPages, err := servers.List(client, nil).AllPages()
+	if err != nil {
+		panic("Unable to retrieve servers: %s", err)
+	}
+
+	err = servers.ExtractServersInto(allPages, &allServers)
+	if err != nil {
+		panic("Unable to extract servers: %s", err)
+	}
+
+	for _, server := range allServers {
+		fmt.Println(server.AvailabilityZone)
+	}
+
+Example of Get Availability Zone Information
+
+	allPages, err := availabilityzones.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	availabilityZoneInfo, err := availabilityzones.ExtractAvailabilityZones(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, zoneInfo := range availabilityZoneInfo {
+  		fmt.Printf("%+v\n", zoneInfo)
+	}
+
+Example of Get Detailed Availability Zone Information
+
+	allPages, err := availabilityzones.ListDetail(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	availabilityZoneInfo, err := availabilityzones.ExtractAvailabilityZones(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, zoneInfo := range availabilityZoneInfo {
+  		fmt.Printf("%+v\n", zoneInfo)
+	}
+*/
+package availabilityzones
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/requests.go
new file mode 100644
index 000000000..f9a2e86e0
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/requests.go
@@ -0,0 +1,20 @@
+package availabilityzones
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List will return the existing availability zones.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, listURL(client), func(r pagination.PageResult) pagination.Page {
+		return AvailabilityZonePage{pagination.SinglePageBase(r)}
+	})
+}
+
+// ListDetail will return the existing availability zones with detailed information.
+func ListDetail(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, listDetailURL(client), func(r pagination.PageResult) pagination.Page {
+		return AvailabilityZonePage{pagination.SinglePageBase(r)}
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/results.go
new file mode 100644
index 000000000..d48a0ea85
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/results.go
@@ -0,0 +1,76 @@
+package availabilityzones
+
+import (
+	"encoding/json"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// ServerAvailabilityZoneExt is an extension to the base Server object.
+type ServerAvailabilityZoneExt struct {
+	// AvailabilityZone is the availabilty zone the server is in.
+	AvailabilityZone string `json:"OS-EXT-AZ:availability_zone"`
+}
+
+// ServiceState represents the state of a service in an AvailabilityZone.
+type ServiceState struct {
+	Active    bool      `json:"active"`
+	Available bool      `json:"available"`
+	UpdatedAt time.Time `json:"-"`
+}
+
+// UnmarshalJSON to override default
+func (r *ServiceState) UnmarshalJSON(b []byte) error {
+	type tmp ServiceState
+	var s struct {
+		tmp
+		UpdatedAt gophercloud.JSONRFC3339MilliNoZ `json:"updated_at"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+	*r = ServiceState(s.tmp)
+
+	r.UpdatedAt = time.Time(s.UpdatedAt)
+
+	return nil
+}
+
+// Services is a map of services contained in an AvailabilityZone.
+type Services map[string]ServiceState
+
+// Hosts is map of hosts/nodes contained in an AvailabilityZone.
+// Each host can have multiple services.
+type Hosts map[string]Services
+
+// ZoneState represents the current state of the availability zone.
+type ZoneState struct {
+	// Returns true if the availability zone is available
+	Available bool `json:"available"`
+}
+
+// AvailabilityZone contains all the information associated with an OpenStack
+// AvailabilityZone.
+type AvailabilityZone struct {
+	Hosts Hosts `json:"hosts"`
+	// The availability zone name
+	ZoneName  string    `json:"zoneName"`
+	ZoneState ZoneState `json:"zoneState"`
+}
+
+type AvailabilityZonePage struct {
+	pagination.SinglePageBase
+}
+
+// ExtractAvailabilityZones returns a slice of AvailabilityZones contained in a
+// single page of results.
+func ExtractAvailabilityZones(r pagination.Page) ([]AvailabilityZone, error) {
+	var s struct {
+		AvailabilityZoneInfo []AvailabilityZone `json:"availabilityZoneInfo"`
+	}
+	err := (r.(AvailabilityZonePage)).ExtractInto(&s)
+	return s.AvailabilityZoneInfo, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/doc.go
new file mode 100644
index 000000000..a4408d7a0
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/doc.go
@@ -0,0 +1,2 @@
+// availabilityzones unittests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/fixtures.go
new file mode 100644
index 000000000..9cc6d4637
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/fixtures.go
@@ -0,0 +1,197 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+	"time"
+
+	az "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const GetOutput = `
+{
+    "availabilityZoneInfo": [
+        {
+            "hosts": null,
+            "zoneName": "nova",
+            "zoneState": {
+                "available": true
+            }
+        }
+    ]
+}
+`
+
+const GetDetailOutput = `
+{
+    "availabilityZoneInfo": [
+        {
+            "hosts": {
+                "localhost": {
+                    "nova-cert": {
+                        "active": true,
+                        "available": false,
+                        "updated_at": "2017-10-14T17:03:39.000000"
+                    },
+                    "nova-conductor": {
+                        "active": true,
+                        "available": false,
+                        "updated_at": "2017-10-14T17:04:09.000000"
+                    },
+                    "nova-consoleauth": {
+                        "active": true,
+                        "available": false,
+                        "updated_at": "2017-10-14T17:04:18.000000"
+                    },
+                    "nova-scheduler": {
+                        "active": true,
+                        "available": false,
+                        "updated_at": "2017-10-14T17:04:30.000000"
+                    }
+                },
+                "openstack-acc-tests.novalocal": {
+                    "nova-cert": {
+                        "active": true,
+                        "available": true,
+                        "updated_at": "2018-01-04T04:11:19.000000"
+                    },
+                    "nova-conductor": {
+                        "active": true,
+                        "available": true,
+                        "updated_at": "2018-01-04T04:11:22.000000"
+                    },
+                    "nova-consoleauth": {
+                        "active": true,
+                        "available": true,
+                        "updated_at": "2018-01-04T04:11:20.000000"
+                    },
+                    "nova-scheduler": {
+                        "active": true,
+                        "available": true,
+                        "updated_at": "2018-01-04T04:11:23.000000"
+                    }
+                }
+            },
+            "zoneName": "internal",
+            "zoneState": {
+                "available": true
+            }
+        },
+        {
+            "hosts": {
+                "openstack-acc-tests.novalocal": {
+                    "nova-compute": {
+                        "active": true,
+                        "available": true,
+                        "updated_at": "2018-01-04T04:11:23.000000"
+                    }
+                }
+            },
+            "zoneName": "nova",
+            "zoneState": {
+                "available": true
+            }
+        }
+    ]
+}`
+
+var AZResult = []az.AvailabilityZone{
+	{
+		Hosts:     nil,
+		ZoneName:  "nova",
+		ZoneState: az.ZoneState{Available: true},
+	},
+}
+
+var AZDetailResult = []az.AvailabilityZone{
+	{
+		Hosts: az.Hosts{
+			"localhost": az.Services{
+				"nova-cert": az.ServiceState{
+					Active:    true,
+					Available: false,
+					UpdatedAt: time.Date(2017, 10, 14, 17, 3, 39, 0, time.UTC),
+				},
+				"nova-conductor": az.ServiceState{
+					Active:    true,
+					Available: false,
+					UpdatedAt: time.Date(2017, 10, 14, 17, 4, 9, 0, time.UTC),
+				},
+				"nova-consoleauth": az.ServiceState{
+					Active:    true,
+					Available: false,
+					UpdatedAt: time.Date(2017, 10, 14, 17, 4, 18, 0, time.UTC),
+				},
+				"nova-scheduler": az.ServiceState{
+					Active:    true,
+					Available: false,
+					UpdatedAt: time.Date(2017, 10, 14, 17, 4, 30, 0, time.UTC),
+				},
+			},
+			"openstack-acc-tests.novalocal": az.Services{
+				"nova-cert": az.ServiceState{
+					Active:    true,
+					Available: true,
+					UpdatedAt: time.Date(2018, 1, 4, 4, 11, 19, 0, time.UTC),
+				},
+				"nova-conductor": az.ServiceState{
+					Active:    true,
+					Available: true,
+					UpdatedAt: time.Date(2018, 1, 4, 4, 11, 22, 0, time.UTC),
+				},
+				"nova-consoleauth": az.ServiceState{
+					Active:    true,
+					Available: true,
+					UpdatedAt: time.Date(2018, 1, 4, 4, 11, 20, 0, time.UTC),
+				},
+				"nova-scheduler": az.ServiceState{
+					Active:    true,
+					Available: true,
+					UpdatedAt: time.Date(2018, 1, 4, 4, 11, 23, 0, time.UTC),
+				},
+			},
+		},
+		ZoneName:  "internal",
+		ZoneState: az.ZoneState{Available: true},
+	},
+	{
+		Hosts: az.Hosts{
+			"openstack-acc-tests.novalocal": az.Services{
+				"nova-compute": az.ServiceState{
+					Active:    true,
+					Available: true,
+					UpdatedAt: time.Date(2018, 1, 4, 4, 11, 23, 0, time.UTC),
+				},
+			},
+		},
+		ZoneName:  "nova",
+		ZoneState: az.ZoneState{Available: true},
+	},
+}
+
+// HandleGetSuccessfully configures the test server to respond to a Get request
+// for availability zone information.
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-availability-zone", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
+
+// HandleGetDetailSuccessfully configures the test server to respond to a Get request
+// for detailed availability zone information.
+func HandleGetDetailSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-availability-zone/detail", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetDetailOutput)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/requests_test.go
new file mode 100644
index 000000000..8996d366d
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/testing/requests_test.go
@@ -0,0 +1,41 @@
+package testing
+
+import (
+	"testing"
+
+	az "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// Verifies that availability zones can be listed correctly
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleGetSuccessfully(t)
+
+	allPages, err := az.List(client.ServiceClient()).AllPages()
+	th.AssertNoErr(t, err)
+
+	actual, err := az.ExtractAvailabilityZones(allPages)
+	th.AssertNoErr(t, err)
+
+	th.CheckDeepEquals(t, AZResult, actual)
+}
+
+// Verifies that detailed availability zones can be listed correctly
+func TestListDetail(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleGetDetailSuccessfully(t)
+
+	allPages, err := az.ListDetail(client.ServiceClient()).AllPages()
+	th.AssertNoErr(t, err)
+
+	actual, err := az.ExtractAvailabilityZones(allPages)
+	th.AssertNoErr(t, err)
+
+	th.CheckDeepEquals(t, AZDetailResult, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/urls.go
new file mode 100644
index 000000000..9d99ec74b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/availabilityzones/urls.go
@@ -0,0 +1,11 @@
+package availabilityzones
+
+import "github.com/gophercloud/gophercloud"
+
+func listURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL("os-availability-zone")
+}
+
+func listDetailURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL("os-availability-zone", "detail")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/doc.go
new file mode 100644
index 000000000..d291325e0
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/doc.go
@@ -0,0 +1,152 @@
+/*
+Package bootfromvolume extends a server create request with the ability to
+specify block device options. This can be used to boot a server from a block
+storage volume as well as specify multiple ephemeral disks upon creation.
+
+It is recommended to refer to the Block Device Mapping documentation to see
+all possible ways to configure a server's block devices at creation time:
+
+https://docs.openstack.org/nova/latest/user/block-device-mapping.html
+
+Note that this package implements `block_device_mapping_v2`.
+
+Example of Creating a Server From an Image
+
+This example will boot a server from an image and use a standard ephemeral
+disk as the server's root disk. This is virtually no different than creating
+a server without using block device mappings.
+
+	blockDevices := []bootfromvolume.BlockDevice{
+		bootfromvolume.BlockDevice{
+			BootIndex:           0,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			SourceType:          bootfromvolume.SourceImage,
+			UUID:                "image-uuid",
+		},
+	}
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_name",
+		FlavorRef: "flavor-uuid",
+		ImageRef:  "image-uuid",
+	}
+
+	createOpts := bootfromvolume.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		BlockDevice:       blockDevices,
+	}
+
+	server, err := bootfromvolume.Create(client, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example of Creating a Server From a New Volume
+
+This example will create a block storage volume based on the given Image. The
+server will use this volume as its root disk.
+
+	blockDevices := []bootfromvolume.BlockDevice{
+		bootfromvolume.BlockDevice{
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationVolume,
+			SourceType:          bootfromvolume.SourceImage,
+			UUID:                "image-uuid",
+			VolumeSize:          2,
+		},
+	}
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_name",
+		FlavorRef: "flavor-uuid",
+	}
+
+	createOpts := bootfromvolume.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		BlockDevice:       blockDevices,
+	}
+
+	server, err := bootfromvolume.Create(client, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example of Creating a Server From an Existing Volume
+
+This example will create a server with an existing volume as its root disk.
+
+	blockDevices := []bootfromvolume.BlockDevice{
+		bootfromvolume.BlockDevice{
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationVolume,
+			SourceType:          bootfromvolume.SourceVolume,
+			UUID:                "volume-uuid",
+		},
+	}
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_name",
+		FlavorRef: "flavor-uuid",
+	}
+
+	createOpts := bootfromvolume.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		BlockDevice:       blockDevices,
+	}
+
+	server, err := bootfromvolume.Create(client, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example of Creating a Server with Multiple Ephemeral Disks
+
+This example will create a server with multiple ephemeral disks. The first
+block device will be based off of an existing Image. Each additional
+ephemeral disks must have an index of -1.
+
+	blockDevices := []bootfromvolume.BlockDevice{
+		bootfromvolume.BlockDevice{
+			BootIndex:           0,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			DeleteOnTermination: true,
+			SourceType:          bootfromvolume.SourceImage,
+			UUID:                "image-uuid",
+			VolumeSize:          5,
+		},
+		bootfromvolume.BlockDevice{
+			BootIndex:           -1,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			DeleteOnTermination: true,
+			GuestFormat:         "ext4",
+			SourceType:          bootfromvolume.SourceBlank,
+			VolumeSize:          1,
+		},
+		bootfromvolume.BlockDevice{
+			BootIndex:           -1,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			DeleteOnTermination: true,
+			GuestFormat:         "ext4",
+			SourceType:          bootfromvolume.SourceBlank,
+			VolumeSize:          1,
+		},
+	}
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_name",
+		FlavorRef: "flavor-uuid",
+		ImageRef:  "image-uuid",
+	}
+
+	createOpts := bootfromvolume.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		BlockDevice:       blockDevices,
+	}
+
+	server, err := bootfromvolume.Create(client, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+*/
+package bootfromvolume
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/requests.go
new file mode 100644
index 000000000..d2346d4b4
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/requests.go
@@ -0,0 +1,132 @@
+package bootfromvolume
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+)
+
+type (
+	// DestinationType represents the type of medium being used as the
+	// destination of the bootable device.
+	DestinationType string
+
+	// SourceType represents the type of medium being used as the source of the
+	// bootable device.
+	SourceType string
+)
+
+const (
+	// DestinationLocal DestinationType is for using an ephemeral disk as the
+	// destination.
+	DestinationLocal DestinationType = "local"
+
+	// DestinationVolume DestinationType is for using a volume as the destination.
+	DestinationVolume DestinationType = "volume"
+
+	// SourceBlank SourceType is for a "blank" or empty source.
+	SourceBlank SourceType = "blank"
+
+	// SourceImage SourceType is for using images as the source of a block device.
+	SourceImage SourceType = "image"
+
+	// SourceSnapshot SourceType is for using a volume snapshot as the source of
+	// a block device.
+	SourceSnapshot SourceType = "snapshot"
+
+	// SourceVolume SourceType is for using a volume as the source of block
+	// device.
+	SourceVolume SourceType = "volume"
+)
+
+// BlockDevice is a structure with options for creating block devices in a
+// server. The block device may be created from an image, snapshot, new volume,
+// or existing volume. The destination may be a new volume, existing volume
+// which will be attached to the instance, ephemeral disk, or boot device.
+type BlockDevice struct {
+	// SourceType must be one of: "volume", "snapshot", "image", or "blank".
+	SourceType SourceType `json:"source_type" required:"true"`
+
+	// UUID is the unique identifier for the existing volume, snapshot, or
+	// image (see above).
+	UUID string `json:"uuid,omitempty"`
+
+	// BootIndex is the boot index. It defaults to 0.
+	BootIndex int `json:"boot_index"`
+
+	// DeleteOnTermination specifies whether or not to delete the attached volume
+	// when the server is deleted. Defaults to `false`.
+	DeleteOnTermination bool `json:"delete_on_termination"`
+
+	// DestinationType is the type that gets created. Possible values are "volume"
+	// and "local".
+	DestinationType DestinationType `json:"destination_type,omitempty"`
+
+	// GuestFormat specifies the format of the block device.
+	GuestFormat string `json:"guest_format,omitempty"`
+
+	// VolumeSize is the size of the volume to create (in gigabytes). This can be
+	// omitted for existing volumes.
+	VolumeSize int `json:"volume_size,omitempty"`
+
+	// DeviceType specifies the device type of the block devices.
+	// Examples of this are disk, cdrom, floppy, lun, etc.
+	DeviceType string `json:"device_type,omitempty"`
+
+	// DiskBus is the bus type of the block devices.
+	// Examples of this are ide, usb, virtio, scsi, etc.
+	DiskBus string `json:"disk_bus,omitempty"`
+
+	// VolumeType is the volume type of the block device.
+	// This requires Compute API microversion 2.67 or later.
+	VolumeType string `json:"volume_type,omitempty"`
+}
+
+// CreateOptsExt is a structure that extends the server `CreateOpts` structure
+// by allowing for a block device mapping.
+type CreateOptsExt struct {
+	servers.CreateOptsBuilder
+	BlockDevice []BlockDevice `json:"block_device_mapping_v2,omitempty"`
+}
+
+// ToServerCreateMap adds the block device mapping option to the base server
+// creation options.
+func (opts CreateOptsExt) ToServerCreateMap() (map[string]interface{}, error) {
+	base, err := opts.CreateOptsBuilder.ToServerCreateMap()
+	if err != nil {
+		return nil, err
+	}
+
+	if len(opts.BlockDevice) == 0 {
+		err := gophercloud.ErrMissingInput{}
+		err.Argument = "bootfromvolume.CreateOptsExt.BlockDevice"
+		return nil, err
+	}
+
+	serverMap := base["server"].(map[string]interface{})
+
+	blockDevice := make([]map[string]interface{}, len(opts.BlockDevice))
+
+	for i, bd := range opts.BlockDevice {
+		b, err := gophercloud.BuildRequestBody(bd, "")
+		if err != nil {
+			return nil, err
+		}
+		blockDevice[i] = b
+	}
+	serverMap["block_device_mapping_v2"] = blockDevice
+
+	return base, nil
+}
+
+// Create requests the creation of a server from the given block device mapping.
+func Create(client *gophercloud.ServiceClient, opts servers.CreateOptsBuilder) (r servers.CreateResult) {
+	b, err := opts.ToServerCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(createURL(client), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200, 202},
+	})
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/results.go
new file mode 100644
index 000000000..ba1eafabc
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/results.go
@@ -0,0 +1,12 @@
+package bootfromvolume
+
+import (
+	os "github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+)
+
+// CreateResult temporarily contains the response from a Create call.
+// It embeds the standard servers.CreateResults type and so can be used the
+// same way as a standard server request result.
+type CreateResult struct {
+	os.CreateResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/doc.go
new file mode 100644
index 000000000..cf5048acb
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/doc.go
@@ -0,0 +1,2 @@
+// bootfromvolume unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/fixtures.go
new file mode 100644
index 000000000..cb89173aa
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/fixtures.go
@@ -0,0 +1,310 @@
+package testing
+
+import (
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+)
+
+var BaseCreateOpts = servers.CreateOpts{
+	Name:      "createdserver",
+	FlavorRef: "performance1-1",
+}
+
+var BaseCreateOptsWithImageRef = servers.CreateOpts{
+	Name:      "createdserver",
+	FlavorRef: "performance1-1",
+	ImageRef:  "asdfasdfasdf",
+}
+
+const ExpectedNewVolumeRequest = `
+{
+	"server": {
+		"name":"createdserver",
+		"flavorRef":"performance1-1",
+		"imageRef":"",
+		"block_device_mapping_v2":[
+			{
+				"uuid":"123456",
+				"source_type":"image",
+				"destination_type":"volume",
+				"boot_index": 0,
+				"delete_on_termination": true,
+				"volume_size": 10
+			}
+		]
+	}
+}
+`
+
+var NewVolumeRequest = bootfromvolume.CreateOptsExt{
+	CreateOptsBuilder: BaseCreateOpts,
+	BlockDevice: []bootfromvolume.BlockDevice{
+		{
+			UUID:                "123456",
+			SourceType:          bootfromvolume.SourceImage,
+			DestinationType:     bootfromvolume.DestinationVolume,
+			VolumeSize:          10,
+			DeleteOnTermination: true,
+		},
+	},
+}
+
+const ExpectedExistingVolumeRequest = `
+{
+	"server": {
+		"name":"createdserver",
+		"flavorRef":"performance1-1",
+		"imageRef":"",
+		"block_device_mapping_v2":[
+			{
+				"uuid":"123456",
+				"source_type":"volume",
+				"destination_type":"volume",
+				"boot_index": 0,
+				"delete_on_termination": true
+			}
+		]
+	}
+}
+`
+
+var ExistingVolumeRequest = bootfromvolume.CreateOptsExt{
+	CreateOptsBuilder: BaseCreateOpts,
+	BlockDevice: []bootfromvolume.BlockDevice{
+		{
+			UUID:                "123456",
+			SourceType:          bootfromvolume.SourceVolume,
+			DestinationType:     bootfromvolume.DestinationVolume,
+			DeleteOnTermination: true,
+		},
+	},
+}
+
+const ExpectedImageRequest = `
+{
+	"server": {
+		"name": "createdserver",
+		"imageRef": "asdfasdfasdf",
+		"flavorRef": "performance1-1",
+		"block_device_mapping_v2":[
+			{
+				"boot_index": 0,
+				"delete_on_termination": true,
+				"destination_type":"local",
+				"source_type":"image",
+				"uuid":"asdfasdfasdf"
+			}
+		]
+	}
+}
+`
+
+var ImageRequest = bootfromvolume.CreateOptsExt{
+	CreateOptsBuilder: BaseCreateOptsWithImageRef,
+	BlockDevice: []bootfromvolume.BlockDevice{
+		{
+			BootIndex:           0,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			SourceType:          bootfromvolume.SourceImage,
+			UUID:                "asdfasdfasdf",
+		},
+	},
+}
+
+const ExpectedMultiEphemeralRequest = `
+{
+	"server": {
+		"name": "createdserver",
+		"imageRef": "asdfasdfasdf",
+		"flavorRef": "performance1-1",
+		"block_device_mapping_v2":[
+			{
+				"boot_index": 0,
+				"delete_on_termination": true,
+				"destination_type":"local",
+				"source_type":"image",
+				"uuid":"asdfasdfasdf"
+			},
+			{
+				"boot_index": -1,
+				"delete_on_termination": true,
+				"destination_type":"local",
+				"guest_format":"ext4",
+				"source_type":"blank",
+				"volume_size": 1
+			},
+			{
+				"boot_index": -1,
+				"delete_on_termination": true,
+				"destination_type":"local",
+				"guest_format":"ext4",
+				"source_type":"blank",
+				"volume_size": 1
+			}
+		]
+	}
+}
+`
+
+var MultiEphemeralRequest = bootfromvolume.CreateOptsExt{
+	CreateOptsBuilder: BaseCreateOptsWithImageRef,
+	BlockDevice: []bootfromvolume.BlockDevice{
+		{
+			BootIndex:           0,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			SourceType:          bootfromvolume.SourceImage,
+			UUID:                "asdfasdfasdf",
+		},
+		{
+			BootIndex:           -1,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			GuestFormat:         "ext4",
+			SourceType:          bootfromvolume.SourceBlank,
+			VolumeSize:          1,
+		},
+		{
+			BootIndex:           -1,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			GuestFormat:         "ext4",
+			SourceType:          bootfromvolume.SourceBlank,
+			VolumeSize:          1,
+		},
+	},
+}
+
+const ExpectedImageAndNewVolumeRequest = `
+{
+	"server": {
+		"name": "createdserver",
+		"imageRef": "asdfasdfasdf",
+		"flavorRef": "performance1-1",
+		"block_device_mapping_v2":[
+			{
+				"boot_index": 0,
+				"delete_on_termination": true,
+				"destination_type":"local",
+				"source_type":"image",
+				"uuid":"asdfasdfasdf"
+			},
+			{
+				"boot_index": 1,
+				"delete_on_termination": true,
+				"destination_type":"volume",
+				"source_type":"blank",
+				"volume_size": 1,
+				"device_type": "disk",
+				"disk_bus": "scsi"
+			}
+		]
+	}
+}
+`
+
+var ImageAndNewVolumeRequest = bootfromvolume.CreateOptsExt{
+	CreateOptsBuilder: BaseCreateOptsWithImageRef,
+	BlockDevice: []bootfromvolume.BlockDevice{
+		{
+			BootIndex:           0,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			SourceType:          bootfromvolume.SourceImage,
+			UUID:                "asdfasdfasdf",
+		},
+		{
+			BootIndex:           1,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationVolume,
+			SourceType:          bootfromvolume.SourceBlank,
+			VolumeSize:          1,
+			DeviceType:          "disk",
+			DiskBus:             "scsi",
+		},
+	},
+}
+
+const ExpectedImageAndExistingVolumeRequest = `
+{
+	"server": {
+		"name": "createdserver",
+		"imageRef": "asdfasdfasdf",
+		"flavorRef": "performance1-1",
+		"block_device_mapping_v2":[
+			{
+				"boot_index": 0,
+				"delete_on_termination": true,
+				"destination_type":"local",
+				"source_type":"image",
+				"uuid":"asdfasdfasdf"
+			},
+			{
+				"boot_index": 1,
+				"delete_on_termination": true,
+				"destination_type":"volume",
+				"source_type":"volume",
+				"uuid":"123456",
+				"volume_size": 1
+			}
+		]
+	}
+}
+`
+
+var ImageAndExistingVolumeRequest = bootfromvolume.CreateOptsExt{
+	CreateOptsBuilder: BaseCreateOptsWithImageRef,
+	BlockDevice: []bootfromvolume.BlockDevice{
+		{
+			BootIndex:           0,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationLocal,
+			SourceType:          bootfromvolume.SourceImage,
+			UUID:                "asdfasdfasdf",
+		},
+		{
+			BootIndex:           1,
+			DeleteOnTermination: true,
+			DestinationType:     bootfromvolume.DestinationVolume,
+			SourceType:          bootfromvolume.SourceVolume,
+			UUID:                "123456",
+			VolumeSize:          1,
+		},
+	},
+}
+
+const ExpectedNewVolumeTypeRequest = `
+{
+	"server": {
+		"name":"createdserver",
+		"flavorRef":"performance1-1",
+		"imageRef":"",
+		"block_device_mapping_v2":[
+			{
+				"uuid":"123456",
+				"source_type":"image",
+				"destination_type":"volume",
+				"boot_index": 0,
+				"delete_on_termination": true,
+				"volume_size": 10,
+				"volume_type": "ssd"
+			}
+		]
+	}
+}
+`
+
+var NewVolumeTypeRequest = bootfromvolume.CreateOptsExt{
+	CreateOptsBuilder: BaseCreateOpts,
+	BlockDevice: []bootfromvolume.BlockDevice{
+		{
+			UUID:                "123456",
+			SourceType:          bootfromvolume.SourceImage,
+			DestinationType:     bootfromvolume.DestinationVolume,
+			VolumeSize:          10,
+			DeleteOnTermination: true,
+			VolumeType:          "ssd",
+		},
+	},
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/requests_test.go
new file mode 100644
index 000000000..69afc865c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/testing/requests_test.go
@@ -0,0 +1,49 @@
+package testing
+
+import (
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+)
+
+func TestBootFromNewVolume(t *testing.T) {
+	actual, err := NewVolumeRequest.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, ExpectedNewVolumeRequest, actual)
+}
+
+func TestBootFromExistingVolume(t *testing.T) {
+	actual, err := ExistingVolumeRequest.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, ExpectedExistingVolumeRequest, actual)
+}
+
+func TestBootFromImage(t *testing.T) {
+	actual, err := ImageRequest.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, ExpectedImageRequest, actual)
+}
+
+func TestCreateMultiEphemeralOpts(t *testing.T) {
+	actual, err := MultiEphemeralRequest.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, ExpectedMultiEphemeralRequest, actual)
+}
+
+func TestAttachNewVolume(t *testing.T) {
+	actual, err := ImageAndNewVolumeRequest.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, ExpectedImageAndNewVolumeRequest, actual)
+}
+
+func TestAttachExistingVolume(t *testing.T) {
+	actual, err := ImageAndExistingVolumeRequest.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, ExpectedImageAndExistingVolumeRequest, actual)
+}
+
+func TestBootFromNewVolumeType(t *testing.T) {
+	actual, err := NewVolumeTypeRequest.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, ExpectedNewVolumeTypeRequest, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/urls.go
new file mode 100644
index 000000000..dc007eadf
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/bootfromvolume/urls.go
@@ -0,0 +1,7 @@
+package bootfromvolume
+
+import "github.com/gophercloud/gophercloud"
+
+func createURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL("os-volumes_boot")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/doc.go
new file mode 100644
index 000000000..255213555
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/doc.go
@@ -0,0 +1,55 @@
+/*
+Package defsecrules enables management of default security group rules.
+
+Default security group rules are rules that are managed in the "default"
+security group.
+
+This is only applicable in environments running nova-network. This package will
+not work if the OpenStack environment is running the OpenStack Networking
+(Neutron) service.
+
+Example of Listing Default Security Group Rules
+
+	allPages, err := defsecrules.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allDefaultRules, err := defsecrules.ExtractDefaultRules(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, df := range allDefaultRules {
+		fmt.Printf("%+v\n", df)
+	}
+
+Example of Retrieving a Default Security Group Rule
+
+	rule, err := defsecrules.Get(computeClient, "rule-id").Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example of Creating a Default Security Group Rule
+
+	createOpts := defsecrules.CreateOpts{
+		IPProtocol: "TCP",
+		FromPort:   80,
+		ToPort:     80,
+		CIDR:       "10.10.12.0/24",
+	}
+
+	rule, err := defsecrules.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example of Deleting a Default Security Group Rule
+
+	err := defsecrules.Delete(computeClient, "rule-id").ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package defsecrules
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/requests.go
new file mode 100644
index 000000000..b63a5d5d6
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/requests.go
@@ -0,0 +1,75 @@
+package defsecrules
+
+import (
+	"strings"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List will return a collection of default rules.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, rootURL(client), func(r pagination.PageResult) pagination.Page {
+		return DefaultRulePage{pagination.SinglePageBase(r)}
+	})
+}
+
+// CreateOpts represents the configuration for adding a new default rule.
+type CreateOpts struct {
+	// The lower bound of the port range that will be opened.
+	FromPort int `json:"from_port"`
+
+	// The upper bound of the port range that will be opened.
+	ToPort int `json:"to_port"`
+
+	// The protocol type that will be allowed, e.g. TCP.
+	IPProtocol string `json:"ip_protocol" required:"true"`
+
+	// ONLY required if FromGroupID is blank. This represents the IP range that
+	// will be the source of network traffic to your security group.
+	//
+	// Use 0.0.0.0/0 to allow all IPv4 addresses.
+	// Use ::/0 to allow all IPv6 addresses.
+	CIDR string `json:"cidr,omitempty"`
+}
+
+// CreateOptsBuilder builds the create rule options into a serializable format.
+type CreateOptsBuilder interface {
+	ToRuleCreateMap() (map[string]interface{}, error)
+}
+
+// ToRuleCreateMap builds the create rule options into a serializable format.
+func (opts CreateOpts) ToRuleCreateMap() (map[string]interface{}, error) {
+	if opts.FromPort == 0 && strings.ToUpper(opts.IPProtocol) != "ICMP" {
+		return nil, gophercloud.ErrMissingInput{Argument: "FromPort"}
+	}
+	if opts.ToPort == 0 && strings.ToUpper(opts.IPProtocol) != "ICMP" {
+		return nil, gophercloud.ErrMissingInput{Argument: "ToPort"}
+	}
+	return gophercloud.BuildRequestBody(opts, "security_group_default_rule")
+}
+
+// Create is the operation responsible for creating a new default rule.
+func Create(client *gophercloud.ServiceClient, opts CreateOptsBuilder) (r CreateResult) {
+	b, err := opts.ToRuleCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(rootURL(client), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Get will return details for a particular default rule.
+func Get(client *gophercloud.ServiceClient, id string) (r GetResult) {
+	_, r.Err = client.Get(resourceURL(client, id), &r.Body, nil)
+	return
+}
+
+// Delete will permanently delete a rule the project's default security group.
+func Delete(client *gophercloud.ServiceClient, id string) (r DeleteResult) {
+	_, r.Err = client.Delete(resourceURL(client, id), nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/results.go
new file mode 100644
index 000000000..98c18fe56
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/results.go
@@ -0,0 +1,73 @@
+package defsecrules
+
+import (
+	"encoding/json"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// DefaultRule represents a rule belonging to the "default" security group.
+// It is identical to an openstack/compute/v2/extensions/secgroups.Rule.
+type DefaultRule secgroups.Rule
+
+func (r *DefaultRule) UnmarshalJSON(b []byte) error {
+	var s secgroups.Rule
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+	*r = DefaultRule(s)
+	return nil
+}
+
+// DefaultRulePage is a single page of a DefaultRule collection.
+type DefaultRulePage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a page of default rules contains any results.
+func (page DefaultRulePage) IsEmpty() (bool, error) {
+	users, err := ExtractDefaultRules(page)
+	return len(users) == 0, err
+}
+
+// ExtractDefaultRules returns a slice of DefaultRules contained in a single
+// page of results.
+func ExtractDefaultRules(r pagination.Page) ([]DefaultRule, error) {
+	var s struct {
+		DefaultRules []DefaultRule `json:"security_group_default_rules"`
+	}
+	err := (r.(DefaultRulePage)).ExtractInto(&s)
+	return s.DefaultRules, err
+}
+
+type commonResult struct {
+	gophercloud.Result
+}
+
+// CreateResult represents the result of a create operation.
+type CreateResult struct {
+	commonResult
+}
+
+// GetResult represents the result of a get operation.
+type GetResult struct {
+	commonResult
+}
+
+// Extract will extract a DefaultRule struct from a Create or Get response.
+func (r commonResult) Extract() (*DefaultRule, error) {
+	var s struct {
+		DefaultRule DefaultRule `json:"security_group_default_rule"`
+	}
+	err := r.ExtractInto(&s)
+	return &s.DefaultRule, err
+}
+
+// DeleteResult is the response from a delete operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/doc.go
new file mode 100644
index 000000000..6eeb60f05
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/doc.go
@@ -0,0 +1,2 @@
+// defsecrules unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/fixtures.go
new file mode 100644
index 000000000..e4a62d4ec
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/fixtures.go
@@ -0,0 +1,143 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	fake "github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const rootPath = "/os-security-group-default-rules"
+
+func mockListRulesResponse(t *testing.T) {
+	th.Mux.HandleFunc(rootPath, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group_default_rules": [
+    {
+      "from_port": 80,
+      "id": "{ruleID}",
+      "ip_protocol": "TCP",
+      "ip_range": {
+        "cidr": "10.10.10.0/24"
+      },
+      "to_port": 80
+    }
+  ]
+}
+      `)
+	})
+}
+
+func mockCreateRuleResponse(t *testing.T) {
+	th.Mux.HandleFunc(rootPath, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		th.TestJSONRequest(t, r, `
+{
+  "security_group_default_rule": {
+    "ip_protocol": "TCP",
+    "from_port": 80,
+    "to_port": 80,
+    "cidr": "10.10.12.0/24"
+  }
+}
+	`)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group_default_rule": {
+    "from_port": 80,
+    "id": "{ruleID}",
+    "ip_protocol": "TCP",
+    "ip_range": {
+      "cidr": "10.10.12.0/24"
+    },
+    "to_port": 80
+  }
+}
+`)
+	})
+}
+
+func mockCreateRuleResponseICMPZero(t *testing.T) {
+	th.Mux.HandleFunc(rootPath, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		th.TestJSONRequest(t, r, `
+{
+  "security_group_default_rule": {
+    "ip_protocol": "ICMP",
+    "from_port": 0,
+    "to_port": 0,
+    "cidr": "10.10.12.0/24"
+  }
+}
+	`)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group_default_rule": {
+    "from_port": 0,
+    "id": "{ruleID}",
+    "ip_protocol": "ICMP",
+    "ip_range": {
+      "cidr": "10.10.12.0/24"
+    },
+    "to_port": 0
+  }
+}
+`)
+	})
+}
+
+func mockGetRuleResponse(t *testing.T, ruleID string) {
+	url := rootPath + "/" + ruleID
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group_default_rule": {
+    "id": "{ruleID}",
+    "from_port": 80,
+    "to_port": 80,
+    "ip_protocol": "TCP",
+    "ip_range": {
+      "cidr": "10.10.12.0/24"
+    }
+  }
+}
+			`)
+	})
+}
+
+func mockDeleteRuleResponse(t *testing.T, ruleID string) {
+	url := rootPath + "/" + ruleID
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusNoContent)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/requests_test.go
new file mode 100644
index 000000000..1f2fb8686
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/testing/requests_test.go
@@ -0,0 +1,127 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const ruleID = "{ruleID}"
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockListRulesResponse(t)
+
+	count := 0
+
+	err := defsecrules.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := defsecrules.ExtractDefaultRules(page)
+		th.AssertNoErr(t, err)
+
+		expected := []defsecrules.DefaultRule{
+			{
+				FromPort:   80,
+				ID:         ruleID,
+				IPProtocol: "TCP",
+				IPRange:    secgroups.IPRange{CIDR: "10.10.10.0/24"},
+				ToPort:     80,
+			},
+		}
+
+		th.CheckDeepEquals(t, expected, actual)
+
+		return true, nil
+	})
+
+	th.AssertNoErr(t, err)
+	th.AssertEquals(t, 1, count)
+}
+
+func TestCreate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockCreateRuleResponse(t)
+
+	opts := defsecrules.CreateOpts{
+		IPProtocol: "TCP",
+		FromPort:   80,
+		ToPort:     80,
+		CIDR:       "10.10.12.0/24",
+	}
+
+	group, err := defsecrules.Create(client.ServiceClient(), opts).Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &defsecrules.DefaultRule{
+		ID:         ruleID,
+		FromPort:   80,
+		ToPort:     80,
+		IPProtocol: "TCP",
+		IPRange:    secgroups.IPRange{CIDR: "10.10.12.0/24"},
+	}
+	th.AssertDeepEquals(t, expected, group)
+}
+
+func TestCreateICMPZero(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockCreateRuleResponseICMPZero(t)
+
+	opts := defsecrules.CreateOpts{
+		IPProtocol: "ICMP",
+		FromPort:   0,
+		ToPort:     0,
+		CIDR:       "10.10.12.0/24",
+	}
+
+	group, err := defsecrules.Create(client.ServiceClient(), opts).Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &defsecrules.DefaultRule{
+		ID:         ruleID,
+		FromPort:   0,
+		ToPort:     0,
+		IPProtocol: "ICMP",
+		IPRange:    secgroups.IPRange{CIDR: "10.10.12.0/24"},
+	}
+	th.AssertDeepEquals(t, expected, group)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockGetRuleResponse(t, ruleID)
+
+	group, err := defsecrules.Get(client.ServiceClient(), ruleID).Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &defsecrules.DefaultRule{
+		ID:         ruleID,
+		FromPort:   80,
+		ToPort:     80,
+		IPProtocol: "TCP",
+		IPRange:    secgroups.IPRange{CIDR: "10.10.12.0/24"},
+	}
+
+	th.AssertDeepEquals(t, expected, group)
+}
+
+func TestDelete(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockDeleteRuleResponse(t, ruleID)
+
+	err := defsecrules.Delete(client.ServiceClient(), ruleID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/urls.go
new file mode 100644
index 000000000..e5fbf8245
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/defsecrules/urls.go
@@ -0,0 +1,13 @@
+package defsecrules
+
+import "github.com/gophercloud/gophercloud"
+
+const rulepath = "os-security-group-default-rules"
+
+func resourceURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL(rulepath, id)
+}
+
+func rootURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(rulepath)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/delegate.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/delegate.go
new file mode 100644
index 000000000..00e7c3bec
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/delegate.go
@@ -0,0 +1,23 @@
+package extensions
+
+import (
+	"github.com/gophercloud/gophercloud"
+	common "github.com/gophercloud/gophercloud/openstack/common/extensions"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// ExtractExtensions interprets a Page as a slice of Extensions.
+func ExtractExtensions(page pagination.Page) ([]common.Extension, error) {
+	return common.ExtractExtensions(page)
+}
+
+// Get retrieves information for a specific extension using its alias.
+func Get(c *gophercloud.ServiceClient, alias string) common.GetResult {
+	return common.Get(c, alias)
+}
+
+// List returns a Pager which allows you to iterate over the full collection of extensions.
+// It does not accept query parameters.
+func List(c *gophercloud.ServiceClient) pagination.Pager {
+	return common.List(c)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/doc.go
new file mode 100644
index 000000000..8141120c3
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/doc.go
@@ -0,0 +1,14 @@
+/*
+Package diagnostics returns details about a nova instance diagnostics
+
+Example of Show Diagnostics
+
+	diags, err := diagnostics.Get(computeClient, serverId).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v\n", diags)
+
+*/
+package diagnostics
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/requests.go
new file mode 100644
index 000000000..b0b441222
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/requests.go
@@ -0,0 +1,11 @@
+package diagnostics
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// Diagnostics
+func Get(client *gophercloud.ServiceClient, serverId string) (r serverDiagnosticsResult) {
+	_, r.Err = client.Get(serverDiagnosticsURL(client, serverId), &r.Body, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/results.go
new file mode 100644
index 000000000..00ee3f316
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/results.go
@@ -0,0 +1,16 @@
+package diagnostics
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+type serverDiagnosticsResult struct {
+	gophercloud.Result
+}
+
+// Extract interprets any diagnostic response as a map
+func (r serverDiagnosticsResult) Extract() (map[string]interface{}, error) {
+	var s map[string]interface{}
+	err := r.ExtractInto(&s)
+	return s, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/testing/fixtures.go
new file mode 100644
index 000000000..e36b8a403
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/testing/fixtures.go
@@ -0,0 +1,21 @@
+package testing
+
+import (
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// HandleDiagnosticGetSuccessfully sets up the test server to respond to a diagnostic Get request.
+func HandleDiagnosticGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/1234asdf/diagnostics", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestHeader(t, r, "Accept", "application/json")
+
+		w.WriteHeader(http.StatusOK)
+		w.Write([]byte(`{"cpu0_time":173,"memory":524288}`))
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/testing/requests_test.go
new file mode 100644
index 000000000..9d8f3a3dc
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/testing/requests_test.go
@@ -0,0 +1,23 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestGetDiagnostics(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleDiagnosticGetSuccessfully(t)
+
+	expected := map[string]interface{}{"cpu0_time": float64(173), "memory": float64(524288)}
+
+	res, err := diagnostics.Get(client.ServiceClient(), "1234asdf").Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertDeepEquals(t, expected, res)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/urls.go
new file mode 100644
index 000000000..72ae68de4
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diagnostics/urls.go
@@ -0,0 +1,8 @@
+package diagnostics
+
+import "github.com/gophercloud/gophercloud"
+
+// serverDiagnosticsURL returns the diagnostics url for a nova instance/server
+func serverDiagnosticsURL(client *gophercloud.ServiceClient, id string) string {
+	return client.ServiceURL("servers", id, "diagnostics")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/doc.go
new file mode 100644
index 000000000..ed9cc6f73
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/doc.go
@@ -0,0 +1,46 @@
+/*
+Package diskconfig provides information and interaction with the Disk Config
+extension that works with the OpenStack Compute service.
+
+Example of Obtaining the Disk Config of a Server
+
+	type ServerWithDiskConfig {
+		servers.Server
+		diskconfig.ServerDiskConfigExt
+	}
+
+	var allServers []ServerWithDiskConfig
+
+	allPages, err := servers.List(client, nil).AllPages()
+	if err != nil {
+		panic("Unable to retrieve servers: %s", err)
+	}
+
+	err = servers.ExtractServersInto(allPages, &allServers)
+	if err != nil {
+		panic("Unable to extract servers: %s", err)
+	}
+
+	for _, server := range allServers {
+		fmt.Println(server.DiskConfig)
+	}
+
+Example of Creating a Server with Disk Config
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_name",
+		ImageRef:  "image-uuid",
+		FlavorRef: "flavor-uuid",
+	}
+
+	createOpts := diskconfig.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		DiskConfig:        diskconfig.Manual,
+	}
+
+	server, err := servers.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic("Unable to create server: %s", err)
+	}
+*/
+package diskconfig
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/requests.go
new file mode 100644
index 000000000..cc04aed6f
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/requests.go
@@ -0,0 +1,106 @@
+package diskconfig
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+)
+
+// DiskConfig represents one of the two possible settings for the DiskConfig
+// option when creating, rebuilding, or resizing servers: Auto or Manual.
+type DiskConfig string
+
+const (
+	// Auto builds a server with a single partition the size of the target flavor
+	// disk and automatically adjusts the filesystem to fit the entire partition.
+	// Auto may only be used with images and servers that use a single EXT3
+	// partition.
+	Auto DiskConfig = "AUTO"
+
+	// Manual builds a server using whatever partition scheme and filesystem are
+	// present in the source image. If the target flavor disk is larger, the
+	// remaining space is left unpartitioned. This enables images to have non-EXT3
+	// filesystems, multiple partitions, and so on, and enables you to manage the
+	// disk configuration. It also results in slightly shorter boot times.
+	Manual DiskConfig = "MANUAL"
+)
+
+// CreateOptsExt adds a DiskConfig option to the base CreateOpts.
+type CreateOptsExt struct {
+	servers.CreateOptsBuilder
+
+	// DiskConfig [optional] controls how the created server's disk is partitioned.
+	DiskConfig DiskConfig `json:"OS-DCF:diskConfig,omitempty"`
+}
+
+// ToServerCreateMap adds the diskconfig option to the base server creation options.
+func (opts CreateOptsExt) ToServerCreateMap() (map[string]interface{}, error) {
+	base, err := opts.CreateOptsBuilder.ToServerCreateMap()
+	if err != nil {
+		return nil, err
+	}
+
+	if string(opts.DiskConfig) == "" {
+		return base, nil
+	}
+
+	serverMap := base["server"].(map[string]interface{})
+	serverMap["OS-DCF:diskConfig"] = string(opts.DiskConfig)
+
+	return base, nil
+}
+
+// RebuildOptsExt adds a DiskConfig option to the base RebuildOpts.
+type RebuildOptsExt struct {
+	servers.RebuildOptsBuilder
+
+	// DiskConfig controls how the rebuilt server's disk is partitioned.
+	DiskConfig DiskConfig `json:"OS-DCF:diskConfig,omitempty"`
+}
+
+// ToServerRebuildMap adds the diskconfig option to the base server rebuild options.
+func (opts RebuildOptsExt) ToServerRebuildMap() (map[string]interface{}, error) {
+	if opts.DiskConfig != Auto && opts.DiskConfig != Manual {
+		err := gophercloud.ErrInvalidInput{}
+		err.Argument = "diskconfig.RebuildOptsExt.DiskConfig"
+		err.Info = "Must be either diskconfig.Auto or diskconfig.Manual"
+		return nil, err
+	}
+
+	base, err := opts.RebuildOptsBuilder.ToServerRebuildMap()
+	if err != nil {
+		return nil, err
+	}
+
+	serverMap := base["rebuild"].(map[string]interface{})
+	serverMap["OS-DCF:diskConfig"] = string(opts.DiskConfig)
+
+	return base, nil
+}
+
+// ResizeOptsExt adds a DiskConfig option to the base server resize options.
+type ResizeOptsExt struct {
+	servers.ResizeOptsBuilder
+
+	// DiskConfig [optional] controls how the resized server's disk is partitioned.
+	DiskConfig DiskConfig
+}
+
+// ToServerResizeMap adds the diskconfig option to the base server creation options.
+func (opts ResizeOptsExt) ToServerResizeMap() (map[string]interface{}, error) {
+	if opts.DiskConfig != Auto && opts.DiskConfig != Manual {
+		err := gophercloud.ErrInvalidInput{}
+		err.Argument = "diskconfig.ResizeOptsExt.DiskConfig"
+		err.Info = "Must be either diskconfig.Auto or diskconfig.Manual"
+		return nil, err
+	}
+
+	base, err := opts.ResizeOptsBuilder.ToServerResizeMap()
+	if err != nil {
+		return nil, err
+	}
+
+	serverMap := base["resize"].(map[string]interface{})
+	serverMap["OS-DCF:diskConfig"] = string(opts.DiskConfig)
+
+	return base, nil
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/results.go
new file mode 100644
index 000000000..239b2683d
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/results.go
@@ -0,0 +1,6 @@
+package diskconfig
+
+type ServerDiskConfigExt struct {
+	// DiskConfig is the disk configuration of the server.
+	DiskConfig DiskConfig `json:"OS-DCF:diskConfig"`
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/testing/doc.go
new file mode 100644
index 000000000..52ab24756
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/testing/doc.go
@@ -0,0 +1,2 @@
+// diskconfig unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/testing/requests_test.go
new file mode 100644
index 000000000..5b6493182
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig/testing/requests_test.go
@@ -0,0 +1,88 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/diskconfig"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+	th "github.com/gophercloud/gophercloud/testhelper"
+)
+
+func TestCreateOpts(t *testing.T) {
+	base := servers.CreateOpts{
+		Name:      "createdserver",
+		ImageRef:  "asdfasdfasdf",
+		FlavorRef: "performance1-1",
+	}
+
+	ext := diskconfig.CreateOptsExt{
+		CreateOptsBuilder: base,
+		DiskConfig:        diskconfig.Manual,
+	}
+
+	expected := `
+		{
+			"server": {
+				"name": "createdserver",
+				"imageRef": "asdfasdfasdf",
+				"flavorRef": "performance1-1",
+				"OS-DCF:diskConfig": "MANUAL"
+			}
+		}
+	`
+	actual, err := ext.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, expected, actual)
+}
+
+func TestRebuildOpts(t *testing.T) {
+	base := servers.RebuildOpts{
+		Name:      "rebuiltserver",
+		AdminPass: "swordfish",
+		ImageRef:  "asdfasdfasdf",
+	}
+
+	ext := diskconfig.RebuildOptsExt{
+		RebuildOptsBuilder: base,
+		DiskConfig:         diskconfig.Auto,
+	}
+
+	actual, err := ext.ToServerRebuildMap()
+	th.AssertNoErr(t, err)
+
+	expected := `
+		{
+			"rebuild": {
+				"name": "rebuiltserver",
+				"imageRef": "asdfasdfasdf",
+				"adminPass": "swordfish",
+				"OS-DCF:diskConfig": "AUTO"
+			}
+		}
+	`
+	th.CheckJSONEquals(t, expected, actual)
+}
+
+func TestResizeOpts(t *testing.T) {
+	base := servers.ResizeOpts{
+		FlavorRef: "performance1-8",
+	}
+
+	ext := diskconfig.ResizeOptsExt{
+		ResizeOptsBuilder: base,
+		DiskConfig:        diskconfig.Auto,
+	}
+
+	actual, err := ext.ToServerResizeMap()
+	th.AssertNoErr(t, err)
+
+	expected := `
+		{
+			"resize": {
+				"flavorRef": "performance1-8",
+				"OS-DCF:diskConfig": "AUTO"
+			}
+		}
+	`
+	th.CheckJSONEquals(t, expected, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/doc.go
new file mode 100644
index 000000000..2b447da1d
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/doc.go
@@ -0,0 +1,3 @@
+// Package extensions provides information and interaction with the
+// different extensions available for the OpenStack Compute service.
+package extensions
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/doc.go
new file mode 100644
index 000000000..faafe7c31
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/doc.go
@@ -0,0 +1,13 @@
+/*
+Package evacuate provides functionality to evacuates servers that have been
+provisioned by the OpenStack Compute service from a failed host to a new host.
+
+Example to Evacuate a Server from a Host
+
+	serverID := "b16ba811-199d-4ffd-8839-ba96c1185a67"
+	err := evacuate.Evacuate(computeClient, serverID, evacuate.EvacuateOpts{}).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package evacuate
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/requests.go
new file mode 100644
index 000000000..b0455acc7
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/requests.go
@@ -0,0 +1,42 @@
+package evacuate
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// EvacuateOptsBuilder allows extensions to add additional parameters to the
+// the Evacuate request.
+type EvacuateOptsBuilder interface {
+	ToEvacuateMap() (map[string]interface{}, error)
+}
+
+// EvacuateOpts specifies Evacuate action parameters.
+type EvacuateOpts struct {
+	// The name of the host to which the server is evacuated
+	Host string `json:"host,omitempty"`
+
+	// Indicates whether server is on shared storage
+	OnSharedStorage bool `json:"onSharedStorage"`
+
+	// An administrative password to access the evacuated server
+	AdminPass string `json:"adminPass,omitempty"`
+}
+
+// ToServerGroupCreateMap constructs a request body from CreateOpts.
+func (opts EvacuateOpts) ToEvacuateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "evacuate")
+}
+
+// Evacuate will Evacuate a failed instance to another host.
+func Evacuate(client *gophercloud.ServiceClient, id string, opts EvacuateOptsBuilder) (r EvacuateResult) {
+	b, err := opts.ToEvacuateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(extensions.ActionURL(client, id), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/results.go
new file mode 100644
index 000000000..8342cb43d
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/results.go
@@ -0,0 +1,23 @@
+package evacuate
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// EvacuateResult is the response from an Evacuate operation.
+//Call its ExtractAdminPass method to retrieve the admin password of the instance.
+//The admin password will be an empty string if the cloud is not configured to inject admin passwords..
+type EvacuateResult struct {
+	gophercloud.Result
+}
+
+func (r EvacuateResult) ExtractAdminPass() (string, error) {
+	var s struct {
+		AdminPass string `json:"adminPass"`
+	}
+	err := r.ExtractInto(&s)
+	if err != nil && err.Error() == "EOF" {
+		return "", nil
+	}
+	return s.AdminPass, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/doc.go
new file mode 100644
index 000000000..613ac1d4b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/doc.go
@@ -0,0 +1,2 @@
+// compute_extensions_evacuate_v2
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/fixtures.go
new file mode 100644
index 000000000..e078d1019
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/fixtures.go
@@ -0,0 +1,83 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func mockEvacuateResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+		{
+		    "evacuate": {
+		    "adminPass": "MySecretPass",
+		    "host": "derp",
+		    "onSharedStorage": false
+		  }
+
+		}
+		      `)
+		w.WriteHeader(http.StatusOK)
+	})
+}
+
+func mockEvacuateResponseWithHost(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+		{
+		    "evacuate": {
+		    "host": "derp",
+		    "onSharedStorage": false
+		  }
+
+		}
+		      `)
+		w.WriteHeader(http.StatusOK)
+	})
+}
+
+func mockEvacuateResponseWithNoOpts(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+		{
+		    "evacuate": {
+		    "onSharedStorage": false
+		  }
+
+		}
+		      `)
+		w.WriteHeader(http.StatusOK)
+	})
+}
+
+const EvacuateResponse = `
+{
+  "adminPass": "MySecretPass"
+}
+`
+
+func mockEvacuateAdminpassResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+    {
+        "evacuate": {
+          "onSharedStorage": false
+        }
+    }
+          `)
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, EvacuateResponse)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/requests_test.go
new file mode 100644
index 000000000..aec03114b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate/testing/requests_test.go
@@ -0,0 +1,60 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/evacuate"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestEvacuate(t *testing.T) {
+	const serverID = "b16ba811-199d-4ffd-8839-ba96c1185a67"
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockEvacuateResponse(t, serverID)
+
+	_, err := evacuate.Evacuate(client.ServiceClient(), serverID, evacuate.EvacuateOpts{
+		Host:            "derp",
+		AdminPass:       "MySecretPass",
+		OnSharedStorage: false,
+	}).ExtractAdminPass()
+	th.AssertNoErr(t, err)
+}
+
+func TestEvacuateWithHost(t *testing.T) {
+	const serverID = "b16ba811-199d-4ffd-8839-ba96c1185a67"
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockEvacuateResponseWithHost(t, serverID)
+
+	_, err := evacuate.Evacuate(client.ServiceClient(), serverID, evacuate.EvacuateOpts{
+		Host: "derp",
+	}).ExtractAdminPass()
+	th.AssertNoErr(t, err)
+}
+
+func TestEvacuateWithNoOpts(t *testing.T) {
+	const serverID = "b16ba811-199d-4ffd-8839-ba96c1185a67"
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockEvacuateResponseWithNoOpts(t, serverID)
+
+	_, err := evacuate.Evacuate(client.ServiceClient(), serverID, evacuate.EvacuateOpts{}).ExtractAdminPass()
+	th.AssertNoErr(t, err)
+}
+
+func TestEvacuateAdminpassResponse(t *testing.T) {
+	const serverID = "b16ba811-199d-4ffd-8839-ba96c1185a67"
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockEvacuateAdminpassResponse(t, serverID)
+
+	actual, err := evacuate.Evacuate(client.ServiceClient(), serverID, evacuate.EvacuateOpts{}).ExtractAdminPass()
+	th.CheckEquals(t, "MySecretPass", actual)
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/doc.go
new file mode 100644
index 000000000..53e24dbe1
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/doc.go
@@ -0,0 +1,67 @@
+/*
+Package extendedserverattributes provides the ability to extend a
+server result with the extended usage information.
+
+Example to Get basic extended information:
+
+  type serverAttributesExt struct {
+    servers.Server
+    extendedserverattributes.ServerAttributesExt
+  }
+  var serverWithAttributesExt serverAttributesExt
+
+  err := servers.Get(computeClient, "d650a0ce-17c3-497d-961a-43c4af80998a").ExtractInto(&serverWithAttributesExt)
+  if err != nil {
+    panic(err)
+  }
+
+  fmt.Printf("%+v\n", serverWithAttributesExt)
+
+Example to get additional fields with microversion 2.3 or later
+
+  computeClient.Microversion = "2.3"
+  result := servers.Get(computeClient, "d650a0ce-17c3-497d-961a-43c4af80998a")
+
+  reservationID, err := extendedserverattributes.ExtractReservationID(result.Result)
+  if err != nil {
+    panic(err)
+  }
+  fmt.Printf("%s\n", reservationID)
+
+  launchIndex, err := extendedserverattributes.ExtractLaunchIndex(result.Result)
+  if err != nil {
+    panic(err)
+  }
+  fmt.Printf("%d\n", launchIndex)
+
+  ramdiskID, err := extendedserverattributes.ExtractRamdiskID(result.Result)
+  if err != nil {
+    panic(err)
+  }
+  fmt.Printf("%s\n", ramdiskID)
+
+  kernelID, err := extendedserverattributes.ExtractKernelID(result.Result)
+  if err != nil {
+    panic(err)
+  }
+  fmt.Printf("%s\n", kernelID)
+
+  hostname, err := extendedserverattributes.ExtractHostname(result.Result)
+  if err != nil {
+    panic(err)
+  }
+  fmt.Printf("%s\n", hostname)
+
+  rootDeviceName, err := extendedserverattributes.ExtractRootDeviceName(result.Result)
+  if err != nil {
+    panic(err)
+  }
+  fmt.Printf("%s\n", rootDeviceName)
+
+  userData, err := extendedserverattributes.ExtractUserData(result.Result)
+  if err != nil {
+    panic(err)
+  }
+  fmt.Printf("%s\n", userData)
+*/
+package extendedserverattributes
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/results.go
new file mode 100644
index 000000000..1640cf510
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/results.go
@@ -0,0 +1,44 @@
+package extendedserverattributes
+
+// ServerAttributesExt represents basic OS-EXT-SRV-ATTR server response fields.
+// You should use extract methods from microversions.go to retrieve additional
+// fields.
+type ServerAttributesExt struct {
+	// Host is the host/hypervisor that the instance is hosted on.
+	Host string `json:"OS-EXT-SRV-ATTR:host"`
+
+	// InstanceName is the name of the instance.
+	InstanceName string `json:"OS-EXT-SRV-ATTR:instance_name"`
+
+	// HypervisorHostname is the hostname of the host/hypervisor that the
+	// instance is hosted on.
+	HypervisorHostname string `json:"OS-EXT-SRV-ATTR:hypervisor_hostname"`
+
+	// ReservationID is the reservation ID of the instance.
+	// This requires microversion 2.3 or later.
+	ReservationID *string `json:"OS-EXT-SRV-ATTR:reservation_id"`
+
+	// LaunchIndex is the launch index of the instance.
+	// This requires microversion 2.3 or later.
+	LaunchIndex *int `json:"OS-EXT-SRV-ATTR:launch_index"`
+
+	// RAMDiskID is the ID of the RAM disk image of the instance.
+	// This requires microversion 2.3 or later.
+	RAMDiskID *string `json:"OS-EXT-SRV-ATTR:ramdisk_id"`
+
+	// KernelID is the ID of the kernel image of the instance.
+	// This requires microversion 2.3 or later.
+	KernelID *string `json:"OS-EXT-SRV-ATTR:kernel_id"`
+
+	// Hostname is the hostname of the instance.
+	// This requires microversion 2.3 or later.
+	Hostname *string `json:"OS-EXT-SRV-ATTR:hostname"`
+
+	// RootDeviceName is the name of the root device of the instance.
+	// This requires microversion 2.3 or later.
+	RootDeviceName *string `json:"OS-EXT-SRV-ATTR:root_device_name"`
+
+	// Userdata is the userdata of the instance.
+	// This requires microversion 2.3 or later.
+	Userdata *string `json:"OS-EXT-SRV-ATTR:user_data"`
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/doc.go
new file mode 100644
index 000000000..7603f836a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/doc.go
@@ -0,0 +1 @@
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/fixtures.go
new file mode 100644
index 000000000..1034bee09
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/fixtures.go
@@ -0,0 +1,28 @@
+package testing
+
+// ServerWithAttributesExtResult represents a raw server response from the
+// Compute API with OS-EXT-SRV-ATTR data.
+// Most of the actual fields were deleted from the response.
+const ServerWithAttributesExtResult = `
+{
+    "server": {
+        "OS-EXT-SRV-ATTR:user_data": "Zm9v",
+        "OS-EXT-SRV-ATTR:instance_name": "instance-00000001",
+        "OS-EXT-SRV-ATTR:root_device_name": "/dev/sda",
+        "OS-EXT-SRV-ATTR:hostname": "test00",
+        "OS-EXT-SRV-ATTR:reservation_id": "r-ky9gim1l",
+        "OS-EXT-SRV-ATTR:ramdisk_id": "",
+        "OS-EXT-SRV-ATTR:host": "compute01",
+        "OS-EXT-SRV-ATTR:kernel_id": "",
+        "OS-EXT-SRV-ATTR:hypervisor_hostname": "compute01",
+        "OS-EXT-SRV-ATTR:launch_index": 0,
+        "created": "2018-07-27T09:15:48Z",
+        "updated": "2018-07-27T09:15:55Z",
+        "id": "d650a0ce-17c3-497d-961a-43c4af80998a",
+        "name": "test_instance",
+        "status": "ACTIVE",
+        "user_id": "0f2f3822679e4b3ea073e5d1c6ed5f02",
+        "tenant_id": "424e7cf0243c468ca61732ba45973b3e"
+    }
+}
+`
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/requests_test.go
new file mode 100644
index 000000000..a9d5d24b3
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes/testing/requests_test.go
@@ -0,0 +1,44 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedserverattributes"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	fake "github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestServerWithUsageExt(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/d650a0ce-17c3-497d-961a-43c4af80998a", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+		th.TestHeader(t, r, "Accept", "application/json")
+
+		fmt.Fprintf(w, ServerWithAttributesExtResult)
+	})
+
+	type serverAttributesExt struct {
+		servers.Server
+		extendedserverattributes.ServerAttributesExt
+	}
+	var serverWithAttributesExt serverAttributesExt
+
+	// Extract basic fields.
+	err := servers.Get(fake.ServiceClient(), "d650a0ce-17c3-497d-961a-43c4af80998a").ExtractInto(&serverWithAttributesExt)
+	th.AssertNoErr(t, err)
+
+	th.AssertEquals(t, serverWithAttributesExt.Host, "compute01")
+	th.AssertEquals(t, serverWithAttributesExt.InstanceName, "instance-00000001")
+	th.AssertEquals(t, serverWithAttributesExt.HypervisorHostname, "compute01")
+	th.AssertEquals(t, *serverWithAttributesExt.Userdata, "Zm9v")
+	th.AssertEquals(t, *serverWithAttributesExt.ReservationID, "r-ky9gim1l")
+	th.AssertEquals(t, *serverWithAttributesExt.LaunchIndex, 0)
+	th.AssertEquals(t, *serverWithAttributesExt.Hostname, "test00")
+	th.AssertEquals(t, *serverWithAttributesExt.RootDeviceName, "/dev/sda")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedstatus/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedstatus/doc.go
new file mode 100644
index 000000000..33b1e35cd
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedstatus/doc.go
@@ -0,0 +1,28 @@
+/*
+Package extendedstatus provides the ability to extend a server result with
+the extended status information. Example:
+
+	type ServerWithExt struct {
+		servers.Server
+		extendedstatus.ServerExtendedStatusExt
+	}
+
+	var allServers []ServerWithExt
+
+	allPages, err := servers.List(client, nil).AllPages()
+	if err != nil {
+		panic("Unable to retrieve servers: %s", err)
+	}
+
+	err = servers.ExtractServersInto(allPages, &allServers)
+	if err != nil {
+		panic("Unable to extract servers: %s", err)
+	}
+
+	for _, server := range allServers {
+		fmt.Println(server.TaskState)
+		fmt.Println(server.VmState)
+		fmt.Println(server.PowerState)
+	}
+*/
+package extendedstatus
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedstatus/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedstatus/results.go
new file mode 100644
index 000000000..acfbd3fb2
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/extendedstatus/results.go
@@ -0,0 +1,41 @@
+package extendedstatus
+
+type PowerState int
+
+type ServerExtendedStatusExt struct {
+	TaskState  string     `json:"OS-EXT-STS:task_state"`
+	VmState    string     `json:"OS-EXT-STS:vm_state"`
+	PowerState PowerState `json:"OS-EXT-STS:power_state"`
+}
+
+const (
+	NOSTATE = iota
+	RUNNING
+	_UNUSED1
+	PAUSED
+	SHUTDOWN
+	_UNUSED2
+	CRASHED
+	SUSPENDED
+)
+
+func (r PowerState) String() string {
+	switch r {
+	case NOSTATE:
+		return "NOSTATE"
+	case RUNNING:
+		return "RUNNING"
+	case PAUSED:
+		return "PAUSED"
+	case SHUTDOWN:
+		return "SHUTDOWN"
+	case CRASHED:
+		return "CRASHED"
+	case SUSPENDED:
+		return "SUSPENDED"
+	case _UNUSED1, _UNUSED2:
+		return "_UNUSED"
+	default:
+		return "N/A"
+	}
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/doc.go
new file mode 100644
index 000000000..f5dbdbf8b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/doc.go
@@ -0,0 +1,68 @@
+/*
+Package floatingips provides the ability to manage floating ips through the
+Nova API.
+
+This API has been deprecated and will be removed from a future release of the
+Nova API service.
+
+For environements that support this extension, this package can be used
+regardless of if either Neutron or nova-network is used as the cloud's network
+service.
+
+Example to List Floating IPs
+
+	allPages, err := floatingips.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allFloatingIPs, err := floatingips.ExtractFloatingIPs(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, fip := range allFloatingIPs {
+		fmt.Printf("%+v\n", fip)
+	}
+
+Example to Create a Floating IP
+
+	createOpts := floatingips.CreateOpts{
+		Pool: "nova",
+	}
+
+	fip, err := floatingips.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Delete a Floating IP
+
+	err := floatingips.Delete(computeClient, "floatingip-id").ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Associate a Floating IP With a Server
+
+	associateOpts := floatingips.AssociateOpts{
+		FloatingIP: "10.10.10.2",
+	}
+
+	err := floatingips.AssociateInstance(computeClient, "server-id", associateOpts).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Disassociate a Floating IP From a Server
+
+	disassociateOpts := floatingips.DisassociateOpts{
+		FloatingIP: "10.10.10.2",
+	}
+
+	err := floatingips.DisassociateInstance(computeClient, "server-id", disassociateOpts).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package floatingips
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/requests.go
new file mode 100644
index 000000000..a922639de
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/requests.go
@@ -0,0 +1,114 @@
+package floatingips
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List returns a Pager that allows you to iterate over a collection of FloatingIPs.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, listURL(client), func(r pagination.PageResult) pagination.Page {
+		return FloatingIPPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// CreateOptsBuilder allows extensions to add additional parameters to the
+// Create request.
+type CreateOptsBuilder interface {
+	ToFloatingIPCreateMap() (map[string]interface{}, error)
+}
+
+// CreateOpts specifies a Floating IP allocation request.
+type CreateOpts struct {
+	// Pool is the pool of Floating IPs to allocate one from.
+	Pool string `json:"pool" required:"true"`
+}
+
+// ToFloatingIPCreateMap constructs a request body from CreateOpts.
+func (opts CreateOpts) ToFloatingIPCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "")
+}
+
+// Create requests the creation of a new Floating IP.
+func Create(client *gophercloud.ServiceClient, opts CreateOptsBuilder) (r CreateResult) {
+	b, err := opts.ToFloatingIPCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(createURL(client), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Get returns data about a previously created Floating IP.
+func Get(client *gophercloud.ServiceClient, id string) (r GetResult) {
+	_, r.Err = client.Get(getURL(client, id), &r.Body, nil)
+	return
+}
+
+// Delete requests the deletion of a previous allocated Floating IP.
+func Delete(client *gophercloud.ServiceClient, id string) (r DeleteResult) {
+	_, r.Err = client.Delete(deleteURL(client, id), nil)
+	return
+}
+
+// AssociateOptsBuilder allows extensions to add additional parameters to the
+// Associate request.
+type AssociateOptsBuilder interface {
+	ToFloatingIPAssociateMap() (map[string]interface{}, error)
+}
+
+// AssociateOpts specifies the required information to associate a Floating IP with an instance
+type AssociateOpts struct {
+	// FloatingIP is the Floating IP to associate with an instance.
+	FloatingIP string `json:"address" required:"true"`
+
+	// FixedIP is an optional fixed IP address of the server.
+	FixedIP string `json:"fixed_address,omitempty"`
+}
+
+// ToFloatingIPAssociateMap constructs a request body from AssociateOpts.
+func (opts AssociateOpts) ToFloatingIPAssociateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "addFloatingIp")
+}
+
+// AssociateInstance pairs an allocated Floating IP with a server.
+func AssociateInstance(client *gophercloud.ServiceClient, serverID string, opts AssociateOptsBuilder) (r AssociateResult) {
+	b, err := opts.ToFloatingIPAssociateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(associateURL(client, serverID), b, nil, nil)
+	return
+}
+
+// DisassociateOptsBuilder allows extensions to add additional parameters to
+// the Disassociate request.
+type DisassociateOptsBuilder interface {
+	ToFloatingIPDisassociateMap() (map[string]interface{}, error)
+}
+
+// DisassociateOpts specifies the required information to disassociate a
+// Floating IP with a server.
+type DisassociateOpts struct {
+	FloatingIP string `json:"address" required:"true"`
+}
+
+// ToFloatingIPDisassociateMap constructs a request body from DisassociateOpts.
+func (opts DisassociateOpts) ToFloatingIPDisassociateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "removeFloatingIp")
+}
+
+// DisassociateInstance decouples an allocated Floating IP from an instance
+func DisassociateInstance(client *gophercloud.ServiceClient, serverID string, opts DisassociateOptsBuilder) (r DisassociateResult) {
+	b, err := opts.ToFloatingIPDisassociateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(disassociateURL(client, serverID), b, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/results.go
new file mode 100644
index 000000000..da4e9da0e
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/results.go
@@ -0,0 +1,115 @@
+package floatingips
+
+import (
+	"encoding/json"
+	"strconv"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// A FloatingIP is an IP that can be associated with a server.
+type FloatingIP struct {
+	// ID is a unique ID of the Floating IP
+	ID string `json:"-"`
+
+	// FixedIP is a specific IP on the server to pair the Floating IP with.
+	FixedIP string `json:"fixed_ip,omitempty"`
+
+	// InstanceID is the ID of the server that is using the Floating IP.
+	InstanceID string `json:"instance_id"`
+
+	// IP is the actual Floating IP.
+	IP string `json:"ip"`
+
+	// Pool is the pool of Floating IPs that this Floating IP belongs to.
+	Pool string `json:"pool"`
+}
+
+func (r *FloatingIP) UnmarshalJSON(b []byte) error {
+	type tmp FloatingIP
+	var s struct {
+		tmp
+		ID interface{} `json:"id"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+
+	*r = FloatingIP(s.tmp)
+
+	switch t := s.ID.(type) {
+	case float64:
+		r.ID = strconv.FormatFloat(t, 'f', -1, 64)
+	case string:
+		r.ID = t
+	}
+
+	return err
+}
+
+// FloatingIPPage stores a single page of FloatingIPs from a List call.
+type FloatingIPPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a FloatingIPsPage is empty.
+func (page FloatingIPPage) IsEmpty() (bool, error) {
+	va, err := ExtractFloatingIPs(page)
+	return len(va) == 0, err
+}
+
+// ExtractFloatingIPs interprets a page of results as a slice of FloatingIPs.
+func ExtractFloatingIPs(r pagination.Page) ([]FloatingIP, error) {
+	var s struct {
+		FloatingIPs []FloatingIP `json:"floating_ips"`
+	}
+	err := (r.(FloatingIPPage)).ExtractInto(&s)
+	return s.FloatingIPs, err
+}
+
+// FloatingIPResult is the raw result from a FloatingIP request.
+type FloatingIPResult struct {
+	gophercloud.Result
+}
+
+// Extract is a method that attempts to interpret any FloatingIP resource
+// response as a FloatingIP struct.
+func (r FloatingIPResult) Extract() (*FloatingIP, error) {
+	var s struct {
+		FloatingIP *FloatingIP `json:"floating_ip"`
+	}
+	err := r.ExtractInto(&s)
+	return s.FloatingIP, err
+}
+
+// CreateResult is the response from a Create operation. Call its Extract method
+// to interpret it as a FloatingIP.
+type CreateResult struct {
+	FloatingIPResult
+}
+
+// GetResult is the response from a Get operation. Call its Extract method to
+// interpret it as a FloatingIP.
+type GetResult struct {
+	FloatingIPResult
+}
+
+// DeleteResult is the response from a Delete operation. Call its ExtractErr
+// method to determine if the call succeeded or failed.
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
+
+// AssociateResult is the response from a Delete operation. Call its ExtractErr
+// method to determine if the call succeeded or failed.
+type AssociateResult struct {
+	gophercloud.ErrResult
+}
+
+// DisassociateResult is the response from a Delete operation. Call its
+// ExtractErr method to determine if the call succeeded or failed.
+type DisassociateResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/doc.go
new file mode 100644
index 000000000..82dfbe7fe
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/doc.go
@@ -0,0 +1,2 @@
+// floatingips unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/fixtures.go
new file mode 100644
index 000000000..6866e265d
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/fixtures.go
@@ -0,0 +1,223 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ListOutput is a sample response to a List call.
+const ListOutput = `
+{
+    "floating_ips": [
+        {
+            "fixed_ip": null,
+            "id": "1",
+            "instance_id": null,
+            "ip": "10.10.10.1",
+            "pool": "nova"
+        },
+        {
+            "fixed_ip": "166.78.185.201",
+            "id": "2",
+            "instance_id": "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+            "ip": "10.10.10.2",
+            "pool": "nova"
+        }
+    ]
+}
+`
+
+// GetOutput is a sample response to a Get call.
+const GetOutput = `
+{
+    "floating_ip": {
+        "fixed_ip": "166.78.185.201",
+        "id": "2",
+        "instance_id": "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+        "ip": "10.10.10.2",
+        "pool": "nova"
+    }
+}
+`
+
+// CreateOutput is a sample response to a Post call
+const CreateOutput = `
+{
+    "floating_ip": {
+        "fixed_ip": null,
+        "id": "1",
+        "instance_id": null,
+        "ip": "10.10.10.1",
+        "pool": "nova"
+    }
+}
+`
+
+// CreateOutputWithNumericID is a sample response to a Post call
+// with a legacy nova-network-based numeric ID.
+const CreateOutputWithNumericID = `
+{
+    "floating_ip": {
+        "fixed_ip": null,
+        "id": 1,
+        "instance_id": null,
+        "ip": "10.10.10.1",
+        "pool": "nova"
+    }
+}
+`
+
+// FirstFloatingIP is the first result in ListOutput.
+var FirstFloatingIP = floatingips.FloatingIP{
+	ID:   "1",
+	IP:   "10.10.10.1",
+	Pool: "nova",
+}
+
+// SecondFloatingIP is the first result in ListOutput.
+var SecondFloatingIP = floatingips.FloatingIP{
+	FixedIP:    "166.78.185.201",
+	ID:         "2",
+	InstanceID: "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+	IP:         "10.10.10.2",
+	Pool:       "nova",
+}
+
+// ExpectedFloatingIPsSlice is the slice of results that should be parsed
+// from ListOutput, in the expected order.
+var ExpectedFloatingIPsSlice = []floatingips.FloatingIP{FirstFloatingIP, SecondFloatingIP}
+
+// CreatedFloatingIP is the parsed result from CreateOutput.
+var CreatedFloatingIP = floatingips.FloatingIP{
+	ID:   "1",
+	IP:   "10.10.10.1",
+	Pool: "nova",
+}
+
+// HandleListSuccessfully configures the test server to respond to a List request.
+func HandleListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-floating-ips", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ListOutput)
+	})
+}
+
+// HandleGetSuccessfully configures the test server to respond to a Get request
+// for an existing floating ip
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-floating-ips/2", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
+
+// HandleCreateSuccessfully configures the test server to respond to a Create request
+// for a new floating ip
+func HandleCreateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-floating-ips", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+{
+	"pool": "nova"
+}
+`)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, CreateOutput)
+	})
+}
+
+// HandleCreateWithNumericIDSuccessfully configures the test server to respond to a Create request
+// for a new floating ip
+func HandleCreateWithNumericIDSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-floating-ips", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+{
+	"pool": "nova"
+}
+`)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, CreateOutputWithNumericID)
+	})
+}
+
+// HandleDeleteSuccessfully configures the test server to respond to a Delete request for a
+// an existing floating ip
+func HandleDeleteSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-floating-ips/1", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+// HandleAssociateSuccessfully configures the test server to respond to a Post request
+// to associate an allocated floating IP
+func HandleAssociateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/4d8c3732-a248-40ed-bebc-539a6ffd25c0/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+{
+	"addFloatingIp": {
+		"address": "10.10.10.2"
+	}
+}
+`)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+// HandleFixedAssociateSucessfully configures the test server to respond to a Post request
+// to associate an allocated floating IP with a specific fixed IP address
+func HandleAssociateFixedSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/4d8c3732-a248-40ed-bebc-539a6ffd25c0/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+{
+	"addFloatingIp": {
+		"address": "10.10.10.2",
+		"fixed_address": "166.78.185.201"
+	}
+}
+`)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+// HandleDisassociateSuccessfully configures the test server to respond to a Post request
+// to disassociate an allocated floating IP
+func HandleDisassociateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/4d8c3732-a248-40ed-bebc-539a6ffd25c0/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+{
+	"removeFloatingIp": {
+		"address": "10.10.10.2"
+	}
+}
+`)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/requests_test.go
new file mode 100644
index 000000000..2356671e0
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/testing/requests_test.go
@@ -0,0 +1,111 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleListSuccessfully(t)
+
+	count := 0
+	err := floatingips.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := floatingips.ExtractFloatingIPs(page)
+		th.AssertNoErr(t, err)
+		th.CheckDeepEquals(t, ExpectedFloatingIPsSlice, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.CheckEquals(t, 1, count)
+}
+
+func TestCreate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleCreateSuccessfully(t)
+
+	actual, err := floatingips.Create(client.ServiceClient(), floatingips.CreateOpts{
+		Pool: "nova",
+	}).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &CreatedFloatingIP, actual)
+}
+
+func TestCreateWithNumericID(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleCreateWithNumericIDSuccessfully(t)
+
+	actual, err := floatingips.Create(client.ServiceClient(), floatingips.CreateOpts{
+		Pool: "nova",
+	}).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &CreatedFloatingIP, actual)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSuccessfully(t)
+
+	actual, err := floatingips.Get(client.ServiceClient(), "2").Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &SecondFloatingIP, actual)
+}
+
+func TestDelete(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleDeleteSuccessfully(t)
+
+	err := floatingips.Delete(client.ServiceClient(), "1").ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestAssociate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleAssociateSuccessfully(t)
+
+	associateOpts := floatingips.AssociateOpts{
+		FloatingIP: "10.10.10.2",
+	}
+
+	err := floatingips.AssociateInstance(client.ServiceClient(), "4d8c3732-a248-40ed-bebc-539a6ffd25c0", associateOpts).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestAssociateFixed(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleAssociateFixedSuccessfully(t)
+
+	associateOpts := floatingips.AssociateOpts{
+		FloatingIP: "10.10.10.2",
+		FixedIP:    "166.78.185.201",
+	}
+
+	err := floatingips.AssociateInstance(client.ServiceClient(), "4d8c3732-a248-40ed-bebc-539a6ffd25c0", associateOpts).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestDisassociateInstance(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleDisassociateSuccessfully(t)
+
+	disassociateOpts := floatingips.DisassociateOpts{
+		FloatingIP: "10.10.10.2",
+	}
+
+	err := floatingips.DisassociateInstance(client.ServiceClient(), "4d8c3732-a248-40ed-bebc-539a6ffd25c0", disassociateOpts).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/urls.go
new file mode 100644
index 000000000..4768e5a89
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips/urls.go
@@ -0,0 +1,37 @@
+package floatingips
+
+import "github.com/gophercloud/gophercloud"
+
+const resourcePath = "os-floating-ips"
+
+func resourceURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(resourcePath)
+}
+
+func listURL(c *gophercloud.ServiceClient) string {
+	return resourceURL(c)
+}
+
+func createURL(c *gophercloud.ServiceClient) string {
+	return resourceURL(c)
+}
+
+func getURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL(resourcePath, id)
+}
+
+func deleteURL(c *gophercloud.ServiceClient, id string) string {
+	return getURL(c, id)
+}
+
+func serverURL(c *gophercloud.ServiceClient, serverID string) string {
+	return c.ServiceURL("servers/" + serverID + "/action")
+}
+
+func associateURL(c *gophercloud.ServiceClient, serverID string) string {
+	return serverURL(c, serverID)
+}
+
+func disassociateURL(c *gophercloud.ServiceClient, serverID string) string {
+	return serverURL(c, serverID)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/doc.go
new file mode 100644
index 000000000..8f7d773e7
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/doc.go
@@ -0,0 +1,70 @@
+/*
+Package hypervisors returns details about list of hypervisors, shows details for a hypervisor
+and shows summary statistics for all hypervisors over all compute nodes in the OpenStack cloud.
+
+Example of Show Hypervisor Details
+
+	hypervisorID := "42"
+	hypervisor, err := hypervisors.Get(computeClient, hypervisorID).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v\n", hypervisor)
+
+Example of Show Hypervisor Details with Compute API microversion greater than 2.53
+
+    hypervisorID := "c48f6247-abe4-4a24-824e-ea39e108874f"
+    hypervisor, err := hypervisors.Get(computeClient, hypervisorID).Extract()
+    if err != nil {
+        panic(err)
+    }
+
+	fmt.Printf("%+v\n", hypervisor)
+
+Example of Retrieving Details of All Hypervisors
+
+	allPages, err := hypervisors.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allHypervisors, err := hypervisors.ExtractHypervisors(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, hypervisor := range allHypervisors {
+		fmt.Printf("%+v\n", hypervisor)
+	}
+
+Example of Show Hypervisors Statistics
+
+	hypervisorsStatistics, err := hypervisors.GetStatistics(computeClient).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v\n", hypervisorsStatistics)
+
+Example of Show Hypervisor Uptime
+
+	hypervisorID := "42"
+	hypervisorUptime, err := hypervisors.GetUptime(computeClient, hypervisorID).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v\n", hypervisorUptime)
+
+Example of Show Hypervisor Uptime with Compute API microversion greater than 2.53
+
+    hypervisorID := "c48f6247-abe4-4a24-824e-ea39e108874f"
+    hypervisorUptime, err := hypervisors.GetUptime(computeClient, hypervisorID).Extract()
+    if err != nil {
+        panic(err)
+    }
+
+	fmt.Printf("%+v\n", hypervisorUptime)
+*/
+package hypervisors
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/requests.go
new file mode 100644
index 000000000..db16543e2
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/requests.go
@@ -0,0 +1,37 @@
+package hypervisors
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List makes a request against the API to list hypervisors.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, hypervisorsListDetailURL(client), func(r pagination.PageResult) pagination.Page {
+		return HypervisorPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// Statistics makes a request against the API to get hypervisors statistics.
+func GetStatistics(client *gophercloud.ServiceClient) (r StatisticsResult) {
+	_, r.Err = client.Get(hypervisorsStatisticsURL(client), &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Get makes a request against the API to get details for specific hypervisor.
+func Get(client *gophercloud.ServiceClient, hypervisorID string) (r HypervisorResult) {
+	_, r.Err = client.Get(hypervisorsGetURL(client, hypervisorID), &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// GetUptime makes a request against the API to get uptime for specific hypervisor.
+func GetUptime(client *gophercloud.ServiceClient, hypervisorID string) (r UptimeResult) {
+	_, r.Err = client.Get(hypervisorsUptimeURL(client, hypervisorID), &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/results.go
new file mode 100644
index 000000000..5dab0f3d3
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/results.go
@@ -0,0 +1,367 @@
+package hypervisors
+
+import (
+	"encoding/json"
+	"fmt"
+	"strconv"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// Topology represents a CPU Topology.
+type Topology struct {
+	Sockets int `json:"sockets"`
+	Cores   int `json:"cores"`
+	Threads int `json:"threads"`
+}
+
+// CPUInfo represents CPU information of the hypervisor.
+type CPUInfo struct {
+	Vendor   string   `json:"vendor"`
+	Arch     string   `json:"arch"`
+	Model    string   `json:"model"`
+	Features []string `json:"features"`
+	Topology Topology `json:"topology"`
+}
+
+// Service represents a Compute service running on the hypervisor.
+type Service struct {
+	Host           string `json:"host"`
+	ID             string `json:"-"`
+	DisabledReason string `json:"disabled_reason"`
+}
+
+func (r *Service) UnmarshalJSON(b []byte) error {
+	type tmp Service
+	var s struct {
+		tmp
+		ID interface{} `json:"id"`
+	}
+
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+
+	*r = Service(s.tmp)
+
+	// OpenStack Compute service returns ID in string representation since
+	// 2.53 microversion API (Pike release).
+	switch t := s.ID.(type) {
+	case int:
+		r.ID = strconv.Itoa(t)
+	case float64:
+		r.ID = strconv.Itoa(int(t))
+	case string:
+		r.ID = t
+	default:
+		return fmt.Errorf("ID has unexpected type: %T", t)
+	}
+
+	return nil
+}
+
+// Hypervisor represents a hypervisor in the OpenStack cloud.
+type Hypervisor struct {
+	// A structure that contains cpu information like arch, model, vendor,
+	// features and topology.
+	CPUInfo CPUInfo `json:"-"`
+
+	// The current_workload is the number of tasks the hypervisor is responsible
+	// for. This will be equal or greater than the number of active VMs on the
+	// system (it can be greater when VMs are being deleted and the hypervisor is
+	// still cleaning up).
+	CurrentWorkload int `json:"current_workload"`
+
+	// Status of the hypervisor, either "enabled" or "disabled".
+	Status string `json:"status"`
+
+	// State of the hypervisor, either "up" or "down".
+	State string `json:"state"`
+
+	// DiskAvailableLeast is the actual free disk on this hypervisor,
+	// measured in GB.
+	DiskAvailableLeast int `json:"disk_available_least"`
+
+	// HostIP is the hypervisor's IP address.
+	HostIP string `json:"host_ip"`
+
+	// FreeDiskGB is the free disk remaining on the hypervisor, measured in GB.
+	FreeDiskGB int `json:"-"`
+
+	// FreeRAMMB is the free RAM in the hypervisor, measured in MB.
+	FreeRamMB int `json:"free_ram_mb"`
+
+	// HypervisorHostname is the hostname of the hypervisor.
+	HypervisorHostname string `json:"hypervisor_hostname"`
+
+	// HypervisorType is the type of hypervisor.
+	HypervisorType string `json:"hypervisor_type"`
+
+	// HypervisorVersion is the version of the hypervisor.
+	HypervisorVersion int `json:"-"`
+
+	// ID is the unique ID of the hypervisor.
+	ID string `json:"-"`
+
+	// LocalGB is the disk space in the hypervisor, measured in GB.
+	LocalGB int `json:"-"`
+
+	// LocalGBUsed is the used disk space of the  hypervisor, measured in GB.
+	LocalGBUsed int `json:"local_gb_used"`
+
+	// MemoryMB is the total memory of the hypervisor, measured in MB.
+	MemoryMB int `json:"memory_mb"`
+
+	// MemoryMBUsed is the used memory of the hypervisor, measured in MB.
+	MemoryMBUsed int `json:"memory_mb_used"`
+
+	// RunningVMs is the The number of running vms on the hypervisor.
+	RunningVMs int `json:"running_vms"`
+
+	// Service is the service this hypervisor represents.
+	Service Service `json:"service"`
+
+	// VCPUs is the total number of vcpus on the hypervisor.
+	VCPUs int `json:"vcpus"`
+
+	// VCPUsUsed is the number of used vcpus on the hypervisor.
+	VCPUsUsed int `json:"vcpus_used"`
+}
+
+func (r *Hypervisor) UnmarshalJSON(b []byte) error {
+	type tmp Hypervisor
+	var s struct {
+		tmp
+		ID                interface{} `json:"id"`
+		CPUInfo           interface{} `json:"cpu_info"`
+		HypervisorVersion interface{} `json:"hypervisor_version"`
+		FreeDiskGB        interface{} `json:"free_disk_gb"`
+		LocalGB           interface{} `json:"local_gb"`
+	}
+
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+
+	*r = Hypervisor(s.tmp)
+
+	// Newer versions return the CPU info as the correct type.
+	// Older versions return the CPU info as a string and need to be
+	// unmarshalled by the json parser.
+	var tmpb []byte
+
+	switch t := s.CPUInfo.(type) {
+	case string:
+		tmpb = []byte(t)
+	case map[string]interface{}:
+		tmpb, err = json.Marshal(t)
+		if err != nil {
+			return err
+		}
+	default:
+		return fmt.Errorf("CPUInfo has unexpected type: %T", t)
+	}
+
+	if len(tmpb) != 0 {
+		err = json.Unmarshal(tmpb, &r.CPUInfo)
+		if err != nil {
+			return err
+		}
+	}
+
+	// These fields may be returned as a scientific notation, so they need
+	// converted to int.
+	switch t := s.HypervisorVersion.(type) {
+	case int:
+		r.HypervisorVersion = t
+	case float64:
+		r.HypervisorVersion = int(t)
+	default:
+		return fmt.Errorf("Hypervisor version has unexpected type: %T", t)
+	}
+
+	switch t := s.FreeDiskGB.(type) {
+	case int:
+		r.FreeDiskGB = t
+	case float64:
+		r.FreeDiskGB = int(t)
+	default:
+		return fmt.Errorf("Free disk GB has unexpected type: %T", t)
+	}
+
+	switch t := s.LocalGB.(type) {
+	case int:
+		r.LocalGB = t
+	case float64:
+		r.LocalGB = int(t)
+	default:
+		return fmt.Errorf("Local GB has unexpected type: %T", t)
+	}
+
+	// OpenStack Compute service returns ID in string representation since
+	// 2.53 microversion API (Pike release).
+	switch t := s.ID.(type) {
+	case int:
+		r.ID = strconv.Itoa(t)
+	case float64:
+		r.ID = strconv.Itoa(int(t))
+	case string:
+		r.ID = t
+	default:
+		return fmt.Errorf("ID has unexpected type: %T", t)
+	}
+
+	return nil
+}
+
+// HypervisorPage represents a single page of all Hypervisors from a List
+// request.
+type HypervisorPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a HypervisorPage is empty.
+func (page HypervisorPage) IsEmpty() (bool, error) {
+	va, err := ExtractHypervisors(page)
+	return len(va) == 0, err
+}
+
+// ExtractHypervisors interprets a page of results as a slice of Hypervisors.
+func ExtractHypervisors(p pagination.Page) ([]Hypervisor, error) {
+	var h struct {
+		Hypervisors []Hypervisor `json:"hypervisors"`
+	}
+	err := (p.(HypervisorPage)).ExtractInto(&h)
+	return h.Hypervisors, err
+}
+
+type HypervisorResult struct {
+	gophercloud.Result
+}
+
+// Extract interprets any HypervisorResult as a Hypervisor, if possible.
+func (r HypervisorResult) Extract() (*Hypervisor, error) {
+	var s struct {
+		Hypervisor Hypervisor `json:"hypervisor"`
+	}
+	err := r.ExtractInto(&s)
+	return &s.Hypervisor, err
+}
+
+// Statistics represents a summary statistics for all enabled
+// hypervisors over all compute nodes in the OpenStack cloud.
+type Statistics struct {
+	// The number of hypervisors.
+	Count int `json:"count"`
+
+	// The current_workload is the number of tasks the hypervisor is responsible for
+	CurrentWorkload int `json:"current_workload"`
+
+	// The actual free disk on this hypervisor(in GB).
+	DiskAvailableLeast int `json:"disk_available_least"`
+
+	// The free disk remaining on this hypervisor(in GB).
+	FreeDiskGB int `json:"free_disk_gb"`
+
+	// The free RAM in this hypervisor(in MB).
+	FreeRamMB int `json:"free_ram_mb"`
+
+	// The disk in this hypervisor(in GB).
+	LocalGB int `json:"local_gb"`
+
+	// The disk used in this hypervisor(in GB).
+	LocalGBUsed int `json:"local_gb_used"`
+
+	// The memory of this hypervisor(in MB).
+	MemoryMB int `json:"memory_mb"`
+
+	// The memory used in this hypervisor(in MB).
+	MemoryMBUsed int `json:"memory_mb_used"`
+
+	// The total number of running vms on all hypervisors.
+	RunningVMs int `json:"running_vms"`
+
+	// The number of vcpu in this hypervisor.
+	VCPUs int `json:"vcpus"`
+
+	// The number of vcpu used in this hypervisor.
+	VCPUsUsed int `json:"vcpus_used"`
+}
+
+type StatisticsResult struct {
+	gophercloud.Result
+}
+
+// Extract interprets any StatisticsResult as a Statistics, if possible.
+func (r StatisticsResult) Extract() (*Statistics, error) {
+	var s struct {
+		Stats Statistics `json:"hypervisor_statistics"`
+	}
+	err := r.ExtractInto(&s)
+	return &s.Stats, err
+}
+
+// Uptime represents uptime and additional info for a specific hypervisor.
+type Uptime struct {
+	// The hypervisor host name provided by the Nova virt driver.
+	// For the Ironic driver, it is the Ironic node uuid.
+	HypervisorHostname string `json:"hypervisor_hostname"`
+
+	// The id of the hypervisor.
+	ID string `json:"-"`
+
+	// The state of the hypervisor. One of up or down.
+	State string `json:"state"`
+
+	// The status of the hypervisor. One of enabled or disabled.
+	Status string `json:"status"`
+
+	// The total uptime of the hypervisor and information about average load.
+	Uptime string `json:"uptime"`
+}
+
+func (r *Uptime) UnmarshalJSON(b []byte) error {
+	type tmp Uptime
+	var s struct {
+		tmp
+		ID interface{} `json:"id"`
+	}
+
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+
+	*r = Uptime(s.tmp)
+
+	// OpenStack Compute service returns ID in string representation since
+	// 2.53 microversion API (Pike release).
+	switch t := s.ID.(type) {
+	case int:
+		r.ID = strconv.Itoa(t)
+	case float64:
+		r.ID = strconv.Itoa(int(t))
+	case string:
+		r.ID = t
+	default:
+		return fmt.Errorf("ID has unexpected type: %T", t)
+	}
+
+	return nil
+}
+
+type UptimeResult struct {
+	gophercloud.Result
+}
+
+// Extract interprets any UptimeResult as a Uptime, if possible.
+func (r UptimeResult) Extract() (*Uptime, error) {
+	var s struct {
+		Uptime Uptime `json:"hypervisor"`
+	}
+	err := r.ExtractInto(&s)
+	return &s.Uptime, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/testing/fixtures.go
new file mode 100644
index 000000000..34e61f5b7
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/testing/fixtures.go
@@ -0,0 +1,460 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors"
+	"github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// HypervisorListBodyPre253 represents a raw hypervisor list from the Compute
+// API with microversion older than 2.53.
+// The first hypervisor represents what the specification says (~Newton)
+// The second is exactly the same, but what you can get off a real system (~Kilo)
+const HypervisorListBodyPre253 = `
+{
+    "hypervisors": [
+        {
+            "cpu_info": {
+                "arch": "x86_64",
+                "model": "Nehalem",
+                "vendor": "Intel",
+                "features": [
+                    "pge",
+                    "clflush"
+                ],
+                "topology": {
+                    "cores": 1,
+                    "threads": 1,
+                    "sockets": 4
+                }
+            },
+            "current_workload": 0,
+            "status": "enabled",
+            "state": "up",
+            "disk_available_least": 0,
+            "host_ip": "1.1.1.1",
+            "free_disk_gb": 1028,
+            "free_ram_mb": 7680,
+            "hypervisor_hostname": "fake-mini",
+            "hypervisor_type": "fake",
+            "hypervisor_version": 2002000,
+            "id": 1,
+            "local_gb": 1028,
+            "local_gb_used": 0,
+            "memory_mb": 8192,
+            "memory_mb_used": 512,
+            "running_vms": 0,
+            "service": {
+                "host": "e6a37ee802d74863ab8b91ade8f12a67",
+                "id": 2,
+                "disabled_reason": null
+            },
+            "vcpus": 1,
+            "vcpus_used": 0
+        },
+        {
+            "cpu_info": "{\"arch\": \"x86_64\", \"model\": \"Nehalem\", \"vendor\": \"Intel\", \"features\": [\"pge\", \"clflush\"], \"topology\": {\"cores\": 1, \"threads\": 1, \"sockets\": 4}}",
+            "current_workload": 0,
+            "status": "enabled",
+            "state": "up",
+            "disk_available_least": 0,
+            "host_ip": "1.1.1.1",
+            "free_disk_gb": 1028,
+            "free_ram_mb": 7680,
+            "hypervisor_hostname": "fake-mini",
+            "hypervisor_type": "fake",
+            "hypervisor_version": 2.002e+06,
+            "id": 1,
+            "local_gb": 1028,
+            "local_gb_used": 0,
+            "memory_mb": 8192,
+            "memory_mb_used": 512,
+            "running_vms": 0,
+            "service": {
+                "host": "e6a37ee802d74863ab8b91ade8f12a67",
+                "id": 2,
+                "disabled_reason": null
+            },
+            "vcpus": 1,
+            "vcpus_used": 0
+        }
+    ]
+}`
+
+// HypervisorListBody represents a raw hypervisor list result with Pike+ release.
+const HypervisorListBody = `
+{
+    "hypervisors": [
+        {
+            "cpu_info": {
+                "arch": "x86_64",
+                "model": "Nehalem",
+                "vendor": "Intel",
+                "features": [
+                    "pge",
+                    "clflush"
+                ],
+                "topology": {
+                    "cores": 1,
+                    "threads": 1,
+                    "sockets": 4
+                }
+            },
+            "current_workload": 0,
+            "status": "enabled",
+            "state": "up",
+            "disk_available_least": 0,
+            "host_ip": "1.1.1.1",
+            "free_disk_gb": 1028,
+            "free_ram_mb": 7680,
+            "hypervisor_hostname": "fake-mini",
+            "hypervisor_type": "fake",
+            "hypervisor_version": 2002000,
+            "id": "c48f6247-abe4-4a24-824e-ea39e108874f",
+            "local_gb": 1028,
+            "local_gb_used": 0,
+            "memory_mb": 8192,
+            "memory_mb_used": 512,
+            "running_vms": 0,
+            "service": {
+                "host": "e6a37ee802d74863ab8b91ade8f12a67",
+                "id": "9c2566e7-7a54-4777-a1ae-c2662f0c407c",
+                "disabled_reason": null
+            },
+            "vcpus": 1,
+            "vcpus_used": 0
+        },
+        {
+            "cpu_info": "{\"arch\": \"x86_64\", \"model\": \"Nehalem\", \"vendor\": \"Intel\", \"features\": [\"pge\", \"clflush\"], \"topology\": {\"cores\": 1, \"threads\": 1, \"sockets\": 4}}",
+            "current_workload": 0,
+            "status": "enabled",
+            "state": "up",
+            "disk_available_least": 0,
+            "host_ip": "1.1.1.1",
+            "free_disk_gb": 1028,
+            "free_ram_mb": 7680,
+            "hypervisor_hostname": "fake-mini",
+            "hypervisor_type": "fake",
+            "hypervisor_version": 2.002e+06,
+            "id": "c48f6247-abe4-4a24-824e-ea39e108874f",
+            "local_gb": 1028,
+            "local_gb_used": 0,
+            "memory_mb": 8192,
+            "memory_mb_used": 512,
+            "running_vms": 0,
+            "service": {
+                "host": "e6a37ee802d74863ab8b91ade8f12a67",
+                "id": "9c2566e7-7a54-4777-a1ae-c2662f0c407c",
+                "disabled_reason": null
+            },
+            "vcpus": 1,
+            "vcpus_used": 0
+        }
+    ]
+}`
+
+const HypervisorsStatisticsBody = `
+{
+    "hypervisor_statistics": {
+        "count": 1,
+        "current_workload": 0,
+        "disk_available_least": 0,
+        "free_disk_gb": 1028,
+        "free_ram_mb": 7680,
+        "local_gb": 1028,
+        "local_gb_used": 0,
+        "memory_mb": 8192,
+        "memory_mb_used": 512,
+        "running_vms": 0,
+        "vcpus": 2,
+        "vcpus_used": 0
+    }
+}
+`
+
+// HypervisorGetBody represents a raw hypervisor GET result with Pike+ release.
+const HypervisorGetBody = `
+{
+    "hypervisor":{
+        "cpu_info":{
+            "arch":"x86_64",
+            "model":"Nehalem",
+            "vendor":"Intel",
+            "features":[
+                "pge",
+                "clflush"
+            ],
+            "topology":{
+                "cores":1,
+                "threads":1,
+                "sockets":4
+            }
+        },
+        "current_workload":0,
+        "status":"enabled",
+        "state":"up",
+        "disk_available_least":0,
+        "host_ip":"1.1.1.1",
+        "free_disk_gb":1028,
+        "free_ram_mb":7680,
+        "hypervisor_hostname":"fake-mini",
+        "hypervisor_type":"fake",
+        "hypervisor_version":2002000,
+        "id":"c48f6247-abe4-4a24-824e-ea39e108874f",
+        "local_gb":1028,
+        "local_gb_used":0,
+        "memory_mb":8192,
+        "memory_mb_used":512,
+        "running_vms":0,
+        "service":{
+            "host":"e6a37ee802d74863ab8b91ade8f12a67",
+            "id":"9c2566e7-7a54-4777-a1ae-c2662f0c407c",
+            "disabled_reason":null
+        },
+        "vcpus":1,
+        "vcpus_used":0
+    }
+}
+`
+
+// HypervisorGetEmptyCPUInfoBody represents a raw hypervisor GET result with
+// no cpu_info
+const HypervisorGetEmptyCPUInfoBody = `
+{
+    "hypervisor":{
+        "cpu_info": "",
+        "current_workload":0,
+        "status":"enabled",
+        "state":"up",
+        "disk_available_least":0,
+        "host_ip":"1.1.1.1",
+        "free_disk_gb":1028,
+        "free_ram_mb":7680,
+        "hypervisor_hostname":"fake-mini",
+        "hypervisor_type":"fake",
+        "hypervisor_version":2002000,
+        "id":"c48f6247-abe4-4a24-824e-ea39e108874f",
+        "local_gb":1028,
+        "local_gb_used":0,
+        "memory_mb":8192,
+        "memory_mb_used":512,
+        "running_vms":0,
+        "service":{
+            "host":"e6a37ee802d74863ab8b91ade8f12a67",
+            "id":"9c2566e7-7a54-4777-a1ae-c2662f0c407c",
+            "disabled_reason":null
+        },
+        "vcpus":1,
+        "vcpus_used":0
+    }
+}
+`
+
+// HypervisorUptimeBody represents a raw hypervisor uptime request result with
+// Pike+ release.
+const HypervisorUptimeBody = `
+{
+    "hypervisor": {
+        "hypervisor_hostname": "fake-mini",
+        "id": "c48f6247-abe4-4a24-824e-ea39e108874f",
+        "state": "up",
+        "status": "enabled",
+        "uptime": " 08:32:11 up 93 days, 18:25, 12 users,  load average: 0.20, 0.12, 0.14"
+    }
+}
+`
+
+var (
+	HypervisorFakePre253 = hypervisors.Hypervisor{
+		CPUInfo: hypervisors.CPUInfo{
+			Arch:   "x86_64",
+			Model:  "Nehalem",
+			Vendor: "Intel",
+			Features: []string{
+				"pge",
+				"clflush",
+			},
+			Topology: hypervisors.Topology{
+				Cores:   1,
+				Threads: 1,
+				Sockets: 4,
+			},
+		},
+		CurrentWorkload:    0,
+		Status:             "enabled",
+		State:              "up",
+		DiskAvailableLeast: 0,
+		HostIP:             "1.1.1.1",
+		FreeDiskGB:         1028,
+		FreeRamMB:          7680,
+		HypervisorHostname: "fake-mini",
+		HypervisorType:     "fake",
+		HypervisorVersion:  2002000,
+		ID:                 "1",
+		LocalGB:            1028,
+		LocalGBUsed:        0,
+		MemoryMB:           8192,
+		MemoryMBUsed:       512,
+		RunningVMs:         0,
+		Service: hypervisors.Service{
+			Host:           "e6a37ee802d74863ab8b91ade8f12a67",
+			ID:             "2",
+			DisabledReason: "",
+		},
+		VCPUs:     1,
+		VCPUsUsed: 0,
+	}
+
+	HypervisorFake = hypervisors.Hypervisor{
+		CPUInfo: hypervisors.CPUInfo{
+			Arch:   "x86_64",
+			Model:  "Nehalem",
+			Vendor: "Intel",
+			Features: []string{
+				"pge",
+				"clflush",
+			},
+			Topology: hypervisors.Topology{
+				Cores:   1,
+				Threads: 1,
+				Sockets: 4,
+			},
+		},
+		CurrentWorkload:    0,
+		Status:             "enabled",
+		State:              "up",
+		DiskAvailableLeast: 0,
+		HostIP:             "1.1.1.1",
+		FreeDiskGB:         1028,
+		FreeRamMB:          7680,
+		HypervisorHostname: "fake-mini",
+		HypervisorType:     "fake",
+		HypervisorVersion:  2002000,
+		ID:                 "c48f6247-abe4-4a24-824e-ea39e108874f",
+		LocalGB:            1028,
+		LocalGBUsed:        0,
+		MemoryMB:           8192,
+		MemoryMBUsed:       512,
+		RunningVMs:         0,
+		Service: hypervisors.Service{
+			Host:           "e6a37ee802d74863ab8b91ade8f12a67",
+			ID:             "9c2566e7-7a54-4777-a1ae-c2662f0c407c",
+			DisabledReason: "",
+		},
+		VCPUs:     1,
+		VCPUsUsed: 0,
+	}
+
+	HypervisorEmptyCPUInfo = hypervisors.Hypervisor{
+		CurrentWorkload:    0,
+		Status:             "enabled",
+		State:              "up",
+		DiskAvailableLeast: 0,
+		HostIP:             "1.1.1.1",
+		FreeDiskGB:         1028,
+		FreeRamMB:          7680,
+		HypervisorHostname: "fake-mini",
+		HypervisorType:     "fake",
+		HypervisorVersion:  2002000,
+		ID:                 "c48f6247-abe4-4a24-824e-ea39e108874f",
+		LocalGB:            1028,
+		LocalGBUsed:        0,
+		MemoryMB:           8192,
+		MemoryMBUsed:       512,
+		RunningVMs:         0,
+		Service: hypervisors.Service{
+			Host:           "e6a37ee802d74863ab8b91ade8f12a67",
+			ID:             "9c2566e7-7a54-4777-a1ae-c2662f0c407c",
+			DisabledReason: "",
+		},
+		VCPUs:     1,
+		VCPUsUsed: 0,
+	}
+
+	HypervisorsStatisticsExpected = hypervisors.Statistics{
+		Count:              1,
+		CurrentWorkload:    0,
+		DiskAvailableLeast: 0,
+		FreeDiskGB:         1028,
+		FreeRamMB:          7680,
+		LocalGB:            1028,
+		LocalGBUsed:        0,
+		MemoryMB:           8192,
+		MemoryMBUsed:       512,
+		RunningVMs:         0,
+		VCPUs:              2,
+		VCPUsUsed:          0,
+	}
+
+	HypervisorUptimeExpected = hypervisors.Uptime{
+		HypervisorHostname: "fake-mini",
+		ID:                 "c48f6247-abe4-4a24-824e-ea39e108874f",
+		State:              "up",
+		Status:             "enabled",
+		Uptime:             " 08:32:11 up 93 days, 18:25, 12 users,  load average: 0.20, 0.12, 0.14",
+	}
+)
+
+func HandleHypervisorsStatisticsSuccessfully(t *testing.T) {
+	testhelper.Mux.HandleFunc("/os-hypervisors/statistics", func(w http.ResponseWriter, r *http.Request) {
+		testhelper.TestMethod(t, r, "GET")
+		testhelper.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, HypervisorsStatisticsBody)
+	})
+}
+
+func HandleHypervisorListPre253Successfully(t *testing.T) {
+	testhelper.Mux.HandleFunc("/os-hypervisors/detail", func(w http.ResponseWriter, r *http.Request) {
+		testhelper.TestMethod(t, r, "GET")
+		testhelper.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, HypervisorListBodyPre253)
+	})
+}
+
+func HandleHypervisorListSuccessfully(t *testing.T) {
+	testhelper.Mux.HandleFunc("/os-hypervisors/detail", func(w http.ResponseWriter, r *http.Request) {
+		testhelper.TestMethod(t, r, "GET")
+		testhelper.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, HypervisorListBody)
+	})
+}
+
+func HandleHypervisorGetSuccessfully(t *testing.T) {
+	testhelper.Mux.HandleFunc("/os-hypervisors/"+HypervisorFake.ID, func(w http.ResponseWriter, r *http.Request) {
+		testhelper.TestMethod(t, r, "GET")
+		testhelper.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, HypervisorGetBody)
+	})
+}
+
+func HandleHypervisorGetEmptyCPUInfoSuccessfully(t *testing.T) {
+	testhelper.Mux.HandleFunc("/os-hypervisors/"+HypervisorFake.ID, func(w http.ResponseWriter, r *http.Request) {
+		testhelper.TestMethod(t, r, "GET")
+		testhelper.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, HypervisorGetEmptyCPUInfoBody)
+	})
+}
+
+func HandleHypervisorUptimeSuccessfully(t *testing.T) {
+	testhelper.Mux.HandleFunc("/os-hypervisors/"+HypervisorFake.ID+"/uptime", func(w http.ResponseWriter, r *http.Request) {
+		testhelper.TestMethod(t, r, "GET")
+		testhelper.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, HypervisorUptimeBody)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/testing/requests_test.go
new file mode 100644
index 000000000..21428d60a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/testing/requests_test.go
@@ -0,0 +1,144 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors"
+	"github.com/gophercloud/gophercloud/pagination"
+	"github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestListHypervisorsPre253(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleHypervisorListPre253Successfully(t)
+
+	pages := 0
+	err := hypervisors.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		pages++
+
+		actual, err := hypervisors.ExtractHypervisors(page)
+		if err != nil {
+			return false, err
+		}
+
+		if len(actual) != 2 {
+			t.Fatalf("Expected 2 hypervisors, got %d", len(actual))
+		}
+		testhelper.CheckDeepEquals(t, HypervisorFakePre253, actual[0])
+		testhelper.CheckDeepEquals(t, HypervisorFakePre253, actual[1])
+
+		return true, nil
+	})
+
+	testhelper.AssertNoErr(t, err)
+
+	if pages != 1 {
+		t.Errorf("Expected 1 page, saw %d", pages)
+	}
+}
+
+func TestListAllHypervisorsPre253(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleHypervisorListPre253Successfully(t)
+
+	allPages, err := hypervisors.List(client.ServiceClient()).AllPages()
+	testhelper.AssertNoErr(t, err)
+	actual, err := hypervisors.ExtractHypervisors(allPages)
+	testhelper.AssertNoErr(t, err)
+	testhelper.CheckDeepEquals(t, HypervisorFakePre253, actual[0])
+	testhelper.CheckDeepEquals(t, HypervisorFakePre253, actual[1])
+}
+
+func TestListHypervisors(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleHypervisorListSuccessfully(t)
+
+	pages := 0
+	err := hypervisors.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		pages++
+
+		actual, err := hypervisors.ExtractHypervisors(page)
+		if err != nil {
+			return false, err
+		}
+
+		if len(actual) != 2 {
+			t.Fatalf("Expected 2 hypervisors, got %d", len(actual))
+		}
+		testhelper.CheckDeepEquals(t, HypervisorFake, actual[0])
+		testhelper.CheckDeepEquals(t, HypervisorFake, actual[1])
+
+		return true, nil
+	})
+
+	testhelper.AssertNoErr(t, err)
+
+	if pages != 1 {
+		t.Errorf("Expected 1 page, saw %d", pages)
+	}
+}
+
+func TestListAllHypervisors(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleHypervisorListSuccessfully(t)
+
+	allPages, err := hypervisors.List(client.ServiceClient()).AllPages()
+	testhelper.AssertNoErr(t, err)
+	actual, err := hypervisors.ExtractHypervisors(allPages)
+	testhelper.AssertNoErr(t, err)
+	testhelper.CheckDeepEquals(t, HypervisorFake, actual[0])
+	testhelper.CheckDeepEquals(t, HypervisorFake, actual[1])
+}
+
+func TestHypervisorsStatistics(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleHypervisorsStatisticsSuccessfully(t)
+
+	expected := HypervisorsStatisticsExpected
+
+	actual, err := hypervisors.GetStatistics(client.ServiceClient()).Extract()
+	testhelper.AssertNoErr(t, err)
+	testhelper.CheckDeepEquals(t, &expected, actual)
+}
+
+func TestGetHypervisor(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleHypervisorGetSuccessfully(t)
+
+	expected := HypervisorFake
+
+	actual, err := hypervisors.Get(client.ServiceClient(), expected.ID).Extract()
+	testhelper.AssertNoErr(t, err)
+	testhelper.CheckDeepEquals(t, &expected, actual)
+}
+
+func TestGetHypervisorEmptyCPUInfo(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleHypervisorGetEmptyCPUInfoSuccessfully(t)
+
+	expected := HypervisorEmptyCPUInfo
+
+	actual, err := hypervisors.Get(client.ServiceClient(), expected.ID).Extract()
+	testhelper.AssertNoErr(t, err)
+	testhelper.CheckDeepEquals(t, &expected, actual)
+}
+
+func TestHypervisorsUptime(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleHypervisorUptimeSuccessfully(t)
+
+	expected := HypervisorUptimeExpected
+
+	actual, err := hypervisors.GetUptime(client.ServiceClient(), HypervisorFake.ID).Extract()
+	testhelper.AssertNoErr(t, err)
+	testhelper.CheckDeepEquals(t, &expected, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/urls.go
new file mode 100644
index 000000000..4c18ed43c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors/urls.go
@@ -0,0 +1,19 @@
+package hypervisors
+
+import "github.com/gophercloud/gophercloud"
+
+func hypervisorsListDetailURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL("os-hypervisors", "detail")
+}
+
+func hypervisorsStatisticsURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL("os-hypervisors", "statistics")
+}
+
+func hypervisorsGetURL(c *gophercloud.ServiceClient, hypervisorID string) string {
+	return c.ServiceURL("os-hypervisors", hypervisorID)
+}
+
+func hypervisorsUptimeURL(c *gophercloud.ServiceClient, hypervisorID string) string {
+	return c.ServiceURL("os-hypervisors", hypervisorID, "uptime")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/doc.go
new file mode 100644
index 000000000..8e75d5070
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/doc.go
@@ -0,0 +1,26 @@
+package instanceactions
+
+/*
+Package instanceactions provides the ability to list or get a server instance-action.
+
+Example to List and Get actions:
+
+	pages, err := instanceactions.List(client, "server-id", nil).AllPages()
+	if err != nil {
+		panic("fail to get actions pages")
+	}
+
+	actions, err := instanceactions.ExtractInstanceActions(pages)
+	if err != nil {
+		panic("fail to list instance actions")
+	}
+
+	for _, action := range actions {
+		action, err = instanceactions.Get(client, "server-id", action.RequestID).Extract()
+		if err != nil {
+			panic("fail to get instance action")
+		}
+
+		fmt.Println(action)
+	}
+*/
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/request.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/request.go
new file mode 100644
index 000000000..326081dfd
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/request.go
@@ -0,0 +1,79 @@
+package instanceactions
+
+import (
+	"net/url"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// ListOptsBuilder allows extensions to add additional parameters to the
+// List request.
+type ListOptsBuilder interface {
+	ToInstanceActionsListQuery() (string, error)
+}
+
+// ListOpts represents options used to filter instance action results
+// in a List request.
+type ListOpts struct {
+	// Limit is an integer value to limit the results to return.
+	// This requires microversion 2.58 or later.
+	Limit int `q:"limit"`
+
+	// Marker is the request ID of the last-seen instance action.
+	// This requires microversion 2.58 or later.
+	Marker string `q:"marker"`
+
+	// ChangesSince filters the response by actions after the given time.
+	// This requires microversion 2.58 or later.
+	ChangesSince *time.Time `q:"changes-since"`
+
+	// ChangesBefore filters the response by actions before the given time.
+	// This requires microversion 2.66 or later.
+	ChangesBefore *time.Time `q:"changes-before"`
+}
+
+// ToInstanceActionsListQuery formats a ListOpts into a query string.
+func (opts ListOpts) ToInstanceActionsListQuery() (string, error) {
+	q, err := gophercloud.BuildQueryString(opts)
+	if err != nil {
+		return "", err
+	}
+
+	params := q.Query()
+
+	if opts.ChangesSince != nil {
+		params.Add("changes-since", opts.ChangesSince.Format(time.RFC3339))
+	}
+
+	if opts.ChangesBefore != nil {
+		params.Add("changes-before", opts.ChangesBefore.Format(time.RFC3339))
+	}
+
+	q = &url.URL{RawQuery: params.Encode()}
+	return q.String(), nil
+}
+
+// List makes a request against the API to list the servers actions.
+func List(client *gophercloud.ServiceClient, id string, opts ListOptsBuilder) pagination.Pager {
+	url := listURL(client, id)
+	if opts != nil {
+		query, err := opts.ToInstanceActionsListQuery()
+		if err != nil {
+			return pagination.Pager{Err: err}
+		}
+		url += query
+	}
+	return pagination.NewPager(client, url, func(r pagination.PageResult) pagination.Page {
+		return InstanceActionPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// Get makes a request against the API to get a server action.
+func Get(client *gophercloud.ServiceClient, serverID, requestID string) (r InstanceActionResult) {
+	_, r.Err = client.Get(instanceActionsURL(client, serverID, requestID), &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/results.go
new file mode 100644
index 000000000..90892a29a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/results.go
@@ -0,0 +1,190 @@
+package instanceactions
+
+import (
+	"encoding/json"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// InstanceAction represents an instance action.
+type InstanceAction struct {
+	// Action is the name of the action.
+	Action string `json:"action"`
+
+	// InstanceUUID is the UUID of the instance.
+	InstanceUUID string `json:"instance_uuid"`
+
+	// Message is the related error message for when an action fails.
+	Message string `json:"message"`
+
+	// Project ID is the ID of the project which initiated the action.
+	ProjectID string `json:"project_id"`
+
+	// RequestID is the ID generated when performing the action.
+	RequestID string `json:"request_id"`
+
+	// StartTime is the time the action started.
+	StartTime time.Time `json:"-"`
+
+	// UserID is the ID of the user which initiated the action.
+	UserID string `json:"user_id"`
+}
+
+// UnmarshalJSON converts our JSON API response into our instance action struct
+func (i *InstanceAction) UnmarshalJSON(b []byte) error {
+	type tmp InstanceAction
+	var s struct {
+		tmp
+		StartTime gophercloud.JSONRFC3339MilliNoZ `json:"start_time"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+	*i = InstanceAction(s.tmp)
+
+	i.StartTime = time.Time(s.StartTime)
+
+	return err
+}
+
+// InstanceActionPage abstracts the raw results of making a List() request
+// against the API. As OpenStack extensions may freely alter the response bodies
+// of structures returned to the client, you may only safely access the data
+// provided through the ExtractInstanceActions call.
+type InstanceActionPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty returns true if an InstanceActionPage contains no instance actions.
+func (r InstanceActionPage) IsEmpty() (bool, error) {
+	instanceactions, err := ExtractInstanceActions(r)
+	return len(instanceactions) == 0, err
+}
+
+// ExtractInstanceActions interprets a page of results as a slice
+// of InstanceAction.
+func ExtractInstanceActions(r pagination.Page) ([]InstanceAction, error) {
+	var resp []InstanceAction
+	err := ExtractInstanceActionsInto(r, &resp)
+	return resp, err
+}
+
+// Event represents an event of instance action.
+type Event struct {
+	// Event is the name of the event.
+	Event string `json:"event"`
+
+	// Host is the host of the event.
+	// This requires microversion 2.62 or later.
+	Host *string `json:"host"`
+
+	// HostID is the host id of the event.
+	// This requires microversion 2.62 or later.
+	HostID *string `json:"hostId"`
+
+	// Result is the result of the event.
+	Result string `json:"result"`
+
+	// Traceback is the traceback stack if an error occurred.
+	Traceback string `json:"traceback"`
+
+	// StartTime is the time the action started.
+	StartTime time.Time `json:"-"`
+
+	// FinishTime is the time the event finished.
+	FinishTime time.Time `json:"-"`
+}
+
+// UnmarshalJSON converts our JSON API response into our instance action struct.
+func (e *Event) UnmarshalJSON(b []byte) error {
+	type tmp Event
+	var s struct {
+		tmp
+		StartTime  gophercloud.JSONRFC3339MilliNoZ `json:"start_time"`
+		FinishTime gophercloud.JSONRFC3339MilliNoZ `json:"finish_time"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+	*e = Event(s.tmp)
+
+	e.StartTime = time.Time(s.StartTime)
+	e.FinishTime = time.Time(s.FinishTime)
+
+	return err
+}
+
+// InstanceActionDetail represents the details of an Action.
+type InstanceActionDetail struct {
+	// Action is the name of the Action.
+	Action string `json:"action"`
+
+	// InstanceUUID is the UUID of the instance.
+	InstanceUUID string `json:"instance_uuid"`
+
+	// Message is the related error message for when an action fails.
+	Message string `json:"message"`
+
+	// Project ID is the ID of the project which initiated the action.
+	ProjectID string `json:"project_id"`
+
+	// RequestID is the ID generated when performing the action.
+	RequestID string `json:"request_id"`
+
+	// UserID is the ID of the user which initiated the action.
+	UserID string `json:"user_id"`
+
+	// Events is the list of events of the action.
+	// This requires microversion 2.50 or later.
+	Events *[]Event `json:"events"`
+
+	// UpdatedAt last update date of the action.
+	// This requires microversion 2.58 or later.
+	UpdatedAt *time.Time `json:"-"`
+
+	// StartTime is the time the action started.
+	StartTime time.Time `json:"-"`
+}
+
+// UnmarshalJSON converts our JSON API response into our instance action struct
+func (i *InstanceActionDetail) UnmarshalJSON(b []byte) error {
+	type tmp InstanceActionDetail
+	var s struct {
+		tmp
+		UpdatedAt *gophercloud.JSONRFC3339MilliNoZ `json:"updated_at"`
+		StartTime gophercloud.JSONRFC3339MilliNoZ  `json:"start_time"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+	*i = InstanceActionDetail(s.tmp)
+
+	i.UpdatedAt = (*time.Time)(s.UpdatedAt)
+	i.StartTime = time.Time(s.StartTime)
+	return err
+}
+
+// InstanceActionResult is the result handler of Get.
+type InstanceActionResult struct {
+	gophercloud.Result
+}
+
+// Extract interprets a result as an InstanceActionDetail.
+func (r InstanceActionResult) Extract() (InstanceActionDetail, error) {
+	var s InstanceActionDetail
+	err := r.ExtractInto(&s)
+	return s, err
+}
+
+func (r InstanceActionResult) ExtractInto(v interface{}) error {
+	return r.Result.ExtractIntoStructPtr(v, "instanceAction")
+}
+
+func ExtractInstanceActionsInto(r pagination.Page, v interface{}) error {
+	return r.(InstanceActionPage).Result.ExtractIntoSlicePtr(v, "instanceActions")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/doc.go
new file mode 100644
index 000000000..011355b12
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/doc.go
@@ -0,0 +1,2 @@
+// instanceactions unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/fixtures.go
new file mode 100644
index 000000000..ced79e74a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/fixtures.go
@@ -0,0 +1,128 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+	"time"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ListExpected represents an expected repsonse from a List request.
+var ListExpected = []instanceactions.InstanceAction{
+	{
+		Action:       "stop",
+		InstanceUUID: "fcd19ef2-b593-40b1-90a5-fc31063fa95c",
+		Message:      "",
+		ProjectID:    "6f70656e737461636b20342065766572",
+		RequestID:    "req-f8a59f03-76dc-412f-92c2-21f8612be728",
+		StartTime:    time.Date(2018, 04, 25, 1, 26, 29, 000000, time.UTC),
+		UserID:       "admin",
+	},
+	{
+		Action:       "create",
+		InstanceUUID: "fcd19ef2-b593-40b1-90a5-fc31063fa95c",
+		Message:      "test",
+		ProjectID:    "6f70656e737461636b20342065766572",
+		RequestID:    "req-50189019-626d-47fb-b944-b8342af09679",
+		StartTime:    time.Date(2018, 04, 25, 1, 26, 25, 000000, time.UTC),
+		UserID:       "admin",
+	},
+}
+
+// HandleInstanceActionListSuccessfully sets up the test server to respond to a ListAddresses request.
+func HandleInstanceActionListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/asdfasdfasdf/os-instance-actions", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, `{
+			"instanceActions": [
+				{
+					"action": "stop",
+					"instance_uuid": "fcd19ef2-b593-40b1-90a5-fc31063fa95c",
+					"message": null,
+					"project_id": "6f70656e737461636b20342065766572",
+					"request_id": "req-f8a59f03-76dc-412f-92c2-21f8612be728",
+					"start_time": "2018-04-25T01:26:29.000000",
+					"user_id": "admin"
+				},
+				{
+					"action": "create",
+					"instance_uuid": "fcd19ef2-b593-40b1-90a5-fc31063fa95c",
+					"message": "test",
+					"project_id": "6f70656e737461636b20342065766572",
+					"request_id": "req-50189019-626d-47fb-b944-b8342af09679",
+					"start_time": "2018-04-25T01:26:25.000000",
+					"user_id": "admin"
+				}
+			]
+		}`)
+	})
+}
+
+var (
+	expectedUpdateAt    = time.Date(2018, 04, 25, 1, 26, 36, 0, time.UTC)
+	expectedEventHost   = "compute"
+	expectedEventHostID = "2091634baaccdc4c5a1d57069c833e402921df696b7f970791b12ec6"
+	expectedEvents      = []instanceactions.Event{{
+		Event:      "compute_stop_instance",
+		Host:       &expectedEventHost,
+		HostID:     &expectedEventHostID,
+		Result:     "Success",
+		StartTime:  time.Date(2018, 04, 25, 1, 26, 36, 0, time.UTC),
+		FinishTime: time.Date(2018, 04, 25, 1, 26, 36, 0, time.UTC),
+		Traceback:  "",
+	}}
+)
+
+// GetExpected represents an expected repsonse from a Get request.
+var GetExpected = instanceactions.InstanceActionDetail{
+	Action:       "stop",
+	InstanceUUID: "4bf3473b-d550-4b65-9409-292d44ab14a2",
+	Message:      "",
+	ProjectID:    "6f70656e737461636b20342065766572",
+	RequestID:    "req-0d819d5c-1527-4669-bdf0-ffad31b5105b",
+	StartTime:    time.Date(2018, 04, 25, 1, 26, 36, 0, time.UTC),
+	UpdatedAt:    &expectedUpdateAt,
+	UserID:       "admin",
+	Events:       &expectedEvents,
+}
+
+// HandleInstanceActionGetSuccessfully sets up the test server to respond to a Get request.
+func HandleInstanceActionGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/asdfasdfasdf/os-instance-actions/okzeorkmkfs", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, `{
+			"instanceAction": 
+			{
+				"action": "stop",
+				"events": [
+					{
+						"event": "compute_stop_instance",
+						"finish_time": "2018-04-25T01:26:36.00000",
+						"host": "compute",
+						"hostId": "2091634baaccdc4c5a1d57069c833e402921df696b7f970791b12ec6",
+						"result": "Success",
+						"start_time": "2018-04-25T01:26:36.00000",
+						"traceback": null
+					}
+				],
+				"instance_uuid": "4bf3473b-d550-4b65-9409-292d44ab14a2",
+				"message": null,
+				"project_id": "6f70656e737461636b20342065766572",
+				"request_id": "req-0d819d5c-1527-4669-bdf0-ffad31b5105b",
+				"start_time": "2018-04-25T01:26:36.00000",
+				"updated_at": "2018-04-25T01:26:36.00000",
+				"user_id": "admin"
+			}
+		}`)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/request_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/request_test.go
new file mode 100644
index 000000000..77b7e6941
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/testing/request_test.go
@@ -0,0 +1,48 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleInstanceActionListSuccessfully(t)
+
+	expected := ListExpected
+	pages := 0
+	err := instanceactions.List(client.ServiceClient(), "asdfasdfasdf", nil).EachPage(func(page pagination.Page) (bool, error) {
+		pages++
+
+		actual, err := instanceactions.ExtractInstanceActions(page)
+		th.AssertNoErr(t, err)
+
+		if len(actual) != 2 {
+			t.Fatalf("Expected 2 instance actions, got %d", len(actual))
+		}
+		th.CheckDeepEquals(t, expected, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.CheckEquals(t, 1, pages)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleInstanceActionGetSuccessfully(t)
+
+	client := client.ServiceClient()
+	actual, err := instanceactions.Get(client, "asdfasdfasdf", "okzeorkmkfs").Extract()
+	if err != nil {
+		t.Fatalf("Unexpected Get error: %v", err)
+	}
+
+	th.CheckDeepEquals(t, GetExpected, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/urls.go
new file mode 100644
index 000000000..4239ade7f
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/instanceactions/urls.go
@@ -0,0 +1,11 @@
+package instanceactions
+
+import "github.com/gophercloud/gophercloud"
+
+func listURL(client *gophercloud.ServiceClient, id string) string {
+	return client.ServiceURL("servers", id, "os-instance-actions")
+}
+
+func instanceActionsURL(client *gophercloud.ServiceClient, serverID, requestID string) string {
+	return client.ServiceURL("servers", serverID, "os-instance-actions", requestID)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/doc.go
new file mode 100644
index 000000000..24c460772
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/doc.go
@@ -0,0 +1,71 @@
+/*
+Package keypairs provides the ability to manage key pairs as well as create
+servers with a specified key pair.
+
+Example to List Key Pairs
+
+	allPages, err := keypairs.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allKeyPairs, err := keypairs.ExtractKeyPairs(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, kp := range allKeyPairs {
+		fmt.Printf("%+v\n", kp)
+	}
+
+Example to Create a Key Pair
+
+	createOpts := keypairs.CreateOpts{
+		Name: "keypair-name",
+	}
+
+	keypair, err := keypairs.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v", keypair)
+
+Example to Import a Key Pair
+
+	createOpts := keypairs.CreateOpts{
+		Name:      "keypair-name",
+		PublicKey: "public-key",
+	}
+
+	keypair, err := keypairs.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Delete a Key Pair
+
+	err := keypairs.Delete(computeClient, "keypair-name").ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Create a Server With a Key Pair
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_name",
+		ImageRef:  "image-uuid",
+		FlavorRef: "flavor-uuid",
+	}
+
+	createOpts := keypairs.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		KeyName:           "keypair-name",
+	}
+
+	server, err := servers.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+*/
+package keypairs
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/requests.go
new file mode 100644
index 000000000..b72807770
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/requests.go
@@ -0,0 +1,86 @@
+package keypairs
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// CreateOptsExt adds a KeyPair option to the base CreateOpts.
+type CreateOptsExt struct {
+	servers.CreateOptsBuilder
+
+	// KeyName is the name of the key pair.
+	KeyName string `json:"key_name,omitempty"`
+}
+
+// ToServerCreateMap adds the key_name to the base server creation options.
+func (opts CreateOptsExt) ToServerCreateMap() (map[string]interface{}, error) {
+	base, err := opts.CreateOptsBuilder.ToServerCreateMap()
+	if err != nil {
+		return nil, err
+	}
+
+	if opts.KeyName == "" {
+		return base, nil
+	}
+
+	serverMap := base["server"].(map[string]interface{})
+	serverMap["key_name"] = opts.KeyName
+
+	return base, nil
+}
+
+// List returns a Pager that allows you to iterate over a collection of KeyPairs.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, listURL(client), func(r pagination.PageResult) pagination.Page {
+		return KeyPairPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// CreateOptsBuilder allows extensions to add additional parameters to the
+// Create request.
+type CreateOptsBuilder interface {
+	ToKeyPairCreateMap() (map[string]interface{}, error)
+}
+
+// CreateOpts specifies KeyPair creation or import parameters.
+type CreateOpts struct {
+	// Name is a friendly name to refer to this KeyPair in other services.
+	Name string `json:"name" required:"true"`
+
+	// PublicKey [optional] is a pregenerated OpenSSH-formatted public key.
+	// If provided, this key will be imported and no new key will be created.
+	PublicKey string `json:"public_key,omitempty"`
+}
+
+// ToKeyPairCreateMap constructs a request body from CreateOpts.
+func (opts CreateOpts) ToKeyPairCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "keypair")
+}
+
+// Create requests the creation of a new KeyPair on the server, or to import a
+// pre-existing keypair.
+func Create(client *gophercloud.ServiceClient, opts CreateOptsBuilder) (r CreateResult) {
+	b, err := opts.ToKeyPairCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(createURL(client), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200, 201},
+	})
+	return
+}
+
+// Get returns public data about a previously uploaded KeyPair.
+func Get(client *gophercloud.ServiceClient, name string) (r GetResult) {
+	_, r.Err = client.Get(getURL(client, name), &r.Body, nil)
+	return
+}
+
+// Delete requests the deletion of a previous stored KeyPair from the server.
+func Delete(client *gophercloud.ServiceClient, name string) (r DeleteResult) {
+	_, r.Err = client.Delete(deleteURL(client, name), nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/results.go
new file mode 100644
index 000000000..2d71034b1
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/results.go
@@ -0,0 +1,91 @@
+package keypairs
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// KeyPair is an SSH key known to the OpenStack Cloud that is available to be
+// injected into servers.
+type KeyPair struct {
+	// Name is used to refer to this keypair from other services within this
+	// region.
+	Name string `json:"name"`
+
+	// Fingerprint is a short sequence of bytes that can be used to authenticate
+	// or validate a longer public key.
+	Fingerprint string `json:"fingerprint"`
+
+	// PublicKey is the public key from this pair, in OpenSSH format.
+	// "ssh-rsa AAAAB3Nz..."
+	PublicKey string `json:"public_key"`
+
+	// PrivateKey is the private key from this pair, in PEM format.
+	// "-----BEGIN RSA PRIVATE KEY-----\nMIICXA..."
+	// It is only present if this KeyPair was just returned from a Create call.
+	PrivateKey string `json:"private_key"`
+
+	// UserID is the user who owns this KeyPair.
+	UserID string `json:"user_id"`
+}
+
+// KeyPairPage stores a single page of all KeyPair results from a List call.
+// Use the ExtractKeyPairs function to convert the results to a slice of
+// KeyPairs.
+type KeyPairPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a KeyPairPage is empty.
+func (page KeyPairPage) IsEmpty() (bool, error) {
+	ks, err := ExtractKeyPairs(page)
+	return len(ks) == 0, err
+}
+
+// ExtractKeyPairs interprets a page of results as a slice of KeyPairs.
+func ExtractKeyPairs(r pagination.Page) ([]KeyPair, error) {
+	type pair struct {
+		KeyPair KeyPair `json:"keypair"`
+	}
+	var s struct {
+		KeyPairs []pair `json:"keypairs"`
+	}
+	err := (r.(KeyPairPage)).ExtractInto(&s)
+	results := make([]KeyPair, len(s.KeyPairs))
+	for i, pair := range s.KeyPairs {
+		results[i] = pair.KeyPair
+	}
+	return results, err
+}
+
+type keyPairResult struct {
+	gophercloud.Result
+}
+
+// Extract is a method that attempts to interpret any KeyPair resource response
+// as a KeyPair struct.
+func (r keyPairResult) Extract() (*KeyPair, error) {
+	var s struct {
+		KeyPair *KeyPair `json:"keypair"`
+	}
+	err := r.ExtractInto(&s)
+	return s.KeyPair, err
+}
+
+// CreateResult is the response from a Create operation. Call its Extract method
+// to interpret it as a KeyPair.
+type CreateResult struct {
+	keyPairResult
+}
+
+// GetResult is the response from a Get operation. Call its Extract method to
+// interpret it as a KeyPair.
+type GetResult struct {
+	keyPairResult
+}
+
+// DeleteResult is the response from a Delete operation. Call its ExtractErr
+// method to determine if the call succeeded or failed.
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/doc.go
new file mode 100644
index 000000000..8d4200983
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/doc.go
@@ -0,0 +1,2 @@
+// keypairs unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/fixtures.go
new file mode 100644
index 000000000..dc716d8db
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/fixtures.go
@@ -0,0 +1,170 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ListOutput is a sample response to a List call.
+const ListOutput = `
+{
+	"keypairs": [
+		{
+			"keypair": {
+				"fingerprint": "15:b0:f8:b3:f9:48:63:71:cf:7b:5b:38:6d:44:2d:4a",
+				"name": "firstkey",
+				"public_key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC+Eo/RZRngaGTkFs7I62ZjsIlO79KklKbMXi8F+KITD4bVQHHn+kV+4gRgkgCRbdoDqoGfpaDFs877DYX9n4z6FrAIZ4PES8TNKhatifpn9NdQYWA+IkU8CuvlEKGuFpKRi/k7JLos/gHi2hy7QUwgtRvcefvD/vgQZOVw/mGR9Q== Generated by Nova\n"
+			}
+		},
+		{
+			"keypair": {
+				"fingerprint": "35:9d:d0:c3:4a:80:d3:d8:86:f1:ca:f7:df:c4:f9:d8",
+				"name": "secondkey",
+				"public_key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC9mC3WZN9UGLxgPBpP7H5jZMc6pKwOoSgre8yun6REFktn/Kz7DUt9jaR1UJyRzHxITfCfAIgSxPdGqB/oF1suMyWgu5i0625vavLB5z5kC8Hq3qZJ9zJO1poE1kyD+htiTtPWJ88e12xuH2XB/CZN9OpEiF98hAagiOE0EnOS5Q== Generated by Nova\n"
+			}
+		}
+	]
+}
+`
+
+// GetOutput is a sample response to a Get call.
+const GetOutput = `
+{
+	"keypair": {
+		"public_key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC+Eo/RZRngaGTkFs7I62ZjsIlO79KklKbMXi8F+KITD4bVQHHn+kV+4gRgkgCRbdoDqoGfpaDFs877DYX9n4z6FrAIZ4PES8TNKhatifpn9NdQYWA+IkU8CuvlEKGuFpKRi/k7JLos/gHi2hy7QUwgtRvcefvD/vgQZOVw/mGR9Q== Generated by Nova\n",
+		"name": "firstkey",
+		"fingerprint": "15:b0:f8:b3:f9:48:63:71:cf:7b:5b:38:6d:44:2d:4a"
+	}
+}
+`
+
+// CreateOutput is a sample response to a Create call.
+const CreateOutput = `
+{
+	"keypair": {
+		"fingerprint": "35:9d:d0:c3:4a:80:d3:d8:86:f1:ca:f7:df:c4:f9:d8",
+		"name": "createdkey",
+		"private_key": "-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQC9mC3WZN9UGLxgPBpP7H5jZMc6pKwOoSgre8yun6REFktn/Kz7\nDUt9jaR1UJyRzHxITfCfAIgSxPdGqB/oF1suMyWgu5i0625vavLB5z5kC8Hq3qZJ\n9zJO1poE1kyD+htiTtPWJ88e12xuH2XB/CZN9OpEiF98hAagiOE0EnOS5QIDAQAB\nAoGAE5XO1mDhORy9COvsg+kYPUhB1GsCYxh+v88wG7HeFDKBY6KUc/Kxo6yoGn5T\nTjRjekyi2KoDZHz4VlIzyZPwFS4I1bf3oCunVoAKzgLdmnTtvRNMC5jFOGc2vUgP\n9bSyRj3S1R4ClVk2g0IDeagko/jc8zzLEYuIK+fbkds79YECQQDt3vcevgegnkga\ntF4NsDmmBPRkcSHCqrANP/7vFcBQN3czxeYYWX3DK07alu6GhH1Y4sHbdm616uU0\nll7xbDzxAkEAzAtN2IyftNygV2EGiaGgqLyo/tD9+Vui2qCQplqe4jvWh/5Sparl\nOjmKo+uAW+hLrLVMnHzRWxbWU8hirH5FNQJATO+ZxCK4etXXAnQmG41NCAqANWB2\nB+2HJbH2NcQ2QHvAHUm741JGn/KI/aBlo7KEjFRDWUVUB5ji64BbUwCsMQJBAIku\nLGcjnBf/oLk+XSPZC2eGd2Ph5G5qYmH0Q2vkTx+wtTn3DV+eNsDfgMtWAJVJ5t61\ngU1QSXyhLPVlKpnnxuUCQC+xvvWjWtsLaFtAsZywJiqLxQzHts8XLGZptYJ5tLWV\nrtmYtBcJCN48RrgQHry/xWYeA4K/AFQpXfNPgprQ96Q=\n-----END RSA PRIVATE KEY-----\n",
+		"public_key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC9mC3WZN9UGLxgPBpP7H5jZMc6pKwOoSgre8yun6REFktn/Kz7DUt9jaR1UJyRzHxITfCfAIgSxPdGqB/oF1suMyWgu5i0625vavLB5z5kC8Hq3qZJ9zJO1poE1kyD+htiTtPWJ88e12xuH2XB/CZN9OpEiF98hAagiOE0EnOS5Q== Generated by Nova\n",
+		"user_id": "fake"
+	}
+}
+`
+
+// ImportOutput is a sample response to a Create call that provides its own public key.
+const ImportOutput = `
+{
+	"keypair": {
+		"fingerprint": "1e:2c:9b:56:79:4b:45:77:f9:ca:7a:98:2c:b0:d5:3c",
+		"name": "importedkey",
+		"public_key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDx8nkQv/zgGgB4rMYmIf+6A4l6Rr+o/6lHBQdW5aYd44bd8JttDCE/F/pNRr0lRE+PiqSPO8nDPHw0010JeMH9gYgnnFlyY3/OcJ02RhIPyyxYpv9FhY+2YiUkpwFOcLImyrxEsYXpD/0d3ac30bNH6Sw9JD9UZHYcpSxsIbECHw== Generated by Nova",
+		"user_id": "fake"
+	}
+}
+`
+
+// FirstKeyPair is the first result in ListOutput.
+var FirstKeyPair = keypairs.KeyPair{
+	Name:        "firstkey",
+	Fingerprint: "15:b0:f8:b3:f9:48:63:71:cf:7b:5b:38:6d:44:2d:4a",
+	PublicKey:   "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC+Eo/RZRngaGTkFs7I62ZjsIlO79KklKbMXi8F+KITD4bVQHHn+kV+4gRgkgCRbdoDqoGfpaDFs877DYX9n4z6FrAIZ4PES8TNKhatifpn9NdQYWA+IkU8CuvlEKGuFpKRi/k7JLos/gHi2hy7QUwgtRvcefvD/vgQZOVw/mGR9Q== Generated by Nova\n",
+}
+
+// SecondKeyPair is the second result in ListOutput.
+var SecondKeyPair = keypairs.KeyPair{
+	Name:        "secondkey",
+	Fingerprint: "35:9d:d0:c3:4a:80:d3:d8:86:f1:ca:f7:df:c4:f9:d8",
+	PublicKey:   "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC9mC3WZN9UGLxgPBpP7H5jZMc6pKwOoSgre8yun6REFktn/Kz7DUt9jaR1UJyRzHxITfCfAIgSxPdGqB/oF1suMyWgu5i0625vavLB5z5kC8Hq3qZJ9zJO1poE1kyD+htiTtPWJ88e12xuH2XB/CZN9OpEiF98hAagiOE0EnOS5Q== Generated by Nova\n",
+}
+
+// ExpectedKeyPairSlice is the slice of results that should be parsed from ListOutput, in the expected
+// order.
+var ExpectedKeyPairSlice = []keypairs.KeyPair{FirstKeyPair, SecondKeyPair}
+
+// CreatedKeyPair is the parsed result from CreatedOutput.
+var CreatedKeyPair = keypairs.KeyPair{
+	Name:        "createdkey",
+	Fingerprint: "35:9d:d0:c3:4a:80:d3:d8:86:f1:ca:f7:df:c4:f9:d8",
+	PublicKey:   "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC9mC3WZN9UGLxgPBpP7H5jZMc6pKwOoSgre8yun6REFktn/Kz7DUt9jaR1UJyRzHxITfCfAIgSxPdGqB/oF1suMyWgu5i0625vavLB5z5kC8Hq3qZJ9zJO1poE1kyD+htiTtPWJ88e12xuH2XB/CZN9OpEiF98hAagiOE0EnOS5Q== Generated by Nova\n",
+	PrivateKey:  "-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQC9mC3WZN9UGLxgPBpP7H5jZMc6pKwOoSgre8yun6REFktn/Kz7\nDUt9jaR1UJyRzHxITfCfAIgSxPdGqB/oF1suMyWgu5i0625vavLB5z5kC8Hq3qZJ\n9zJO1poE1kyD+htiTtPWJ88e12xuH2XB/CZN9OpEiF98hAagiOE0EnOS5QIDAQAB\nAoGAE5XO1mDhORy9COvsg+kYPUhB1GsCYxh+v88wG7HeFDKBY6KUc/Kxo6yoGn5T\nTjRjekyi2KoDZHz4VlIzyZPwFS4I1bf3oCunVoAKzgLdmnTtvRNMC5jFOGc2vUgP\n9bSyRj3S1R4ClVk2g0IDeagko/jc8zzLEYuIK+fbkds79YECQQDt3vcevgegnkga\ntF4NsDmmBPRkcSHCqrANP/7vFcBQN3czxeYYWX3DK07alu6GhH1Y4sHbdm616uU0\nll7xbDzxAkEAzAtN2IyftNygV2EGiaGgqLyo/tD9+Vui2qCQplqe4jvWh/5Sparl\nOjmKo+uAW+hLrLVMnHzRWxbWU8hirH5FNQJATO+ZxCK4etXXAnQmG41NCAqANWB2\nB+2HJbH2NcQ2QHvAHUm741JGn/KI/aBlo7KEjFRDWUVUB5ji64BbUwCsMQJBAIku\nLGcjnBf/oLk+XSPZC2eGd2Ph5G5qYmH0Q2vkTx+wtTn3DV+eNsDfgMtWAJVJ5t61\ngU1QSXyhLPVlKpnnxuUCQC+xvvWjWtsLaFtAsZywJiqLxQzHts8XLGZptYJ5tLWV\nrtmYtBcJCN48RrgQHry/xWYeA4K/AFQpXfNPgprQ96Q=\n-----END RSA PRIVATE KEY-----\n",
+	UserID:      "fake",
+}
+
+// ImportedKeyPair is the parsed result from ImportOutput.
+var ImportedKeyPair = keypairs.KeyPair{
+	Name:        "importedkey",
+	Fingerprint: "1e:2c:9b:56:79:4b:45:77:f9:ca:7a:98:2c:b0:d5:3c",
+	PublicKey:   "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDx8nkQv/zgGgB4rMYmIf+6A4l6Rr+o/6lHBQdW5aYd44bd8JttDCE/F/pNRr0lRE+PiqSPO8nDPHw0010JeMH9gYgnnFlyY3/OcJ02RhIPyyxYpv9FhY+2YiUkpwFOcLImyrxEsYXpD/0d3ac30bNH6Sw9JD9UZHYcpSxsIbECHw== Generated by Nova",
+	UserID:      "fake",
+}
+
+// HandleListSuccessfully configures the test server to respond to a List request.
+func HandleListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-keypairs", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ListOutput)
+	})
+}
+
+// HandleGetSuccessfully configures the test server to respond to a Get request for "firstkey".
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-keypairs/firstkey", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
+
+// HandleCreateSuccessfully configures the test server to respond to a Create request for a new
+// keypair called "createdkey".
+func HandleCreateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-keypairs", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{ "keypair": { "name": "createdkey" } }`)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, CreateOutput)
+	})
+}
+
+// HandleImportSuccessfully configures the test server to respond to an Import request for an
+// existing keypair called "importedkey".
+func HandleImportSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-keypairs", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+			{
+				"keypair": {
+					"name": "importedkey",
+					"public_key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDx8nkQv/zgGgB4rMYmIf+6A4l6Rr+o/6lHBQdW5aYd44bd8JttDCE/F/pNRr0lRE+PiqSPO8nDPHw0010JeMH9gYgnnFlyY3/OcJ02RhIPyyxYpv9FhY+2YiUkpwFOcLImyrxEsYXpD/0d3ac30bNH6Sw9JD9UZHYcpSxsIbECHw== Generated by Nova"
+				}
+			}
+		`)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ImportOutput)
+	})
+}
+
+// HandleDeleteSuccessfully configures the test server to respond to a Delete request for a
+// keypair called "deletedkey".
+func HandleDeleteSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-keypairs/deletedkey", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/requests_test.go
new file mode 100644
index 000000000..1e05e6687
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/testing/requests_test.go
@@ -0,0 +1,72 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleListSuccessfully(t)
+
+	count := 0
+	err := keypairs.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := keypairs.ExtractKeyPairs(page)
+		th.AssertNoErr(t, err)
+		th.CheckDeepEquals(t, ExpectedKeyPairSlice, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.CheckEquals(t, 1, count)
+}
+
+func TestCreate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleCreateSuccessfully(t)
+
+	actual, err := keypairs.Create(client.ServiceClient(), keypairs.CreateOpts{
+		Name: "createdkey",
+	}).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &CreatedKeyPair, actual)
+}
+
+func TestImport(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleImportSuccessfully(t)
+
+	actual, err := keypairs.Create(client.ServiceClient(), keypairs.CreateOpts{
+		Name:      "importedkey",
+		PublicKey: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDx8nkQv/zgGgB4rMYmIf+6A4l6Rr+o/6lHBQdW5aYd44bd8JttDCE/F/pNRr0lRE+PiqSPO8nDPHw0010JeMH9gYgnnFlyY3/OcJ02RhIPyyxYpv9FhY+2YiUkpwFOcLImyrxEsYXpD/0d3ac30bNH6Sw9JD9UZHYcpSxsIbECHw== Generated by Nova",
+	}).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &ImportedKeyPair, actual)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSuccessfully(t)
+
+	actual, err := keypairs.Get(client.ServiceClient(), "firstkey").Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &FirstKeyPair, actual)
+}
+
+func TestDelete(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleDeleteSuccessfully(t)
+
+	err := keypairs.Delete(client.ServiceClient(), "deletedkey").ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/urls.go
new file mode 100644
index 000000000..fec38f367
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs/urls.go
@@ -0,0 +1,25 @@
+package keypairs
+
+import "github.com/gophercloud/gophercloud"
+
+const resourcePath = "os-keypairs"
+
+func resourceURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(resourcePath)
+}
+
+func listURL(c *gophercloud.ServiceClient) string {
+	return resourceURL(c)
+}
+
+func createURL(c *gophercloud.ServiceClient) string {
+	return resourceURL(c)
+}
+
+func getURL(c *gophercloud.ServiceClient, name string) string {
+	return c.ServiceURL(resourcePath, name)
+}
+
+func deleteURL(c *gophercloud.ServiceClient, name string) string {
+	return getURL(c, name)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/doc.go
new file mode 100644
index 000000000..c14d537a6
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/doc.go
@@ -0,0 +1,17 @@
+/*
+Package limits shows rate and limit information for a tenant/project.
+
+Example to Retrieve Limits for a Tenant
+
+	getOpts := limits.GetOpts{
+		TenantID: "tenant-id",
+	}
+
+	limits, err := limits.Get(computeClient, getOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v\n", limits)
+*/
+package limits
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/requests.go
new file mode 100644
index 000000000..57573d38c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/requests.go
@@ -0,0 +1,39 @@
+package limits
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// GetOptsBuilder allows extensions to add additional parameters to the
+// Get request.
+type GetOptsBuilder interface {
+	ToLimitsQuery() (string, error)
+}
+
+// GetOpts enables retrieving limits by a specific tenant.
+type GetOpts struct {
+	// The tenant ID to retrieve limits for.
+	TenantID string `q:"tenant_id"`
+}
+
+// ToLimitsQuery formats a GetOpts into a query string.
+func (opts GetOpts) ToLimitsQuery() (string, error) {
+	q, err := gophercloud.BuildQueryString(opts)
+	return q.String(), err
+}
+
+// Get returns the limits about the currently scoped tenant.
+func Get(client *gophercloud.ServiceClient, opts GetOptsBuilder) (r GetResult) {
+	url := getURL(client)
+	if opts != nil {
+		query, err := opts.ToLimitsQuery()
+		if err != nil {
+			r.Err = err
+			return
+		}
+		url += query
+	}
+
+	_, r.Err = client.Get(url, &r.Body, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/results.go
new file mode 100644
index 000000000..8d0564bd2
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/results.go
@@ -0,0 +1,90 @@
+package limits
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// Limits is a struct that contains the response of a limit query.
+type Limits struct {
+	// Absolute contains the limits and usage information.
+	Absolute Absolute `json:"absolute"`
+}
+
+// Usage is a struct that contains the current resource usage and limits
+// of a tenant.
+type Absolute struct {
+	// MaxTotalCores is the number of cores available to a tenant.
+	MaxTotalCores int `json:"maxTotalCores"`
+
+	// MaxImageMeta is the amount of image metadata available to a tenant.
+	MaxImageMeta int `json:"maxImageMeta"`
+
+	// MaxServerMeta is the amount of server metadata available to a tenant.
+	MaxServerMeta int `json:"maxServerMeta"`
+
+	// MaxPersonality is the amount of personality/files available to a tenant.
+	MaxPersonality int `json:"maxPersonality"`
+
+	// MaxPersonalitySize is the personality file size available to a tenant.
+	MaxPersonalitySize int `json:"maxPersonalitySize"`
+
+	// MaxTotalKeypairs is the total keypairs available to a tenant.
+	MaxTotalKeypairs int `json:"maxTotalKeypairs"`
+
+	// MaxSecurityGroups is the number of security groups available to a tenant.
+	MaxSecurityGroups int `json:"maxSecurityGroups"`
+
+	// MaxSecurityGroupRules is the number of security group rules available to
+	// a tenant.
+	MaxSecurityGroupRules int `json:"maxSecurityGroupRules"`
+
+	// MaxServerGroups is the number of server groups available to a tenant.
+	MaxServerGroups int `json:"maxServerGroups"`
+
+	// MaxServerGroupMembers is the number of server group members available
+	// to a tenant.
+	MaxServerGroupMembers int `json:"maxServerGroupMembers"`
+
+	// MaxTotalFloatingIps is the number of floating IPs available to a tenant.
+	MaxTotalFloatingIps int `json:"maxTotalFloatingIps"`
+
+	// MaxTotalInstances is the number of instances/servers available to a tenant.
+	MaxTotalInstances int `json:"maxTotalInstances"`
+
+	// MaxTotalRAMSize is the total amount of RAM available to a tenant measured
+	// in megabytes (MB).
+	MaxTotalRAMSize int `json:"maxTotalRAMSize"`
+
+	// TotalCoresUsed is the number of cores currently in use.
+	TotalCoresUsed int `json:"totalCoresUsed"`
+
+	// TotalInstancesUsed is the number of instances/servers in use.
+	TotalInstancesUsed int `json:"totalInstancesUsed"`
+
+	// TotalFloatingIpsUsed is the number of floating IPs in use.
+	TotalFloatingIpsUsed int `json:"totalFloatingIpsUsed"`
+
+	// TotalRAMUsed is the total RAM/memory in use measured in megabytes (MB).
+	TotalRAMUsed int `json:"totalRAMUsed"`
+
+	// TotalSecurityGroupsUsed is the total number of security groups in use.
+	TotalSecurityGroupsUsed int `json:"totalSecurityGroupsUsed"`
+
+	// TotalServerGroupsUsed is the total number of server groups in use.
+	TotalServerGroupsUsed int `json:"totalServerGroupsUsed"`
+}
+
+// Extract interprets a limits result as a Limits.
+func (r GetResult) Extract() (*Limits, error) {
+	var s struct {
+		Limits *Limits `json:"limits"`
+	}
+	err := r.ExtractInto(&s)
+	return s.Limits, err
+}
+
+// GetResult is the response from a Get operation. Call its Extract
+// method to interpret it as an Absolute.
+type GetResult struct {
+	gophercloud.Result
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/testing/fixtures.go
new file mode 100644
index 000000000..d4e52f778
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/testing/fixtures.go
@@ -0,0 +1,80 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// GetOutput is a sample response to a Get call.
+const GetOutput = `
+{
+    "limits": {
+        "rate": [],
+        "absolute": {
+            "maxServerMeta": 128,
+            "maxPersonality": 5,
+            "totalServerGroupsUsed": 0,
+            "maxImageMeta": 128,
+            "maxPersonalitySize": 10240,
+            "maxTotalKeypairs": 100,
+            "maxSecurityGroupRules": 20,
+            "maxServerGroups": 10,
+            "totalCoresUsed": 1,
+            "totalRAMUsed": 2048,
+            "totalInstancesUsed": 1,
+            "maxSecurityGroups": 10,
+            "totalFloatingIpsUsed": 0,
+            "maxTotalCores": 20,
+            "maxServerGroupMembers": 10,
+            "maxTotalFloatingIps": 10,
+            "totalSecurityGroupsUsed": 1,
+            "maxTotalInstances": 10,
+            "maxTotalRAMSize": 51200
+        }
+    }
+}
+`
+
+// LimitsResult is the result of the limits in GetOutput.
+var LimitsResult = limits.Limits{
+	Absolute: limits.Absolute{
+		MaxServerMeta:           128,
+		MaxPersonality:          5,
+		TotalServerGroupsUsed:   0,
+		MaxImageMeta:            128,
+		MaxPersonalitySize:      10240,
+		MaxTotalKeypairs:        100,
+		MaxSecurityGroupRules:   20,
+		MaxServerGroups:         10,
+		TotalCoresUsed:          1,
+		TotalRAMUsed:            2048,
+		TotalInstancesUsed:      1,
+		MaxSecurityGroups:       10,
+		TotalFloatingIpsUsed:    0,
+		MaxTotalCores:           20,
+		MaxServerGroupMembers:   10,
+		MaxTotalFloatingIps:     10,
+		TotalSecurityGroupsUsed: 1,
+		MaxTotalInstances:       10,
+		MaxTotalRAMSize:         51200,
+	},
+}
+
+const TenantID = "555544443333222211110000ffffeeee"
+
+// HandleGetSuccessfully configures the test server to respond to a Get request
+// for a limit.
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/limits", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/testing/requests_test.go
new file mode 100644
index 000000000..9c8456c9d
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/testing/requests_test.go
@@ -0,0 +1,23 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSuccessfully(t)
+
+	getOpts := limits.GetOpts{
+		TenantID: TenantID,
+	}
+
+	actual, err := limits.Get(client.ServiceClient(), getOpts).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &LimitsResult, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/urls.go
new file mode 100644
index 000000000..edd97e4e0
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/limits/urls.go
@@ -0,0 +1,11 @@
+package limits
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+const resourcePath = "limits"
+
+func getURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(resourcePath)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/doc.go
new file mode 100644
index 000000000..ac51a36f6
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/doc.go
@@ -0,0 +1,19 @@
+/*
+Package lockunlock provides functionality to lock and unlock servers that
+have been provisioned by the OpenStack Compute service.
+
+Example to Lock and Unlock a Server
+
+	serverID := "47b6b7b7-568d-40e4-868c-d5c41735532e"
+
+	err := lockunlock.Lock(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+	err = lockunlock.Unlock(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package lockunlock
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/requests.go
new file mode 100644
index 000000000..3ddf11846
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/requests.go
@@ -0,0 +1,18 @@
+package lockunlock
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// Lock is the operation responsible for locking a Compute server.
+func Lock(client *gophercloud.ServiceClient, id string) (r LockResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"lock": nil}, nil, nil)
+	return
+}
+
+// Unlock is the operation responsible for unlocking a Compute server.
+func Unlock(client *gophercloud.ServiceClient, id string) (r UnlockResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"unlock": nil}, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/results.go
new file mode 100644
index 000000000..282bc8a0e
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/results.go
@@ -0,0 +1,16 @@
+package lockunlock
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// LockResult and UnlockResult are the responses from a Lock and Unlock
+// operations respectively. Call their ExtractErr methods to determine if the
+// requests suceeded or failed.
+type LockResult struct {
+	gophercloud.ErrResult
+}
+
+type UnlockResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/doc.go
new file mode 100644
index 000000000..59cb9be47
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/doc.go
@@ -0,0 +1,2 @@
+// unlocklock unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/fixtures.go
new file mode 100644
index 000000000..ec79b7532
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/fixtures.go
@@ -0,0 +1,27 @@
+package testing
+
+import (
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func mockStartServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"lock": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockStopServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"unlock": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/request_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/request_test.go
new file mode 100644
index 000000000..cb2906d27
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock/testing/request_test.go
@@ -0,0 +1,31 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/lockunlock"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const serverID = "{serverId}"
+
+func TestLock(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockStartServerResponse(t, serverID)
+
+	err := lockunlock.Lock(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestUnlock(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockStopServerResponse(t, serverID)
+
+	err := lockunlock.Unlock(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/doc.go
new file mode 100644
index 000000000..cf3067716
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/doc.go
@@ -0,0 +1,30 @@
+/*
+Package migrate provides functionality to migrate servers that have been
+provisioned by the OpenStack Compute service.
+
+Example of Migrate Server (migrate Action)
+
+	serverID := "b16ba811-199d-4ffd-8839-ba96c1185a67"
+	err := migrate.Migrate(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+Example of Live-Migrate Server (os-migrateLive Action)
+
+	serverID := "b16ba811-199d-4ffd-8839-ba96c1185a67"
+	host := "01c0cadef72d47e28a672a76060d492c"
+	blockMigration := false
+
+	migrationOpts := migrate.LiveMigrateOpts{
+		Host: &host,
+		BlockMigration: &blockMigration,
+	}
+
+	err := migrate.LiveMigrate(computeClient, serverID, migrationOpts).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+*/
+package migrate
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/requests.go
new file mode 100644
index 000000000..5c7833c38
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/requests.go
@@ -0,0 +1,51 @@
+package migrate
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// Migrate will initiate a migration of the instance to another host.
+func Migrate(client *gophercloud.ServiceClient, id string) (r MigrateResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"migrate": nil}, nil, nil)
+	return
+}
+
+// LiveMigrateOptsBuilder allows extensions to add additional parameters to the
+// LiveMigrate request.
+type LiveMigrateOptsBuilder interface {
+	ToLiveMigrateMap() (map[string]interface{}, error)
+}
+
+// LiveMigrateOpts specifies parameters of live migrate action.
+type LiveMigrateOpts struct {
+	// The host to which to migrate the server.
+	// If this parameter is None, the scheduler chooses a host.
+	Host *string `json:"host"`
+
+	// Set to True to migrate local disks by using block migration.
+	// If the source or destination host uses shared storage and you set
+	// this value to True, the live migration fails.
+	BlockMigration *bool `json:"block_migration,omitempty"`
+
+	// Set to True to enable over commit when the destination host is checked
+	// for available disk space. Set to False to disable over commit. This setting
+	// affects only the libvirt virt driver.
+	DiskOverCommit *bool `json:"disk_over_commit,omitempty"`
+}
+
+// ToLiveMigrateMap constructs a request body from LiveMigrateOpts.
+func (opts LiveMigrateOpts) ToLiveMigrateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "os-migrateLive")
+}
+
+// LiveMigrate will initiate a live-migration (without rebooting) of the instance to another host.
+func LiveMigrate(client *gophercloud.ServiceClient, id string, opts LiveMigrateOptsBuilder) (r MigrateResult) {
+	b, err := opts.ToLiveMigrateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(extensions.ActionURL(client, id), b, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/results.go
new file mode 100644
index 000000000..ebccf56ac
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/results.go
@@ -0,0 +1,11 @@
+package migrate
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// MigrateResult is the response from a Migrate operation. Call its ExtractErr
+// method to determine if the request suceeded or failed.
+type MigrateResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/doc.go
new file mode 100644
index 000000000..613547573
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/doc.go
@@ -0,0 +1,2 @@
+// compute_extensions_startstop_v2
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/fixtures.go
new file mode 100644
index 000000000..1d2f5902c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/fixtures.go
@@ -0,0 +1,33 @@
+package testing
+
+import (
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func mockMigrateResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"migrate": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockLiveMigrateResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{
+			"os-migrateLive": {
+				"host": "01c0cadef72d47e28a672a76060d492c",
+				"block_migration": false,
+				"disk_over_commit": true
+			}
+		}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/requests_test.go
new file mode 100644
index 000000000..b6906b783
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate/testing/requests_test.go
@@ -0,0 +1,41 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/migrate"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const serverID = "b16ba811-199d-4ffd-8839-ba96c1185a67"
+
+func TestMigrate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockMigrateResponse(t, serverID)
+
+	err := migrate.Migrate(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestLiveMigrate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockLiveMigrateResponse(t, serverID)
+
+	host := "01c0cadef72d47e28a672a76060d492c"
+	blockMigration := false
+	diskOverCommit := true
+
+	migrationOpts := migrate.LiveMigrateOpts{
+		Host:           &host,
+		BlockMigration: &blockMigration,
+		DiskOverCommit: &diskOverCommit,
+	}
+
+	err := migrate.LiveMigrate(client.ServiceClient(), serverID, migrationOpts).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/doc.go
new file mode 100644
index 000000000..f291734e9
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/doc.go
@@ -0,0 +1,24 @@
+/*
+Package networks provides the ability to create and manage networks in cloud
+environments using nova-network.
+
+This package can also be used to retrieve network details of Neutron-based
+networks.
+
+Example to List Networks
+
+	allPages, err := networks.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allNetworks, err := networks.ExtractNetworks(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, network := range allNetworks {
+		fmt.Printf("%+v\n", network)
+	}
+*/
+package networks
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/requests.go
new file mode 100644
index 000000000..5432a1025
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/requests.go
@@ -0,0 +1,19 @@
+package networks
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List returns a Pager that allows you to iterate over a collection of Network.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, listURL(client), func(r pagination.PageResult) pagination.Page {
+		return NetworkPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// Get returns data about a previously created Network.
+func Get(client *gophercloud.ServiceClient, id string) (r GetResult) {
+	_, r.Err = client.Get(getURL(client, id), &r.Body, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/results.go
new file mode 100644
index 000000000..c36ce678c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/results.go
@@ -0,0 +1,133 @@
+package networks
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// A Network represents a network in an OpenStack cloud.
+type Network struct {
+	// The Bridge that VIFs on this network are connected to
+	Bridge string `json:"bridge"`
+
+	// BridgeInterface is what interface is connected to the Bridge
+	BridgeInterface string `json:"bridge_interface"`
+
+	// The Broadcast address of the network.
+	Broadcast string `json:"broadcast"`
+
+	// CIDR is the IPv4 subnet.
+	CIDR string `json:"cidr"`
+
+	// CIDRv6 is the IPv6 subnet.
+	CIDRv6 string `json:"cidr_v6"`
+
+	// CreatedAt is when the network was created..
+	CreatedAt gophercloud.JSONRFC3339MilliNoZ `json:"created_at,omitempty"`
+
+	// Deleted shows if the network has been deleted.
+	Deleted bool `json:"deleted"`
+
+	// DeletedAt is the time when the network was deleted.
+	DeletedAt gophercloud.JSONRFC3339MilliNoZ `json:"deleted_at,omitempty"`
+
+	// DHCPStart is the start of the DHCP address range.
+	DHCPStart string `json:"dhcp_start"`
+
+	// DNS1 is the first DNS server to use through DHCP.
+	DNS1 string `json:"dns_1"`
+
+	// DNS2 is the first DNS server to use through DHCP.
+	DNS2 string `json:"dns_2"`
+
+	// Gateway is the network gateway.
+	Gateway string `json:"gateway"`
+
+	// Gatewayv6 is the IPv6 network gateway.
+	Gatewayv6 string `json:"gateway_v6"`
+
+	// Host is the host that the network service is running on.
+	Host string `json:"host"`
+
+	// ID is the UUID of the network.
+	ID string `json:"id"`
+
+	// Injected determines if network information is injected into the host.
+	Injected bool `json:"injected"`
+
+	// Label is the common name that the network has..
+	Label string `json:"label"`
+
+	// MultiHost is if multi-host networking is enablec..
+	MultiHost bool `json:"multi_host"`
+
+	// Netmask is the network netmask.
+	Netmask string `json:"netmask"`
+
+	// Netmaskv6 is the IPv6 netmask.
+	Netmaskv6 string `json:"netmask_v6"`
+
+	// Priority is the network interface priority.
+	Priority int `json:"priority"`
+
+	// ProjectID is the project associated with this network.
+	ProjectID string `json:"project_id"`
+
+	// RXTXBase configures bandwidth entitlement.
+	RXTXBase int `json:"rxtx_base"`
+
+	// UpdatedAt is the time when the network was last updated.
+	UpdatedAt gophercloud.JSONRFC3339MilliNoZ `json:"updated_at,omitempty"`
+
+	// VLAN is the vlan this network runs on.
+	VLAN int `json:"vlan"`
+
+	// VPNPrivateAddress is the private address of the CloudPipe VPN.
+	VPNPrivateAddress string `json:"vpn_private_address"`
+
+	// VPNPublicAddress is the public address of the CloudPipe VPN.
+	VPNPublicAddress string `json:"vpn_public_address"`
+
+	// VPNPublicPort is the port of the CloudPipe VPN.
+	VPNPublicPort int `json:"vpn_public_port"`
+}
+
+// NetworkPage stores a single page of all Network results from a List call.
+type NetworkPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a NetworkPage is empty.
+func (page NetworkPage) IsEmpty() (bool, error) {
+	va, err := ExtractNetworks(page)
+	return len(va) == 0, err
+}
+
+// ExtractNetworks interprets a page of results as a slice of Networks.
+func ExtractNetworks(r pagination.Page) ([]Network, error) {
+	var s struct {
+		Networks []Network `json:"networks"`
+	}
+	err := (r.(NetworkPage)).ExtractInto(&s)
+	return s.Networks, err
+}
+
+type NetworkResult struct {
+	gophercloud.Result
+}
+
+// Extract is a method that attempts to interpret any Network resource
+// response as a Network struct.
+func (r NetworkResult) Extract() (*Network, error) {
+	var s struct {
+		Network *Network `json:"network"`
+	}
+	err := r.ExtractInto(&s)
+	return s.Network, err
+}
+
+// GetResult is the response from a Get operation. Call its Extract method to
+// interpret it as a Network.
+type GetResult struct {
+	NetworkResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/doc.go
new file mode 100644
index 000000000..fc8511de4
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/doc.go
@@ -0,0 +1,2 @@
+// networks unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/fixtures.go
new file mode 100644
index 000000000..e2fa49b48
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/fixtures.go
@@ -0,0 +1,204 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ListOutput is a sample response to a List call.
+const ListOutput = `
+{
+    "networks": [
+        {
+            "bridge": "br100",
+            "bridge_interface": "eth0",
+            "broadcast": "10.0.0.7",
+            "cidr": "10.0.0.0/29",
+            "cidr_v6": null,
+            "created_at": "2011-08-15T06:19:19.387525",
+            "deleted": false,
+            "dhcp_start": "10.0.0.3",
+            "dns1": null,
+            "dns2": null,
+            "gateway": "10.0.0.1",
+            "gateway_v6": null,
+            "host": "nsokolov-desktop",
+            "id": "20c8acc0-f747-4d71-a389-46d078ebf047",
+            "injected": false,
+            "label": "mynet_0",
+            "multi_host": false,
+            "netmask": "255.255.255.248",
+            "netmask_v6": null,
+            "priority": null,
+            "project_id": "1234",
+            "rxtx_base": null,
+            "updated_at": "2011-08-16T09:26:13.048257",
+            "vlan": 100,
+            "vpn_private_address": "10.0.0.2",
+            "vpn_public_address": "127.0.0.1",
+            "vpn_public_port": 1000
+        },
+        {
+            "bridge": "br101",
+            "bridge_interface": "eth0",
+            "broadcast": "10.0.0.15",
+            "cidr": "10.0.0.10/29",
+            "cidr_v6": null,
+            "created_at": "2011-08-15T06:19:19.387525",
+            "deleted": false,
+            "dhcp_start": "10.0.0.11",
+            "dns1": null,
+            "dns2": null,
+            "gateway": "10.0.0.9",
+            "gateway_v6": null,
+            "host": null,
+            "id": "20c8acc0-f747-4d71-a389-46d078ebf000",
+            "injected": false,
+            "label": "mynet_1",
+            "multi_host": false,
+            "netmask": "255.255.255.248",
+            "netmask_v6": null,
+            "priority": null,
+            "project_id": null,
+            "rxtx_base": null,
+            "vlan": 101,
+            "vpn_private_address": "10.0.0.10",
+            "vpn_public_address": null,
+            "vpn_public_port": 1001
+        }
+    ]
+}
+`
+
+// GetOutput is a sample response to a Get call.
+const GetOutput = `
+{
+    "network": {
+			"bridge": "br101",
+			"bridge_interface": "eth0",
+			"broadcast": "10.0.0.15",
+			"cidr": "10.0.0.10/29",
+			"cidr_v6": null,
+			"created_at": "2011-08-15T06:19:19.387525",
+			"deleted": false,
+			"dhcp_start": "10.0.0.11",
+			"dns1": null,
+			"dns2": null,
+			"gateway": "10.0.0.9",
+			"gateway_v6": null,
+			"host": null,
+			"id": "20c8acc0-f747-4d71-a389-46d078ebf000",
+			"injected": false,
+			"label": "mynet_1",
+			"multi_host": false,
+			"netmask": "255.255.255.248",
+			"netmask_v6": null,
+			"priority": null,
+			"project_id": null,
+			"rxtx_base": null,
+			"vlan": 101,
+			"vpn_private_address": "10.0.0.10",
+			"vpn_public_address": null,
+			"vpn_public_port": 1001
+		}
+}
+`
+
+// FirstNetwork is the first result in ListOutput.
+var nilTime time.Time
+var FirstNetwork = networks.Network{
+	Bridge:            "br100",
+	BridgeInterface:   "eth0",
+	Broadcast:         "10.0.0.7",
+	CIDR:              "10.0.0.0/29",
+	CIDRv6:            "",
+	CreatedAt:         gophercloud.JSONRFC3339MilliNoZ(time.Date(2011, 8, 15, 6, 19, 19, 387525000, time.UTC)),
+	Deleted:           false,
+	DeletedAt:         gophercloud.JSONRFC3339MilliNoZ(nilTime),
+	DHCPStart:         "10.0.0.3",
+	DNS1:              "",
+	DNS2:              "",
+	Gateway:           "10.0.0.1",
+	Gatewayv6:         "",
+	Host:              "nsokolov-desktop",
+	ID:                "20c8acc0-f747-4d71-a389-46d078ebf047",
+	Injected:          false,
+	Label:             "mynet_0",
+	MultiHost:         false,
+	Netmask:           "255.255.255.248",
+	Netmaskv6:         "",
+	Priority:          0,
+	ProjectID:         "1234",
+	RXTXBase:          0,
+	UpdatedAt:         gophercloud.JSONRFC3339MilliNoZ(time.Date(2011, 8, 16, 9, 26, 13, 48257000, time.UTC)),
+	VLAN:              100,
+	VPNPrivateAddress: "10.0.0.2",
+	VPNPublicAddress:  "127.0.0.1",
+	VPNPublicPort:     1000,
+}
+
+// SecondNetwork is the second result in ListOutput.
+var SecondNetwork = networks.Network{
+	Bridge:            "br101",
+	BridgeInterface:   "eth0",
+	Broadcast:         "10.0.0.15",
+	CIDR:              "10.0.0.10/29",
+	CIDRv6:            "",
+	CreatedAt:         gophercloud.JSONRFC3339MilliNoZ(time.Date(2011, 8, 15, 6, 19, 19, 387525000, time.UTC)),
+	Deleted:           false,
+	DeletedAt:         gophercloud.JSONRFC3339MilliNoZ(nilTime),
+	DHCPStart:         "10.0.0.11",
+	DNS1:              "",
+	DNS2:              "",
+	Gateway:           "10.0.0.9",
+	Gatewayv6:         "",
+	Host:              "",
+	ID:                "20c8acc0-f747-4d71-a389-46d078ebf000",
+	Injected:          false,
+	Label:             "mynet_1",
+	MultiHost:         false,
+	Netmask:           "255.255.255.248",
+	Netmaskv6:         "",
+	Priority:          0,
+	ProjectID:         "",
+	RXTXBase:          0,
+	UpdatedAt:         gophercloud.JSONRFC3339MilliNoZ(nilTime),
+	VLAN:              101,
+	VPNPrivateAddress: "10.0.0.10",
+	VPNPublicAddress:  "",
+	VPNPublicPort:     1001,
+}
+
+// ExpectedNetworkSlice is the slice of results that should be parsed
+// from ListOutput, in the expected order.
+var ExpectedNetworkSlice = []networks.Network{FirstNetwork, SecondNetwork}
+
+// HandleListSuccessfully configures the test server to respond to a List request.
+func HandleListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-networks", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ListOutput)
+	})
+}
+
+// HandleGetSuccessfully configures the test server to respond to a Get request
+// for an existing network.
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-networks/20c8acc0-f747-4d71-a389-46d078ebf000", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/requests_test.go
new file mode 100644
index 000000000..36b5463e4
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/testing/requests_test.go
@@ -0,0 +1,38 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleListSuccessfully(t)
+
+	count := 0
+	err := networks.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := networks.ExtractNetworks(page)
+		th.AssertNoErr(t, err)
+		th.CheckDeepEquals(t, ExpectedNetworkSlice, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.CheckEquals(t, 1, count)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSuccessfully(t)
+
+	actual, err := networks.Get(client.ServiceClient(), "20c8acc0-f747-4d71-a389-46d078ebf000").Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &SecondNetwork, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/urls.go
new file mode 100644
index 000000000..491bde6f6
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/networks/urls.go
@@ -0,0 +1,17 @@
+package networks
+
+import "github.com/gophercloud/gophercloud"
+
+const resourcePath = "os-networks"
+
+func resourceURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(resourcePath)
+}
+
+func listURL(c *gophercloud.ServiceClient) string {
+	return resourceURL(c)
+}
+
+func getURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL(resourcePath, id)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/doc.go
new file mode 100644
index 000000000..b260ca076
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/doc.go
@@ -0,0 +1,18 @@
+/*
+Package pauseunpause provides functionality to pause and unpause servers that
+have been provisioned by the OpenStack Compute service.
+
+Example to Pause and Unpause a Server
+
+	serverID := "32c8baf7-1cdb-4cc2-bc31-c3a55b89f56b"
+	err := pauseunpause.Pause(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+	err = pauseunpause.Unpause(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package pauseunpause
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/requests.go
new file mode 100644
index 000000000..209617399
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/requests.go
@@ -0,0 +1,18 @@
+package pauseunpause
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// Pause is the operation responsible for pausing a Compute server.
+func Pause(client *gophercloud.ServiceClient, id string) (r PauseResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"pause": nil}, nil, nil)
+	return
+}
+
+// Unpause is the operation responsible for unpausing a Compute server.
+func Unpause(client *gophercloud.ServiceClient, id string) (r UnpauseResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"unpause": nil}, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/results.go
new file mode 100644
index 000000000..3cb91d981
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/results.go
@@ -0,0 +1,15 @@
+package pauseunpause
+
+import "github.com/gophercloud/gophercloud"
+
+// PauseResult is the response from a Pause operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type PauseResult struct {
+	gophercloud.ErrResult
+}
+
+// UnpauseResult is the response from an Unpause operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type UnpauseResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/doc.go
new file mode 100644
index 000000000..095386750
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/doc.go
@@ -0,0 +1,2 @@
+// pauseunpause unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/fixtures.go
new file mode 100644
index 000000000..3723bb336
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/fixtures.go
@@ -0,0 +1,27 @@
+package testing
+
+import (
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func mockPauseServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"pause": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockUnpauseServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"unpause": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/requests_test.go
new file mode 100644
index 000000000..0433e8c48
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause/testing/requests_test.go
@@ -0,0 +1,31 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/pauseunpause"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const serverID = "{serverId}"
+
+func TestPause(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockPauseServerResponse(t, serverID)
+
+	err := pauseunpause.Pause(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestUnpause(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockUnpauseServerResponse(t, serverID)
+
+	err := pauseunpause.Unpause(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/doc.go
new file mode 100644
index 000000000..04d9887a1
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/doc.go
@@ -0,0 +1,36 @@
+/*
+Package quotasets enables retrieving and managing Compute quotas.
+
+Example to Get a Quota Set
+
+	quotaset, err := quotasets.Get(computeClient, "tenant-id").Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v\n", quotaset)
+
+Example to Get a Detailed Quota Set
+
+	quotaset, err := quotasets.GetDetail(computeClient, "tenant-id").Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v\n", quotaset)
+
+Example to Update a Quota Set
+
+	updateOpts := quotasets.UpdateOpts{
+		FixedIPs: gophercloud.IntToPointer(100),
+		Cores:    gophercloud.IntToPointer(64),
+	}
+
+	quotaset, err := quotasets.Update(computeClient, "tenant-id", updateOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Printf("%+v\n", quotaset)
+*/
+package quotasets
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/requests.go
new file mode 100644
index 000000000..d5daa7e3f
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/requests.go
@@ -0,0 +1,99 @@
+package quotasets
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// Get returns public data about a previously created QuotaSet.
+func Get(client *gophercloud.ServiceClient, tenantID string) (r GetResult) {
+	_, r.Err = client.Get(getURL(client, tenantID), &r.Body, nil)
+	return
+}
+
+// GetDetail returns detailed public data about a previously created QuotaSet.
+func GetDetail(client *gophercloud.ServiceClient, tenantID string) (r GetDetailResult) {
+	_, r.Err = client.Get(getDetailURL(client, tenantID), &r.Body, nil)
+	return
+}
+
+// Updates the quotas for the given tenantID and returns the new QuotaSet.
+func Update(client *gophercloud.ServiceClient, tenantID string, opts UpdateOptsBuilder) (r UpdateResult) {
+	reqBody, err := opts.ToComputeQuotaUpdateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+
+	_, r.Err = client.Put(updateURL(client, tenantID), reqBody, &r.Body, &gophercloud.RequestOpts{OkCodes: []int{200}})
+	return
+}
+
+// Resets the quotas for the given tenant to their default values.
+func Delete(client *gophercloud.ServiceClient, tenantID string) (r DeleteResult) {
+	_, r.Err = client.Delete(deleteURL(client, tenantID), nil)
+	return
+}
+
+// Options for Updating the quotas of a Tenant.
+// All int-values are pointers so they can be nil if they are not needed.
+// You can use gopercloud.IntToPointer() for convenience
+type UpdateOpts struct {
+	// FixedIPs is number of fixed ips alloted this quota_set.
+	FixedIPs *int `json:"fixed_ips,omitempty"`
+
+	// FloatingIPs is number of floating ips alloted this quota_set.
+	FloatingIPs *int `json:"floating_ips,omitempty"`
+
+	// InjectedFileContentBytes is content bytes allowed for each injected file.
+	InjectedFileContentBytes *int `json:"injected_file_content_bytes,omitempty"`
+
+	// InjectedFilePathBytes is allowed bytes for each injected file path.
+	InjectedFilePathBytes *int `json:"injected_file_path_bytes,omitempty"`
+
+	// InjectedFiles is injected files allowed for each project.
+	InjectedFiles *int `json:"injected_files,omitempty"`
+
+	// KeyPairs is number of ssh keypairs.
+	KeyPairs *int `json:"key_pairs,omitempty"`
+
+	// MetadataItems is number of metadata items allowed for each instance.
+	MetadataItems *int `json:"metadata_items,omitempty"`
+
+	// RAM is megabytes allowed for each instance.
+	RAM *int `json:"ram,omitempty"`
+
+	// SecurityGroupRules is rules allowed for each security group.
+	SecurityGroupRules *int `json:"security_group_rules,omitempty"`
+
+	// SecurityGroups security groups allowed for each project.
+	SecurityGroups *int `json:"security_groups,omitempty"`
+
+	// Cores is number of instance cores allowed for each project.
+	Cores *int `json:"cores,omitempty"`
+
+	// Instances is number of instances allowed for each project.
+	Instances *int `json:"instances,omitempty"`
+
+	// Number of ServerGroups allowed for the project.
+	ServerGroups *int `json:"server_groups,omitempty"`
+
+	// Max number of Members for each ServerGroup.
+	ServerGroupMembers *int `json:"server_group_members,omitempty"`
+
+	// Force will update the quotaset even if the quota has already been used
+	// and the reserved quota exceeds the new quota.
+	Force bool `json:"force,omitempty"`
+}
+
+// UpdateOptsBuilder enables extensins to add parameters to the update request.
+type UpdateOptsBuilder interface {
+	// Extra specific name to prevent collisions with interfaces for other quotas
+	// (e.g. neutron)
+	ToComputeQuotaUpdateMap() (map[string]interface{}, error)
+}
+
+// ToComputeQuotaUpdateMap builds the update options into a serializable
+// format.
+func (opts UpdateOpts) ToComputeQuotaUpdateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "quota_set")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/results.go
new file mode 100644
index 000000000..e38868a63
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/results.go
@@ -0,0 +1,194 @@
+package quotasets
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// QuotaSet is a set of operational limits that allow for control of compute
+// usage.
+type QuotaSet struct {
+	// ID is tenant associated with this QuotaSet.
+	ID string `json:"id"`
+
+	// FixedIPs is number of fixed ips alloted this QuotaSet.
+	FixedIPs int `json:"fixed_ips"`
+
+	// FloatingIPs is number of floating ips alloted this QuotaSet.
+	FloatingIPs int `json:"floating_ips"`
+
+	// InjectedFileContentBytes is the allowed bytes for each injected file.
+	InjectedFileContentBytes int `json:"injected_file_content_bytes"`
+
+	// InjectedFilePathBytes is allowed bytes for each injected file path.
+	InjectedFilePathBytes int `json:"injected_file_path_bytes"`
+
+	// InjectedFiles is the number of injected files allowed for each project.
+	InjectedFiles int `json:"injected_files"`
+
+	// KeyPairs is number of ssh keypairs.
+	KeyPairs int `json:"key_pairs"`
+
+	// MetadataItems is number of metadata items allowed for each instance.
+	MetadataItems int `json:"metadata_items"`
+
+	// RAM is megabytes allowed for each instance.
+	RAM int `json:"ram"`
+
+	// SecurityGroupRules is number of security group rules allowed for each
+	// security group.
+	SecurityGroupRules int `json:"security_group_rules"`
+
+	// SecurityGroups is the number of security groups allowed for each project.
+	SecurityGroups int `json:"security_groups"`
+
+	// Cores is number of instance cores allowed for each project.
+	Cores int `json:"cores"`
+
+	// Instances is number of instances allowed for each project.
+	Instances int `json:"instances"`
+
+	// ServerGroups is the number of ServerGroups allowed for the project.
+	ServerGroups int `json:"server_groups"`
+
+	// ServerGroupMembers is the number of members for each ServerGroup.
+	ServerGroupMembers int `json:"server_group_members"`
+}
+
+// QuotaDetailSet represents details of both operational limits of compute
+// resources and the current usage of those resources.
+type QuotaDetailSet struct {
+	// ID is the tenant ID associated with this QuotaDetailSet.
+	ID string `json:"id"`
+
+	// FixedIPs is number of fixed ips alloted this QuotaDetailSet.
+	FixedIPs QuotaDetail `json:"fixed_ips"`
+
+	// FloatingIPs is number of floating ips alloted this QuotaDetailSet.
+	FloatingIPs QuotaDetail `json:"floating_ips"`
+
+	// InjectedFileContentBytes is the allowed bytes for each injected file.
+	InjectedFileContentBytes QuotaDetail `json:"injected_file_content_bytes"`
+
+	// InjectedFilePathBytes is allowed bytes for each injected file path.
+	InjectedFilePathBytes QuotaDetail `json:"injected_file_path_bytes"`
+
+	// InjectedFiles is the number of injected files allowed for each project.
+	InjectedFiles QuotaDetail `json:"injected_files"`
+
+	// KeyPairs is number of ssh keypairs.
+	KeyPairs QuotaDetail `json:"key_pairs"`
+
+	// MetadataItems is number of metadata items allowed for each instance.
+	MetadataItems QuotaDetail `json:"metadata_items"`
+
+	// RAM is megabytes allowed for each instance.
+	RAM QuotaDetail `json:"ram"`
+
+	// SecurityGroupRules is number of security group rules allowed for each
+	// security group.
+	SecurityGroupRules QuotaDetail `json:"security_group_rules"`
+
+	// SecurityGroups is the number of security groups allowed for each project.
+	SecurityGroups QuotaDetail `json:"security_groups"`
+
+	// Cores is number of instance cores allowed for each project.
+	Cores QuotaDetail `json:"cores"`
+
+	// Instances is number of instances allowed for each project.
+	Instances QuotaDetail `json:"instances"`
+
+	// ServerGroups is the number of ServerGroups allowed for the project.
+	ServerGroups QuotaDetail `json:"server_groups"`
+
+	// ServerGroupMembers is the number of members for each ServerGroup.
+	ServerGroupMembers QuotaDetail `json:"server_group_members"`
+}
+
+// QuotaDetail is a set of details about a single operational limit that allows
+// for control of compute usage.
+type QuotaDetail struct {
+	// InUse is the current number of provisioned/allocated resources of the
+	// given type.
+	InUse int `json:"in_use"`
+
+	// Reserved is a transitional state when a claim against quota has been made
+	// but the resource is not yet fully online.
+	Reserved int `json:"reserved"`
+
+	// Limit is the maximum number of a given resource that can be
+	// allocated/provisioned.  This is what "quota" usually refers to.
+	Limit int `json:"limit"`
+}
+
+// QuotaSetPage stores a single page of all QuotaSet results from a List call.
+type QuotaSetPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a QuotaSetsetPage is empty.
+func (page QuotaSetPage) IsEmpty() (bool, error) {
+	ks, err := ExtractQuotaSets(page)
+	return len(ks) == 0, err
+}
+
+// ExtractQuotaSets interprets a page of results as a slice of QuotaSets.
+func ExtractQuotaSets(r pagination.Page) ([]QuotaSet, error) {
+	var s struct {
+		QuotaSets []QuotaSet `json:"quotas"`
+	}
+	err := (r.(QuotaSetPage)).ExtractInto(&s)
+	return s.QuotaSets, err
+}
+
+type quotaResult struct {
+	gophercloud.Result
+}
+
+// Extract is a method that attempts to interpret any QuotaSet resource response
+// as a QuotaSet struct.
+func (r quotaResult) Extract() (*QuotaSet, error) {
+	var s struct {
+		QuotaSet *QuotaSet `json:"quota_set"`
+	}
+	err := r.ExtractInto(&s)
+	return s.QuotaSet, err
+}
+
+// GetResult is the response from a Get operation. Call its Extract method to
+// interpret it as a QuotaSet.
+type GetResult struct {
+	quotaResult
+}
+
+// UpdateResult is the response from a Update operation. Call its Extract method
+// to interpret it as a QuotaSet.
+type UpdateResult struct {
+	quotaResult
+}
+
+// DeleteResult is the response from a Delete operation. Call its Extract method
+// to interpret it as a QuotaSet.
+type DeleteResult struct {
+	quotaResult
+}
+
+type quotaDetailResult struct {
+	gophercloud.Result
+}
+
+// GetDetailResult is the response from a Get operation. Call its Extract
+// method to interpret it as a QuotaSet.
+type GetDetailResult struct {
+	quotaDetailResult
+}
+
+// Extract is a method that attempts to interpret any QuotaDetailSet
+// resource response as a set of QuotaDetailSet structs.
+func (r quotaDetailResult) Extract() (QuotaDetailSet, error) {
+	var s struct {
+		QuotaData QuotaDetailSet `json:"quota_set"`
+	}
+	err := r.ExtractInto(&s)
+	return s.QuotaData, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/doc.go
new file mode 100644
index 000000000..30d864eb9
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/doc.go
@@ -0,0 +1,2 @@
+// quotasets unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/fixtures.go
new file mode 100644
index 000000000..c0955c5ca
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/fixtures.go
@@ -0,0 +1,215 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// GetOutput is a sample response to a Get call.
+const GetOutput = `
+{
+   "quota_set" : {
+      "instances" : 25,
+      "security_groups" : 10,
+      "security_group_rules" : 20,
+      "cores" : 200,
+      "injected_file_content_bytes" : 10240,
+      "injected_files" : 5,
+      "metadata_items" : 128,
+      "ram" : 9216000,
+      "key_pairs" : 10,
+      "injected_file_path_bytes" : 255,
+	  "server_groups" : 2,
+	  "server_group_members" : 3
+   }
+}
+`
+
+// GetDetailsOutput is a sample response to a Get call with the detailed option.
+const GetDetailsOutput = `
+{
+   "quota_set" : {
+	  "id": "555544443333222211110000ffffeeee",
+      "instances" : {
+          "in_use": 0,
+          "limit": 25,
+          "reserved": 0
+      },
+      "security_groups" : {
+          "in_use": 0,
+          "limit": 10,
+          "reserved": 0
+      },
+      "security_group_rules" : {
+          "in_use": 0,
+          "limit": 20,
+          "reserved": 0
+      },
+      "cores" : {
+          "in_use": 0,
+          "limit": 200,
+          "reserved": 0
+      },
+      "injected_file_content_bytes" : {
+          "in_use": 0,
+          "limit": 10240,
+          "reserved": 0
+      },
+      "injected_files" : {
+          "in_use": 0,
+          "limit": 5,
+          "reserved": 0
+      },
+      "metadata_items" : {
+          "in_use": 0,
+          "limit": 128,
+          "reserved": 0
+      },
+      "ram" : {
+          "in_use": 0,
+          "limit": 9216000,
+          "reserved": 0
+      },
+      "key_pairs" : {
+          "in_use": 0,
+          "limit": 10,
+          "reserved": 0
+      },
+      "injected_file_path_bytes" : {
+          "in_use": 0,
+          "limit": 255,
+          "reserved": 0
+      },
+      "server_groups" : {
+          "in_use": 0,
+          "limit": 2,
+          "reserved": 0
+      },
+      "server_group_members" : {
+          "in_use": 0,
+          "limit": 3,
+          "reserved": 0
+      }
+   }
+}
+`
+const FirstTenantID = "555544443333222211110000ffffeeee"
+
+// FirstQuotaSet is the first result in ListOutput.
+var FirstQuotaSet = quotasets.QuotaSet{
+	FixedIPs:                 0,
+	FloatingIPs:              0,
+	InjectedFileContentBytes: 10240,
+	InjectedFilePathBytes:    255,
+	InjectedFiles:            5,
+	KeyPairs:                 10,
+	MetadataItems:            128,
+	RAM:                      9216000,
+	SecurityGroupRules:       20,
+	SecurityGroups:           10,
+	Cores:                    200,
+	Instances:                25,
+	ServerGroups:             2,
+	ServerGroupMembers:       3,
+}
+
+// FirstQuotaDetailsSet is the first result in ListOutput.
+var FirstQuotaDetailsSet = quotasets.QuotaDetailSet{
+	ID:                       FirstTenantID,
+	InjectedFileContentBytes: quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 10240},
+	InjectedFilePathBytes:    quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 255},
+	InjectedFiles:            quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 5},
+	KeyPairs:                 quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 10},
+	MetadataItems:            quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 128},
+	RAM:                      quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 9216000},
+	SecurityGroupRules:       quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 20},
+	SecurityGroups:           quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 10},
+	Cores:                    quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 200},
+	Instances:                quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 25},
+	ServerGroups:             quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 2},
+	ServerGroupMembers:       quotasets.QuotaDetail{InUse: 0, Reserved: 0, Limit: 3},
+}
+
+//The expected update Body. Is also returned by PUT request
+const UpdateOutput = `{"quota_set":{"cores":200,"fixed_ips":0,"floating_ips":0,"injected_file_content_bytes":10240,"injected_file_path_bytes":255,"injected_files":5,"instances":25,"key_pairs":10,"metadata_items":128,"ram":9216000,"security_group_rules":20,"security_groups":10,"server_groups":2,"server_group_members":3}}`
+
+//The expected partialupdate Body. Is also returned by PUT request
+const PartialUpdateBody = `{"quota_set":{"cores":200, "force":true}}`
+
+//Result of Quota-update
+var UpdatedQuotaSet = quotasets.UpdateOpts{
+	FixedIPs:                 gophercloud.IntToPointer(0),
+	FloatingIPs:              gophercloud.IntToPointer(0),
+	InjectedFileContentBytes: gophercloud.IntToPointer(10240),
+	InjectedFilePathBytes:    gophercloud.IntToPointer(255),
+	InjectedFiles:            gophercloud.IntToPointer(5),
+	KeyPairs:                 gophercloud.IntToPointer(10),
+	MetadataItems:            gophercloud.IntToPointer(128),
+	RAM:                      gophercloud.IntToPointer(9216000),
+	SecurityGroupRules:       gophercloud.IntToPointer(20),
+	SecurityGroups:           gophercloud.IntToPointer(10),
+	Cores:                    gophercloud.IntToPointer(200),
+	Instances:                gophercloud.IntToPointer(25),
+	ServerGroups:             gophercloud.IntToPointer(2),
+	ServerGroupMembers:       gophercloud.IntToPointer(3),
+}
+
+// HandleGetSuccessfully configures the test server to respond to a Get request for sample tenant
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-quota-sets/"+FirstTenantID, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
+
+// HandleGetDetailSuccessfully configures the test server to respond to a Get Details request for sample tenant
+func HandleGetDetailSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-quota-sets/"+FirstTenantID+"/detail", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetDetailsOutput)
+	})
+}
+
+// HandlePutSuccessfully configures the test server to respond to a Put request for sample tenant
+func HandlePutSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-quota-sets/"+FirstTenantID, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "PUT")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, UpdateOutput)
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, UpdateOutput)
+	})
+}
+
+// HandlePartialPutSuccessfully configures the test server to respond to a Put request for sample tenant that only containes specific values
+func HandlePartialPutSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-quota-sets/"+FirstTenantID, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "PUT")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, PartialUpdateBody)
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, UpdateOutput)
+	})
+}
+
+// HandleDeleteSuccessfully configures the test server to respond to a Delete request for sample tenant
+func HandleDeleteSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-quota-sets/"+FirstTenantID, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestBody(t, r, "")
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(202)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/requests_test.go
new file mode 100644
index 000000000..ccac51b36
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/testing/requests_test.go
@@ -0,0 +1,73 @@
+package testing
+
+import (
+	"errors"
+	"testing"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSuccessfully(t)
+	actual, err := quotasets.Get(client.ServiceClient(), FirstTenantID).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &FirstQuotaSet, actual)
+}
+
+func TestGetDetail(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetDetailSuccessfully(t)
+	actual, err := quotasets.GetDetail(client.ServiceClient(), FirstTenantID).Extract()
+	th.CheckDeepEquals(t, FirstQuotaDetailsSet, actual)
+	th.AssertNoErr(t, err)
+}
+
+func TestUpdate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandlePutSuccessfully(t)
+	actual, err := quotasets.Update(client.ServiceClient(), FirstTenantID, UpdatedQuotaSet).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &FirstQuotaSet, actual)
+}
+
+func TestPartialUpdate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandlePartialPutSuccessfully(t)
+	opts := quotasets.UpdateOpts{Cores: gophercloud.IntToPointer(200), Force: true}
+	actual, err := quotasets.Update(client.ServiceClient(), FirstTenantID, opts).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &FirstQuotaSet, actual)
+}
+
+func TestDelete(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleDeleteSuccessfully(t)
+	_, err := quotasets.Delete(client.ServiceClient(), FirstTenantID).Extract()
+	th.AssertNoErr(t, err)
+}
+
+type ErrorUpdateOpts quotasets.UpdateOpts
+
+func (opts ErrorUpdateOpts) ToComputeQuotaUpdateMap() (map[string]interface{}, error) {
+	return nil, errors.New("This is an error")
+}
+
+func TestErrorInToComputeQuotaUpdateMap(t *testing.T) {
+	opts := &ErrorUpdateOpts{}
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandlePutSuccessfully(t)
+	_, err := quotasets.Update(client.ServiceClient(), FirstTenantID, opts).Extract()
+	if err == nil {
+		t.Fatal("Error handling failed")
+	}
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/urls.go
new file mode 100644
index 000000000..37e50215b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/quotasets/urls.go
@@ -0,0 +1,25 @@
+package quotasets
+
+import "github.com/gophercloud/gophercloud"
+
+const resourcePath = "os-quota-sets"
+
+func resourceURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(resourcePath)
+}
+
+func getURL(c *gophercloud.ServiceClient, tenantID string) string {
+	return c.ServiceURL(resourcePath, tenantID)
+}
+
+func getDetailURL(c *gophercloud.ServiceClient, tenantID string) string {
+	return c.ServiceURL(resourcePath, tenantID, "detail")
+}
+
+func updateURL(c *gophercloud.ServiceClient, tenantID string) string {
+	return getURL(c, tenantID)
+}
+
+func deleteURL(c *gophercloud.ServiceClient, tenantID string) string {
+	return getURL(c, tenantID)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/doc.go
new file mode 100644
index 000000000..1ab269b47
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/doc.go
@@ -0,0 +1,25 @@
+/*
+Package remoteconsoles provides the ability to create server remote consoles
+through the Compute API.
+You need to specify at least "2.6" microversion for the ComputeClient to use
+that API.
+
+Example of Creating a new RemoteConsole
+
+  computeClient, err := openstack.NewComputeV2(providerClient, endpointOptions)
+  computeClient.Microversion = "2.6"
+
+  createOpts := remoteconsoles.CreateOpts{
+    Protocol: remoteconsoles.ConsoleProtocolVNC,
+    Type:     remoteconsoles.ConsoleTypeNoVNC,
+  }
+  serverID := "b16ba811-199d-4ffd-8839-ba96c1185a67"
+
+  remtoteConsole, err := remoteconsoles.Create(computeClient, serverID, createOpts).Extract()
+  if err != nil {
+    panic(err)
+  }
+
+  fmt.Printf("Console URL: %s\n", remtoteConsole.URL)
+*/
+package remoteconsoles
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/requests.go
new file mode 100644
index 000000000..5c41035f7
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/requests.go
@@ -0,0 +1,83 @@
+package remoteconsoles
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// ConsoleProtocol represents valid remote console protocol.
+// It can be used to create a remote console with one of the pre-defined protocol.
+type ConsoleProtocol string
+
+const (
+	// ConsoleProtocolVNC represents the VNC console protocol.
+	ConsoleProtocolVNC ConsoleProtocol = "vnc"
+
+	// ConsoleProtocolSPICE represents the SPICE console protocol.
+	ConsoleProtocolSPICE ConsoleProtocol = "spice"
+
+	// ConsoleProtocolRDP represents the RDP console protocol.
+	ConsoleProtocolRDP ConsoleProtocol = "rdp"
+
+	// ConsoleProtocolSerial represents the Serial console protocol.
+	ConsoleProtocolSerial ConsoleProtocol = "serial"
+
+	// ConsoleProtocolMKS represents the MKS console protocol.
+	ConsoleProtocolMKS ConsoleProtocol = "mks"
+)
+
+// ConsoleType represents valid remote console type.
+// It can be used to create a remote console with one of the pre-defined type.
+type ConsoleType string
+
+const (
+	// ConsoleTypeNoVNC represents the VNC console type.
+	ConsoleTypeNoVNC ConsoleType = "novnc"
+
+	// ConsoleTypeXVPVNC represents the XVP VNC console type.
+	ConsoleTypeXVPVNC ConsoleType = "xvpvnc"
+
+	// ConsoleTypeRDPHTML5 represents the RDP HTML5 console type.
+	ConsoleTypeRDPHTML5 ConsoleType = "rdp-html5"
+
+	// ConsoleTypeSPICEHTML5 represents the SPICE HTML5 console type.
+	ConsoleTypeSPICEHTML5 ConsoleType = "spice-html5"
+
+	// ConsoleTypeSerial represents the Serial console type.
+	ConsoleTypeSerial ConsoleType = "serial"
+
+	// ConsoleTypeWebMKS represents the Web MKS console type.
+	ConsoleTypeWebMKS ConsoleType = "webmks"
+)
+
+// CreateOptsBuilder allows to add additional parameters to the Create request.
+type CreateOptsBuilder interface {
+	ToRemoteConsoleCreateMap() (map[string]interface{}, error)
+}
+
+// CreateOpts specifies parameters to the Create request.
+type CreateOpts struct {
+	// Protocol specifies the protocol of a new remote console.
+	Protocol ConsoleProtocol `json:"protocol" required:"true"`
+
+	// Type specifies the type of a new remote console.
+	Type ConsoleType `json:"type" required:"true"`
+}
+
+// ToRemoteConsoleCreateMap builds a request body from the CreateOpts.
+func (opts CreateOpts) ToRemoteConsoleCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "remote_console")
+}
+
+// Create requests the creation of a new remote console on the specified server.
+func Create(client *gophercloud.ServiceClient, serverID string, opts CreateOptsBuilder) (r CreateResult) {
+	reqBody, err := opts.ToRemoteConsoleCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+
+	_, r.Err = client.Post(createURL(client, serverID), reqBody, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/results.go
new file mode 100644
index 000000000..684c63708
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/results.go
@@ -0,0 +1,38 @@
+package remoteconsoles
+
+import "github.com/gophercloud/gophercloud"
+
+type commonResult struct {
+	gophercloud.Result
+}
+
+// CreateResult represents the result of a create operation. Call its Extract
+// method to interpret it as a RemoteConsole.
+type CreateResult struct {
+	commonResult
+}
+
+// RemoteConsole represents the Compute service remote console object.
+type RemoteConsole struct {
+	// Protocol contains remote console protocol.
+	// You can use the RemoteConsoleProtocol custom type to unmarshal raw JSON
+	// response into the pre-defined valid console protocol.
+	Protocol string `json:"protocol"`
+
+	// Type contains remote console type.
+	// You can use the RemoteConsoleType custom type to unmarshal raw JSON
+	// response into the pre-defined valid console type.
+	Type string `json:"type"`
+
+	// URL can be used to connect to the remote console.
+	URL string `json:"url"`
+}
+
+// Extract interprets any commonResult as a RemoteConsole.
+func (r commonResult) Extract() (*RemoteConsole, error) {
+	var s struct {
+		RemoteConsole *RemoteConsole `json:"remote_console"`
+	}
+	err := r.ExtractInto(&s)
+	return s.RemoteConsole, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/doc.go
new file mode 100644
index 000000000..7603f836a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/doc.go
@@ -0,0 +1 @@
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/fixtures.go
new file mode 100644
index 000000000..9644a4895
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/fixtures.go
@@ -0,0 +1,22 @@
+package testing
+
+// RemoteConsoleCreateRequest represents a request to create a remote console.
+const RemoteConsoleCreateRequest = `
+{
+    "remote_console": {
+        "protocol": "vnc",
+        "type": "novnc"
+    }
+}
+`
+
+// RemoteConsoleCreateResult represents a raw server responce to the RemoteConsoleCreateRequest.
+const RemoteConsoleCreateResult = `
+{
+    "remote_console": {
+        "protocol": "vnc",
+        "type": "novnc",
+        "url": "http://192.168.0.4:6080/vnc_auto.html?token=9a2372b9-6a0e-4f71-aca1-56020e6bb677"
+    }
+}
+`
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/requests_test.go
new file mode 100644
index 000000000..f0b2c8c4c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/testing/requests_test.go
@@ -0,0 +1,40 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	fake "github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestCreate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/b16ba811-199d-4ffd-8839-ba96c1185a67/remote-consoles", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+		th.TestHeader(t, r, "Content-Type", "application/json")
+		th.TestHeader(t, r, "Accept", "application/json")
+		th.TestJSONRequest(t, r, RemoteConsoleCreateRequest)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, RemoteConsoleCreateResult)
+	})
+
+	opts := remoteconsoles.CreateOpts{
+		Protocol: remoteconsoles.ConsoleProtocolVNC,
+		Type:     remoteconsoles.ConsoleTypeNoVNC,
+	}
+	s, err := remoteconsoles.Create(fake.ServiceClient(), "b16ba811-199d-4ffd-8839-ba96c1185a67", opts).Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertEquals(t, s.Protocol, string(remoteconsoles.ConsoleProtocolVNC))
+	th.AssertEquals(t, s.Type, string(remoteconsoles.ConsoleTypeNoVNC))
+	th.AssertEquals(t, s.URL, "http://192.168.0.4:6080/vnc_auto.html?token=9a2372b9-6a0e-4f71-aca1-56020e6bb677")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/urls.go
new file mode 100644
index 000000000..b4d7ec2bb
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/remoteconsoles/urls.go
@@ -0,0 +1,17 @@
+package remoteconsoles
+
+import "github.com/gophercloud/gophercloud"
+
+const (
+	rootPath = "servers"
+
+	resourcePath = "remote-consoles"
+)
+
+func rootURL(c *gophercloud.ServiceClient, serverID string) string {
+	return c.ServiceURL(rootPath, serverID, resourcePath)
+}
+
+func createURL(c *gophercloud.ServiceClient, serverID string) string {
+	return rootURL(c, serverID)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/doc.go
new file mode 100644
index 000000000..2081018cd
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/doc.go
@@ -0,0 +1,28 @@
+/*
+Package rescueunrescue provides the ability to place a server into rescue mode
+and to return it back.
+
+Example to Rescue a server
+
+  rescueOpts := rescueunrescue.RescueOpts{
+    AdminPass:      "aUPtawPzE9NU",
+    RescueImageRef: "115e5c5b-72f0-4a0a-9067-60706545248c",
+  }
+  serverID := "3f54d05f-3430-4d80-aa07-63e6af9e2488"
+
+  adminPass, err := rescueunrescue.Rescue(computeClient, serverID, rescueOpts).Extract()
+  if err != nil {
+    panic(err)
+  }
+
+  fmt.Printf("adminPass of the rescued server %s: %s\n", serverID, adminPass)
+
+Example to Unrescue a server
+
+  serverID := "3f54d05f-3430-4d80-aa07-63e6af9e2488"
+
+  if err := rescueunrescue.Unrescue(computeClient, serverID).ExtractErr(); err != nil {
+    panic(err)
+  }
+*/
+package rescueunrescue
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/requests.go
new file mode 100644
index 000000000..fd7534b97
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/requests.go
@@ -0,0 +1,51 @@
+package rescueunrescue
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// RescueOptsBuilder is an interface that allows extensions to override the
+// default structure of a Rescue request.
+type RescueOptsBuilder interface {
+	ToServerRescueMap() (map[string]interface{}, error)
+}
+
+// RescueOpts represents the configuration options used to control a Rescue
+// option.
+type RescueOpts struct {
+	// AdminPass is the desired administrative password for the instance in
+	// RESCUE mode.
+	// If it's left blank, the server will generate a password.
+	AdminPass string `json:"adminPass,omitempty"`
+
+	// RescueImageRef contains reference on an image that needs to be used as
+	// rescue image.
+	// If it's left blank, the server will be rescued with the default image.
+	RescueImageRef string `json:"rescue_image_ref,omitempty"`
+}
+
+// ToServerRescueMap formats a RescueOpts as a map that can be used as a JSON
+// request body for the Rescue request.
+func (opts RescueOpts) ToServerRescueMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "rescue")
+}
+
+// Rescue instructs the provider to place the server into RESCUE mode.
+func Rescue(client *gophercloud.ServiceClient, id string, opts RescueOptsBuilder) (r RescueResult) {
+	b, err := opts.ToServerRescueMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(extensions.ActionURL(client, id), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Unrescue instructs the provider to return the server from RESCUE mode.
+func Unrescue(client *gophercloud.ServiceClient, id string) (r UnrescueResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"unrescue": nil}, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/results.go
new file mode 100644
index 000000000..1966b15c4
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/results.go
@@ -0,0 +1,28 @@
+package rescueunrescue
+
+import "github.com/gophercloud/gophercloud"
+
+type commonResult struct {
+	gophercloud.Result
+}
+
+// RescueResult is the response from a Rescue operation. Call its Extract
+// method to retrieve adminPass for a rescued server.
+type RescueResult struct {
+	commonResult
+}
+
+// UnrescueResult is the response from an UnRescue operation. Call its ExtractErr
+// method to determine if the call succeeded or failed.
+type UnrescueResult struct {
+	gophercloud.ErrResult
+}
+
+// Extract interprets any RescueResult as an AdminPass, if possible.
+func (r RescueResult) Extract() (string, error) {
+	var s struct {
+		AdminPass string `json:"adminPass"`
+	}
+	err := r.ExtractInto(&s)
+	return s.AdminPass, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/doc.go
new file mode 100644
index 000000000..7603f836a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/doc.go
@@ -0,0 +1 @@
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/fixtures.go
new file mode 100644
index 000000000..c822193d6
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/fixtures.go
@@ -0,0 +1,25 @@
+package testing
+
+// RescueRequest represents request to rescue a server.
+const RescueRequest = `
+{
+    "rescue": {
+        "adminPass": "aUPtawPzE9NU",
+        "rescue_image_ref": "115e5c5b-72f0-4a0a-9067-60706545248c"
+    }
+}
+`
+
+// RescueResult represents a raw server response to a RescueRequest.
+const RescueResult = `
+{
+	"adminPass": "aUPtawPzE9NU"
+}
+`
+
+// UnrescueRequest represents request to unrescue a server.
+const UnrescueRequest = `
+{
+    "unrescue": null
+}
+`
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/requests_test.go
new file mode 100644
index 000000000..fda9023e2
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue/testing/requests_test.go
@@ -0,0 +1,49 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/rescueunrescue"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	fake "github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestRescue(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/3f54d05f-3430-4d80-aa07-63e6af9e2488/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+		th.TestJSONRequest(t, r, RescueRequest)
+
+		w.WriteHeader(http.StatusOK)
+		fmt.Fprintf(w, RescueResult)
+	})
+
+	s, err := rescueunrescue.Rescue(fake.ServiceClient(), "3f54d05f-3430-4d80-aa07-63e6af9e2488", rescueunrescue.RescueOpts{
+		AdminPass:      "aUPtawPzE9NU",
+		RescueImageRef: "115e5c5b-72f0-4a0a-9067-60706545248c",
+	}).Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertEquals(t, "aUPtawPzE9NU", s)
+}
+
+func TestUnrescue(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/3f54d05f-3430-4d80-aa07-63e6af9e2488/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+		th.TestJSONRequest(t, r, UnrescueRequest)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+
+	err := rescueunrescue.Unrescue(fake.ServiceClient(), "3f54d05f-3430-4d80-aa07-63e6af9e2488").ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/doc.go
new file mode 100644
index 000000000..00f004b02
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/doc.go
@@ -0,0 +1,13 @@
+/*
+Package resetstate provides functionality to reset the state of a server that has
+been provisioned by the OpenStack Compute service.
+
+Example to Reset a Server
+
+	serverID := "47b6b7b7-568d-40e4-868c-d5c41735532e"
+	err := resetstate.ResetState(client, id, resetstate.StateActive).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package resetstate
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/requests.go
new file mode 100644
index 000000000..e98ba32bd
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/requests.go
@@ -0,0 +1,24 @@
+package resetstate
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// ServerState refers to the states usable in ResetState Action
+type ServerState string
+
+const (
+	// StateActive returns the state of the server as active
+	StateActive ServerState = "active"
+
+	// StateError returns the state of the server as error
+	StateError ServerState = "error"
+)
+
+// ResetState will reset the state of a server
+func ResetState(client *gophercloud.ServiceClient, id string, state ServerState) (r ResetResult) {
+	stateMap := map[string]interface{}{"state": state}
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"os-resetState": stateMap}, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/results.go
new file mode 100644
index 000000000..ddeb3519a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/results.go
@@ -0,0 +1,11 @@
+package resetstate
+
+import (
+	"github.com/gophercloud/gophercloud"
+)
+
+// ResetResult is the response of a ResetState operation. Call its ExtractErr
+// method to determine if the request suceeded or failed.
+type ResetResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/doc.go
new file mode 100644
index 000000000..7603f836a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/doc.go
@@ -0,0 +1 @@
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/fixtures.go
new file mode 100644
index 000000000..857a8b212
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/fixtures.go
@@ -0,0 +1,19 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func mockResetStateResponse(t *testing.T, id string, state string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, fmt.Sprintf(`{"os-resetState": {"state": "%s"}}`, state))
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/requests_test.go
new file mode 100644
index 000000000..491a7ee1f
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate/testing/requests_test.go
@@ -0,0 +1,21 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/resetstate"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const serverID = "b16ba811-199d-4ffd-8839-ba96c1185a67"
+
+func TestResetState(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockResetStateResponse(t, serverID, "active")
+
+	err := resetstate.ResetState(client.ServiceClient(), serverID, "active").ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/doc.go
new file mode 100644
index 000000000..2d9d3acde
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/doc.go
@@ -0,0 +1,76 @@
+/*
+Package schedulerhints extends the server create request with the ability to
+specify additional parameters which determine where the server will be
+created in the OpenStack cloud.
+
+Example to Add a Server to a Server Group
+
+	schedulerHints := schedulerhints.SchedulerHints{
+		Group: "servergroup-uuid",
+	}
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_name",
+		ImageRef:  "image-uuid",
+		FlavorRef: "flavor-uuid",
+	}
+
+	createOpts := schedulerhints.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		SchedulerHints:    schedulerHints,
+	}
+
+	server, err := servers.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Place Server B on a Different Host than Server A
+
+	schedulerHints := schedulerhints.SchedulerHints{
+		DifferentHost: []string{
+			"server-a-uuid",
+		}
+	}
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_b",
+		ImageRef:  "image-uuid",
+		FlavorRef: "flavor-uuid",
+	}
+
+	createOpts := schedulerhints.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		SchedulerHints:    schedulerHints,
+	}
+
+	server, err := servers.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Place Server B on the Same Host as Server A
+
+	schedulerHints := schedulerhints.SchedulerHints{
+		SameHost: []string{
+			"server-a-uuid",
+		}
+	}
+
+	serverCreateOpts := servers.CreateOpts{
+		Name:      "server_b",
+		ImageRef:  "image-uuid",
+		FlavorRef: "flavor-uuid",
+	}
+
+	createOpts := schedulerhints.CreateOptsExt{
+		CreateOptsBuilder: serverCreateOpts,
+		SchedulerHints:    schedulerHints,
+	}
+
+	server, err := servers.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+*/
+package schedulerhints
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/requests.go
new file mode 100644
index 000000000..963934507
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/requests.go
@@ -0,0 +1,176 @@
+package schedulerhints
+
+import (
+	"encoding/json"
+	"net"
+	"regexp"
+	"strings"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+)
+
+// SchedulerHints represents a set of scheduling hints that are passed to the
+// OpenStack scheduler.
+type SchedulerHints struct {
+	// Group specifies a Server Group to place the instance in.
+	Group string
+
+	// DifferentHost will place the instance on a compute node that does not
+	// host the given instances.
+	DifferentHost []string
+
+	// SameHost will place the instance on a compute node that hosts the given
+	// instances.
+	SameHost []string
+
+	// Query is a conditional statement that results in compute nodes able to
+	// host the instance.
+	Query []interface{}
+
+	// TargetCell specifies a cell name where the instance will be placed.
+	TargetCell string `json:"target_cell,omitempty"`
+
+	// BuildNearHostIP specifies a subnet of compute nodes to host the instance.
+	BuildNearHostIP string
+
+	// AdditionalProperies are arbitrary key/values that are not validated by nova.
+	AdditionalProperties map[string]interface{}
+}
+
+// CreateOptsBuilder builds the scheduler hints into a serializable format.
+type CreateOptsBuilder interface {
+	ToServerSchedulerHintsCreateMap() (map[string]interface{}, error)
+}
+
+// ToServerSchedulerHintsMap builds the scheduler hints into a serializable format.
+func (opts SchedulerHints) ToServerSchedulerHintsCreateMap() (map[string]interface{}, error) {
+	sh := make(map[string]interface{})
+
+	uuidRegex, _ := regexp.Compile("^[a-z0-9]{8}-[a-z0-9]{4}-[1-5][a-z0-9]{3}-[a-z0-9]{4}-[a-z0-9]{12}$")
+
+	if opts.Group != "" {
+		if !uuidRegex.MatchString(opts.Group) {
+			err := gophercloud.ErrInvalidInput{}
+			err.Argument = "schedulerhints.SchedulerHints.Group"
+			err.Value = opts.Group
+			err.Info = "Group must be a UUID"
+			return nil, err
+		}
+		sh["group"] = opts.Group
+	}
+
+	if len(opts.DifferentHost) > 0 {
+		for _, diffHost := range opts.DifferentHost {
+			if !uuidRegex.MatchString(diffHost) {
+				err := gophercloud.ErrInvalidInput{}
+				err.Argument = "schedulerhints.SchedulerHints.DifferentHost"
+				err.Value = opts.DifferentHost
+				err.Info = "The hosts must be in UUID format."
+				return nil, err
+			}
+		}
+		sh["different_host"] = opts.DifferentHost
+	}
+
+	if len(opts.SameHost) > 0 {
+		for _, sameHost := range opts.SameHost {
+			if !uuidRegex.MatchString(sameHost) {
+				err := gophercloud.ErrInvalidInput{}
+				err.Argument = "schedulerhints.SchedulerHints.SameHost"
+				err.Value = opts.SameHost
+				err.Info = "The hosts must be in UUID format."
+				return nil, err
+			}
+		}
+		sh["same_host"] = opts.SameHost
+	}
+
+	/*
+		Query can be something simple like:
+			 [">=", "$free_ram_mb", 1024]
+
+			Or more complex like:
+				['and',
+					['>=', '$free_ram_mb', 1024],
+					['>=', '$free_disk_mb', 200 * 1024]
+				]
+
+		Because of the possible complexity, just make sure the length is a minimum of 3.
+	*/
+	if len(opts.Query) > 0 {
+		if len(opts.Query) < 3 {
+			err := gophercloud.ErrInvalidInput{}
+			err.Argument = "schedulerhints.SchedulerHints.Query"
+			err.Value = opts.Query
+			err.Info = "Must be a conditional statement in the format of [op,variable,value]"
+			return nil, err
+		}
+
+		// The query needs to be sent as a marshalled string.
+		b, err := json.Marshal(opts.Query)
+		if err != nil {
+			err := gophercloud.ErrInvalidInput{}
+			err.Argument = "schedulerhints.SchedulerHints.Query"
+			err.Value = opts.Query
+			err.Info = "Must be a conditional statement in the format of [op,variable,value]"
+			return nil, err
+		}
+
+		sh["query"] = string(b)
+	}
+
+	if opts.TargetCell != "" {
+		sh["target_cell"] = opts.TargetCell
+	}
+
+	if opts.BuildNearHostIP != "" {
+		if _, _, err := net.ParseCIDR(opts.BuildNearHostIP); err != nil {
+			err := gophercloud.ErrInvalidInput{}
+			err.Argument = "schedulerhints.SchedulerHints.BuildNearHostIP"
+			err.Value = opts.BuildNearHostIP
+			err.Info = "Must be a valid subnet in the form 192.168.1.1/24"
+			return nil, err
+		}
+		ipParts := strings.Split(opts.BuildNearHostIP, "/")
+		sh["build_near_host_ip"] = ipParts[0]
+		sh["cidr"] = "/" + ipParts[1]
+	}
+
+	if opts.AdditionalProperties != nil {
+		for k, v := range opts.AdditionalProperties {
+			sh[k] = v
+		}
+	}
+
+	return sh, nil
+}
+
+// CreateOptsExt adds a SchedulerHints option to the base CreateOpts.
+type CreateOptsExt struct {
+	servers.CreateOptsBuilder
+
+	// SchedulerHints provides a set of hints to the scheduler.
+	SchedulerHints CreateOptsBuilder
+}
+
+// ToServerCreateMap adds the SchedulerHints option to the base server creation options.
+func (opts CreateOptsExt) ToServerCreateMap() (map[string]interface{}, error) {
+	base, err := opts.CreateOptsBuilder.ToServerCreateMap()
+	if err != nil {
+		return nil, err
+	}
+
+	schedulerHints, err := opts.SchedulerHints.ToServerSchedulerHintsCreateMap()
+	if err != nil {
+		return nil, err
+	}
+
+	if len(schedulerHints) == 0 {
+		return base, nil
+	}
+
+	base["os:scheduler_hints"] = schedulerHints
+
+	return base, nil
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/testing/doc.go
new file mode 100644
index 000000000..1915aef2f
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/testing/doc.go
@@ -0,0 +1,2 @@
+// schedulerhints unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/testing/requests_test.go
new file mode 100644
index 000000000..393c0f73c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints/testing/requests_test.go
@@ -0,0 +1,125 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/schedulerhints"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+	th "github.com/gophercloud/gophercloud/testhelper"
+)
+
+func TestCreateOpts(t *testing.T) {
+	base := servers.CreateOpts{
+		Name:      "createdserver",
+		ImageRef:  "asdfasdfasdf",
+		FlavorRef: "performance1-1",
+	}
+
+	schedulerHints := schedulerhints.SchedulerHints{
+		Group: "101aed42-22d9-4a3e-9ba1-21103b0d1aba",
+		DifferentHost: []string{
+			"a0cf03a5-d921-4877-bb5c-86d26cf818e1",
+			"8c19174f-4220-44f0-824a-cd1eeef10287",
+		},
+		SameHost: []string{
+			"a0cf03a5-d921-4877-bb5c-86d26cf818e1",
+			"8c19174f-4220-44f0-824a-cd1eeef10287",
+		},
+		Query:                []interface{}{"=", "$free_ram_mb", "1024"},
+		TargetCell:           "foobar",
+		BuildNearHostIP:      "192.168.1.1/24",
+		AdditionalProperties: map[string]interface{}{"reservation": "a0cf03a5-d921-4877-bb5c-86d26cf818e1"},
+	}
+
+	ext := schedulerhints.CreateOptsExt{
+		CreateOptsBuilder: base,
+		SchedulerHints:    schedulerHints,
+	}
+
+	expected := `
+		{
+			"server": {
+				"name": "createdserver",
+				"imageRef": "asdfasdfasdf",
+				"flavorRef": "performance1-1"
+			},
+			"os:scheduler_hints": {
+				"group": "101aed42-22d9-4a3e-9ba1-21103b0d1aba",
+				"different_host": [
+					"a0cf03a5-d921-4877-bb5c-86d26cf818e1",
+					"8c19174f-4220-44f0-824a-cd1eeef10287"
+				],
+				"same_host": [
+					"a0cf03a5-d921-4877-bb5c-86d26cf818e1",
+					"8c19174f-4220-44f0-824a-cd1eeef10287"
+				],
+				"query": "[\"=\",\"$free_ram_mb\",\"1024\"]",
+				"target_cell": "foobar",
+				"build_near_host_ip": "192.168.1.1",
+				"cidr": "/24",
+				"reservation": "a0cf03a5-d921-4877-bb5c-86d26cf818e1"
+			}
+		}
+	`
+	actual, err := ext.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, expected, actual)
+}
+
+func TestCreateOptsWithComplexQuery(t *testing.T) {
+	base := servers.CreateOpts{
+		Name:      "createdserver",
+		ImageRef:  "asdfasdfasdf",
+		FlavorRef: "performance1-1",
+	}
+
+	schedulerHints := schedulerhints.SchedulerHints{
+		Group: "101aed42-22d9-4a3e-9ba1-21103b0d1aba",
+		DifferentHost: []string{
+			"a0cf03a5-d921-4877-bb5c-86d26cf818e1",
+			"8c19174f-4220-44f0-824a-cd1eeef10287",
+		},
+		SameHost: []string{
+			"a0cf03a5-d921-4877-bb5c-86d26cf818e1",
+			"8c19174f-4220-44f0-824a-cd1eeef10287",
+		},
+		Query:                []interface{}{"and", []string{"=", "$free_ram_mb", "1024"}, []string{"=", "$free_disk_mb", "204800"}},
+		TargetCell:           "foobar",
+		BuildNearHostIP:      "192.168.1.1/24",
+		AdditionalProperties: map[string]interface{}{"reservation": "a0cf03a5-d921-4877-bb5c-86d26cf818e1"},
+	}
+
+	ext := schedulerhints.CreateOptsExt{
+		CreateOptsBuilder: base,
+		SchedulerHints:    schedulerHints,
+	}
+
+	expected := `
+		{
+			"server": {
+				"name": "createdserver",
+				"imageRef": "asdfasdfasdf",
+				"flavorRef": "performance1-1"
+			},
+			"os:scheduler_hints": {
+				"group": "101aed42-22d9-4a3e-9ba1-21103b0d1aba",
+				"different_host": [
+					"a0cf03a5-d921-4877-bb5c-86d26cf818e1",
+					"8c19174f-4220-44f0-824a-cd1eeef10287"
+				],
+				"same_host": [
+					"a0cf03a5-d921-4877-bb5c-86d26cf818e1",
+					"8c19174f-4220-44f0-824a-cd1eeef10287"
+				],
+				"query": "[\"and\",[\"=\",\"$free_ram_mb\",\"1024\"],[\"=\",\"$free_disk_mb\",\"204800\"]]",
+				"target_cell": "foobar",
+				"build_near_host_ip": "192.168.1.1",
+				"cidr": "/24",
+				"reservation": "a0cf03a5-d921-4877-bb5c-86d26cf818e1"
+			}
+		}
+	`
+	actual, err := ext.ToServerCreateMap()
+	th.AssertNoErr(t, err)
+	th.CheckJSONEquals(t, expected, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/doc.go
new file mode 100644
index 000000000..8d3ebf2e5
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/doc.go
@@ -0,0 +1,112 @@
+/*
+Package secgroups provides the ability to manage security groups through the
+Nova API.
+
+This API has been deprecated and will be removed from a future release of the
+Nova API service.
+
+For environments that support this extension, this package can be used
+regardless of if either Neutron or nova-network is used as the cloud's network
+service.
+
+Example to List Security Groups
+
+	allPages, err := secroups.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allSecurityGroups, err := secgroups.ExtractSecurityGroups(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, sg := range allSecurityGroups {
+		fmt.Printf("%+v\n", sg)
+	}
+
+Example to List Security Groups by Server
+
+	serverID := "aab3ad01-9956-4623-a29b-24afc89a7d36"
+
+	allPages, err := secroups.ListByServer(computeClient, serverID).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allSecurityGroups, err := secgroups.ExtractSecurityGroups(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, sg := range allSecurityGroups {
+		fmt.Printf("%+v\n", sg)
+	}
+
+Example to Create a Security Group
+
+	createOpts := secgroups.CreateOpts{
+		Name:        "group_name",
+		Description: "A Security Group",
+	}
+
+	sg, err := secgroups.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Create a Security Group Rule
+
+	sgID := "37d94f8a-d136-465c-ae46-144f0d8ef141"
+
+	createOpts := secgroups.CreateRuleOpts{
+		ParentGroupID: sgID,
+		FromPort:      22,
+		ToPort:        22,
+		IPProtocol:    "tcp",
+		CIDR:          "0.0.0.0/0",
+	}
+
+	rule, err := secgroups.CreateRule(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Add a Security Group to a Server
+
+	serverID := "aab3ad01-9956-4623-a29b-24afc89a7d36"
+	sgID := "37d94f8a-d136-465c-ae46-144f0d8ef141"
+
+	err := secgroups.AddServer(computeClient, serverID, sgID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Remove a Security Group from a Server
+
+	serverID := "aab3ad01-9956-4623-a29b-24afc89a7d36"
+	sgID := "37d94f8a-d136-465c-ae46-144f0d8ef141"
+
+	err := secgroups.RemoveServer(computeClient, serverID, sgID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Delete a Security Group
+
+
+	sgID := "37d94f8a-d136-465c-ae46-144f0d8ef141"
+	err := secgroups.Delete(computeClient, sgID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Delete a Security Group Rule
+
+	ruleID := "6221fe3e-383d-46c9-a3a6-845e66c1e8b4"
+	err := secgroups.DeleteRule(computeClient, ruleID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package secgroups
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/requests.go
new file mode 100644
index 000000000..92a0331e1
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/requests.go
@@ -0,0 +1,183 @@
+package secgroups
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+func commonList(client *gophercloud.ServiceClient, url string) pagination.Pager {
+	return pagination.NewPager(client, url, func(r pagination.PageResult) pagination.Page {
+		return SecurityGroupPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// List will return a collection of all the security groups for a particular
+// tenant.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return commonList(client, rootURL(client))
+}
+
+// ListByServer will return a collection of all the security groups which are
+// associated with a particular server.
+func ListByServer(client *gophercloud.ServiceClient, serverID string) pagination.Pager {
+	return commonList(client, listByServerURL(client, serverID))
+}
+
+// CreateOpts is the struct responsible for creating a security group.
+type CreateOpts struct {
+	// the name of your security group.
+	Name string `json:"name" required:"true"`
+	// the description of your security group.
+	Description string `json:"description,omitempty"`
+}
+
+// CreateOptsBuilder allows extensions to add additional parameters to the
+// Create request.
+type CreateOptsBuilder interface {
+	ToSecGroupCreateMap() (map[string]interface{}, error)
+}
+
+// ToSecGroupCreateMap builds a request body from CreateOpts.
+func (opts CreateOpts) ToSecGroupCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "security_group")
+}
+
+// Create will create a new security group.
+func Create(client *gophercloud.ServiceClient, opts CreateOptsBuilder) (r CreateResult) {
+	b, err := opts.ToSecGroupCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(rootURL(client), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// UpdateOpts is the struct responsible for updating an existing security group.
+type UpdateOpts struct {
+	// the name of your security group.
+	Name string `json:"name,omitempty"`
+	// the description of your security group.
+	Description *string `json:"description,omitempty"`
+}
+
+// UpdateOptsBuilder allows extensions to add additional parameters to the
+// Update request.
+type UpdateOptsBuilder interface {
+	ToSecGroupUpdateMap() (map[string]interface{}, error)
+}
+
+// ToSecGroupUpdateMap builds a request body from UpdateOpts.
+func (opts UpdateOpts) ToSecGroupUpdateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "security_group")
+}
+
+// Update will modify the mutable properties of a security group, notably its
+// name and description.
+func Update(client *gophercloud.ServiceClient, id string, opts UpdateOptsBuilder) (r UpdateResult) {
+	b, err := opts.ToSecGroupUpdateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Put(resourceURL(client, id), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Get will return details for a particular security group.
+func Get(client *gophercloud.ServiceClient, id string) (r GetResult) {
+	_, r.Err = client.Get(resourceURL(client, id), &r.Body, nil)
+	return
+}
+
+// Delete will permanently delete a security group from the project.
+func Delete(client *gophercloud.ServiceClient, id string) (r DeleteResult) {
+	_, r.Err = client.Delete(resourceURL(client, id), nil)
+	return
+}
+
+// CreateRuleOpts represents the configuration for adding a new rule to an
+// existing security group.
+type CreateRuleOpts struct {
+	// ID is the ID of the group that this rule will be added to.
+	ParentGroupID string `json:"parent_group_id" required:"true"`
+
+	// FromPort is the lower bound of the port range that will be opened.
+	// Use -1 to allow all ICMP traffic.
+	FromPort int `json:"from_port"`
+
+	// ToPort is the upper bound of the port range that will be opened.
+	// Use -1 to allow all ICMP traffic.
+	ToPort int `json:"to_port"`
+
+	// IPProtocol the protocol type that will be allowed, e.g. TCP.
+	IPProtocol string `json:"ip_protocol" required:"true"`
+
+	// CIDR is the network CIDR to allow traffic from.
+	// This is ONLY required if FromGroupID is blank. This represents the IP
+	// range that will be the source of network traffic to your security group.
+	// Use 0.0.0.0/0 to allow all IP addresses.
+	CIDR string `json:"cidr,omitempty" or:"FromGroupID"`
+
+	// FromGroupID represents another security group to allow access.
+	// This is ONLY required if CIDR is blank. This value represents the ID of a
+	// group that forwards traffic to the parent group. So, instead of accepting
+	// network traffic from an entire IP range, you can instead refine the
+	// inbound source by an existing security group.
+	FromGroupID string `json:"group_id,omitempty" or:"CIDR"`
+}
+
+// CreateRuleOptsBuilder allows extensions to add additional parameters to the
+// CreateRule request.
+type CreateRuleOptsBuilder interface {
+	ToRuleCreateMap() (map[string]interface{}, error)
+}
+
+// ToRuleCreateMap builds a request body from CreateRuleOpts.
+func (opts CreateRuleOpts) ToRuleCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "security_group_rule")
+}
+
+// CreateRule will add a new rule to an existing security group (whose ID is
+// specified in CreateRuleOpts). You have the option of controlling inbound
+// traffic from either an IP range (CIDR) or from another security group.
+func CreateRule(client *gophercloud.ServiceClient, opts CreateRuleOptsBuilder) (r CreateRuleResult) {
+	b, err := opts.ToRuleCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(rootRuleURL(client), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// DeleteRule will permanently delete a rule from a security group.
+func DeleteRule(client *gophercloud.ServiceClient, id string) (r DeleteRuleResult) {
+	_, r.Err = client.Delete(resourceRuleURL(client, id), nil)
+	return
+}
+
+func actionMap(prefix, groupName string) map[string]map[string]string {
+	return map[string]map[string]string{
+		prefix + "SecurityGroup": map[string]string{"name": groupName},
+	}
+}
+
+// AddServer will associate a server and a security group, enforcing the
+// rules of the group on the server.
+func AddServer(client *gophercloud.ServiceClient, serverID, groupName string) (r AddServerResult) {
+	_, r.Err = client.Post(serverActionURL(client, serverID), actionMap("add", groupName), nil, nil)
+	return
+}
+
+// RemoveServer will disassociate a server from a security group.
+func RemoveServer(client *gophercloud.ServiceClient, serverID, groupName string) (r RemoveServerResult) {
+	_, r.Err = client.Post(serverActionURL(client, serverID), actionMap("remove", groupName), nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/results.go
new file mode 100644
index 000000000..046889220
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/results.go
@@ -0,0 +1,214 @@
+package secgroups
+
+import (
+	"encoding/json"
+	"strconv"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// SecurityGroup represents a security group.
+type SecurityGroup struct {
+	// The unique ID of the group. If Neutron is installed, this ID will be
+	// represented as a string UUID; if Neutron is not installed, it will be a
+	// numeric ID. For the sake of consistency, we always cast it to a string.
+	ID string `json:"-"`
+
+	// The human-readable name of the group, which needs to be unique.
+	Name string `json:"name"`
+
+	// The human-readable description of the group.
+	Description string `json:"description"`
+
+	// The rules which determine how this security group operates.
+	Rules []Rule `json:"rules"`
+
+	// The ID of the tenant to which this security group belongs.
+	TenantID string `json:"tenant_id"`
+}
+
+func (r *SecurityGroup) UnmarshalJSON(b []byte) error {
+	type tmp SecurityGroup
+	var s struct {
+		tmp
+		ID interface{} `json:"id"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+
+	*r = SecurityGroup(s.tmp)
+
+	switch t := s.ID.(type) {
+	case float64:
+		r.ID = strconv.FormatFloat(t, 'f', -1, 64)
+	case string:
+		r.ID = t
+	}
+
+	return err
+}
+
+// Rule represents a security group rule, a policy which determines how a
+// security group operates and what inbound traffic it allows in.
+type Rule struct {
+	// The unique ID. If Neutron is installed, this ID will be
+	// represented as a string UUID; if Neutron is not installed, it will be a
+	// numeric ID. For the sake of consistency, we always cast it to a string.
+	ID string `json:"-"`
+
+	// The lower bound of the port range which this security group should open up.
+	FromPort int `json:"from_port"`
+
+	// The upper bound of the port range which this security group should open up.
+	ToPort int `json:"to_port"`
+
+	// The IP protocol (e.g. TCP) which the security group accepts.
+	IPProtocol string `json:"ip_protocol"`
+
+	// The CIDR IP range whose traffic can be received.
+	IPRange IPRange `json:"ip_range"`
+
+	// The security group ID to which this rule belongs.
+	ParentGroupID string `json:"-"`
+
+	// Not documented.
+	Group Group
+}
+
+func (r *Rule) UnmarshalJSON(b []byte) error {
+	type tmp Rule
+	var s struct {
+		tmp
+		ID            interface{} `json:"id"`
+		ParentGroupID interface{} `json:"parent_group_id"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+
+	*r = Rule(s.tmp)
+
+	switch t := s.ID.(type) {
+	case float64:
+		r.ID = strconv.FormatFloat(t, 'f', -1, 64)
+	case string:
+		r.ID = t
+	}
+
+	switch t := s.ParentGroupID.(type) {
+	case float64:
+		r.ParentGroupID = strconv.FormatFloat(t, 'f', -1, 64)
+	case string:
+		r.ParentGroupID = t
+	}
+
+	return err
+}
+
+// IPRange represents the IP range whose traffic will be accepted by the
+// security group.
+type IPRange struct {
+	CIDR string
+}
+
+// Group represents a group.
+type Group struct {
+	TenantID string `json:"tenant_id"`
+	Name     string
+}
+
+// SecurityGroupPage is a single page of a SecurityGroup collection.
+type SecurityGroupPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a page of Security Groups contains any
+// results.
+func (page SecurityGroupPage) IsEmpty() (bool, error) {
+	users, err := ExtractSecurityGroups(page)
+	return len(users) == 0, err
+}
+
+// ExtractSecurityGroups returns a slice of SecurityGroups contained in a
+// single page of results.
+func ExtractSecurityGroups(r pagination.Page) ([]SecurityGroup, error) {
+	var s struct {
+		SecurityGroups []SecurityGroup `json:"security_groups"`
+	}
+	err := (r.(SecurityGroupPage)).ExtractInto(&s)
+	return s.SecurityGroups, err
+}
+
+type commonResult struct {
+	gophercloud.Result
+}
+
+// CreateResult represents the result of a create operation. Call its Extract
+// method to interpret the result as a SecurityGroup.
+type CreateResult struct {
+	commonResult
+}
+
+// GetResult represents the result of a get operation. Call its Extract
+// method to interpret the result as a SecurityGroup.
+type GetResult struct {
+	commonResult
+}
+
+// UpdateResult represents the result of an update operation. Call its Extract
+// method to interpret the result as a SecurityGroup.
+type UpdateResult struct {
+	commonResult
+}
+
+// Extract will extract a SecurityGroup struct from most responses.
+func (r commonResult) Extract() (*SecurityGroup, error) {
+	var s struct {
+		SecurityGroup *SecurityGroup `json:"security_group"`
+	}
+	err := r.ExtractInto(&s)
+	return s.SecurityGroup, err
+}
+
+// CreateRuleResult represents the result when adding rules to a security group.
+// Call its Extract method to interpret the result as a Rule.
+type CreateRuleResult struct {
+	gophercloud.Result
+}
+
+// Extract will extract a Rule struct from a CreateRuleResult.
+func (r CreateRuleResult) Extract() (*Rule, error) {
+	var s struct {
+		Rule *Rule `json:"security_group_rule"`
+	}
+	err := r.ExtractInto(&s)
+	return s.Rule, err
+}
+
+// DeleteResult is the response from delete operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
+
+// DeleteRuleResult is the response from a DeleteRule operation. Call its
+// ExtractErr method to determine if the request succeeded or failed.
+type DeleteRuleResult struct {
+	gophercloud.ErrResult
+}
+
+// AddServerResult is the response from an AddServer operation. Call its
+// ExtractErr method to determine if the request succeeded or failed.
+type AddServerResult struct {
+	gophercloud.ErrResult
+}
+
+// RemoveServerResult is the response from a RemoveServer operation. Call its
+// ExtractErr method to determine if the request succeeded or failed.
+type RemoveServerResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/doc.go
new file mode 100644
index 000000000..c5e60ea09
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/doc.go
@@ -0,0 +1,2 @@
+// secgroups unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/fixtures.go
new file mode 100644
index 000000000..27bd56f36
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/fixtures.go
@@ -0,0 +1,326 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	fake "github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const rootPath = "/os-security-groups"
+
+const listGroupsJSON = `
+{
+  "security_groups": [
+    {
+      "description": "default",
+      "id": "{groupID}",
+      "name": "default",
+      "rules": [],
+      "tenant_id": "openstack"
+    }
+  ]
+}
+`
+
+func mockListGroupsResponse(t *testing.T) {
+	th.Mux.HandleFunc(rootPath, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, listGroupsJSON)
+	})
+}
+
+func mockListGroupsByServerResponse(t *testing.T, serverID string) {
+	url := fmt.Sprintf("/servers/%s%s", serverID, rootPath)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, listGroupsJSON)
+	})
+}
+
+func mockCreateGroupResponse(t *testing.T) {
+	th.Mux.HandleFunc(rootPath, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		th.TestJSONRequest(t, r, `
+{
+  "security_group": {
+    "name": "test",
+    "description": "something"
+  }
+}
+	`)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group": {
+    "description": "something",
+    "id": "{groupID}",
+    "name": "test",
+    "rules": [],
+    "tenant_id": "openstack"
+  }
+}
+`)
+	})
+}
+
+func mockUpdateGroupResponse(t *testing.T, groupID string) {
+	url := fmt.Sprintf("%s/%s", rootPath, groupID)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "PUT")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		th.TestJSONRequest(t, r, `
+{
+  "security_group": {
+    "name": "new_name",
+		"description": "new_desc"
+  }
+}
+	`)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group": {
+    "description": "something",
+    "id": "{groupID}",
+    "name": "new_name",
+    "rules": [],
+    "tenant_id": "openstack"
+  }
+}
+`)
+	})
+}
+
+func mockGetGroupsResponse(t *testing.T, groupID string) {
+	url := fmt.Sprintf("%s/%s", rootPath, groupID)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group": {
+    "description": "default",
+    "id": "{groupID}",
+    "name": "default",
+    "rules": [
+      {
+        "from_port": 80,
+        "group": {
+          "tenant_id": "openstack",
+          "name": "default"
+        },
+        "ip_protocol": "TCP",
+        "to_port": 85,
+        "parent_group_id": "{groupID}",
+        "ip_range": {
+						"cidr": "0.0.0.0"
+				},
+        "id": "{ruleID}"
+      }
+    ],
+    "tenant_id": "openstack"
+  }
+}
+			`)
+	})
+}
+
+func mockGetNumericIDGroupResponse(t *testing.T, groupID int) {
+	url := fmt.Sprintf("%s/%d", rootPath, groupID)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+	"security_group": {
+		"id": %d
+	}
+}
+		`, groupID)
+	})
+}
+
+func mockGetNumericIDGroupRuleResponse(t *testing.T, groupID int) {
+	url := fmt.Sprintf("%s/%d", rootPath, groupID)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group": {
+    "id": %d,
+    "rules": [
+      {
+        "parent_group_id": %d,
+        "id": %d
+      }
+    ]
+  }
+}
+		`, groupID, groupID, groupID)
+	})
+}
+
+func mockDeleteGroupResponse(t *testing.T, groupID string) {
+	url := fmt.Sprintf("%s/%s", rootPath, groupID)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockAddRuleResponse(t *testing.T) {
+	th.Mux.HandleFunc("/os-security-group-rules", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		th.TestJSONRequest(t, r, `
+{
+  "security_group_rule": {
+    "from_port": 22,
+    "ip_protocol": "TCP",
+    "to_port": 22,
+    "parent_group_id": "{groupID}",
+    "cidr": "0.0.0.0/0"
+  }
+}	`)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group_rule": {
+    "from_port": 22,
+    "group": {},
+    "ip_protocol": "TCP",
+    "to_port": 22,
+    "parent_group_id": "{groupID}",
+    "ip_range": {
+      "cidr": "0.0.0.0/0"
+    },
+    "id": "{ruleID}"
+  }
+}`)
+	})
+}
+
+func mockAddRuleResponseICMPZero(t *testing.T) {
+	th.Mux.HandleFunc("/os-security-group-rules", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		th.TestJSONRequest(t, r, `
+{
+  "security_group_rule": {
+    "from_port": 0,
+    "ip_protocol": "ICMP",
+    "to_port": 0,
+    "parent_group_id": "{groupID}",
+    "cidr": "0.0.0.0/0"
+  }
+}	`)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+  "security_group_rule": {
+    "from_port": 0,
+    "group": {},
+    "ip_protocol": "ICMP",
+    "to_port": 0,
+    "parent_group_id": "{groupID}",
+    "ip_range": {
+      "cidr": "0.0.0.0/0"
+    },
+    "id": "{ruleID}"
+  }
+}`)
+	})
+}
+
+func mockDeleteRuleResponse(t *testing.T, ruleID string) {
+	url := fmt.Sprintf("/os-security-group-rules/%s", ruleID)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockAddServerToGroupResponse(t *testing.T, serverID string) {
+	url := fmt.Sprintf("/servers/%s/action", serverID)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		th.TestJSONRequest(t, r, `
+{
+  "addSecurityGroup": {
+    "name": "test"
+  }
+}
+	`)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockRemoveServerFromGroupResponse(t *testing.T, serverID string) {
+	url := fmt.Sprintf("/servers/%s/action", serverID)
+	th.Mux.HandleFunc(url, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+
+		th.TestJSONRequest(t, r, `
+{
+  "removeSecurityGroup": {
+    "name": "test"
+  }
+}
+	`)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/requests_test.go
new file mode 100644
index 000000000..01ab9f735
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/testing/requests_test.go
@@ -0,0 +1,303 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const (
+	serverID = "{serverID}"
+	groupID  = "{groupID}"
+	ruleID   = "{ruleID}"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockListGroupsResponse(t)
+
+	count := 0
+
+	err := secgroups.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := secgroups.ExtractSecurityGroups(page)
+		if err != nil {
+			t.Errorf("Failed to extract users: %v", err)
+			return false, err
+		}
+
+		expected := []secgroups.SecurityGroup{
+			{
+				ID:          groupID,
+				Description: "default",
+				Name:        "default",
+				Rules:       []secgroups.Rule{},
+				TenantID:    "openstack",
+			},
+		}
+
+		th.CheckDeepEquals(t, expected, actual)
+
+		return true, nil
+	})
+
+	th.AssertNoErr(t, err)
+	th.AssertEquals(t, 1, count)
+}
+
+func TestListByServer(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockListGroupsByServerResponse(t, serverID)
+
+	count := 0
+
+	err := secgroups.ListByServer(client.ServiceClient(), serverID).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := secgroups.ExtractSecurityGroups(page)
+		if err != nil {
+			t.Errorf("Failed to extract users: %v", err)
+			return false, err
+		}
+
+		expected := []secgroups.SecurityGroup{
+			{
+				ID:          groupID,
+				Description: "default",
+				Name:        "default",
+				Rules:       []secgroups.Rule{},
+				TenantID:    "openstack",
+			},
+		}
+
+		th.CheckDeepEquals(t, expected, actual)
+
+		return true, nil
+	})
+
+	th.AssertNoErr(t, err)
+	th.AssertEquals(t, 1, count)
+}
+
+func TestCreate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockCreateGroupResponse(t)
+
+	opts := secgroups.CreateOpts{
+		Name:        "test",
+		Description: "something",
+	}
+
+	group, err := secgroups.Create(client.ServiceClient(), opts).Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &secgroups.SecurityGroup{
+		ID:          groupID,
+		Name:        "test",
+		Description: "something",
+		TenantID:    "openstack",
+		Rules:       []secgroups.Rule{},
+	}
+	th.AssertDeepEquals(t, expected, group)
+}
+
+func TestUpdate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockUpdateGroupResponse(t, groupID)
+
+	description := "new_desc"
+	opts := secgroups.UpdateOpts{
+		Name:        "new_name",
+		Description: &description,
+	}
+
+	group, err := secgroups.Update(client.ServiceClient(), groupID, opts).Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &secgroups.SecurityGroup{
+		ID:          groupID,
+		Name:        "new_name",
+		Description: "something",
+		TenantID:    "openstack",
+		Rules:       []secgroups.Rule{},
+	}
+	th.AssertDeepEquals(t, expected, group)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockGetGroupsResponse(t, groupID)
+
+	group, err := secgroups.Get(client.ServiceClient(), groupID).Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &secgroups.SecurityGroup{
+		ID:          groupID,
+		Description: "default",
+		Name:        "default",
+		TenantID:    "openstack",
+		Rules: []secgroups.Rule{
+			{
+				FromPort:      80,
+				ToPort:        85,
+				IPProtocol:    "TCP",
+				IPRange:       secgroups.IPRange{CIDR: "0.0.0.0"},
+				Group:         secgroups.Group{TenantID: "openstack", Name: "default"},
+				ParentGroupID: groupID,
+				ID:            ruleID,
+			},
+		},
+	}
+
+	th.AssertDeepEquals(t, expected, group)
+}
+
+func TestGetNumericID(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	numericGroupID := 12345
+
+	mockGetNumericIDGroupResponse(t, numericGroupID)
+
+	group, err := secgroups.Get(client.ServiceClient(), "12345").Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &secgroups.SecurityGroup{ID: "12345"}
+	th.AssertDeepEquals(t, expected, group)
+}
+
+func TestGetNumericRuleID(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	numericGroupID := 12345
+
+	mockGetNumericIDGroupRuleResponse(t, numericGroupID)
+
+	group, err := secgroups.Get(client.ServiceClient(), "12345").Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &secgroups.SecurityGroup{
+		ID: "12345",
+		Rules: []secgroups.Rule{
+			{
+				ParentGroupID: "12345",
+				ID:            "12345",
+			},
+		},
+	}
+	th.AssertDeepEquals(t, expected, group)
+}
+
+func TestDelete(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockDeleteGroupResponse(t, groupID)
+
+	err := secgroups.Delete(client.ServiceClient(), groupID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestAddRule(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockAddRuleResponse(t)
+
+	opts := secgroups.CreateRuleOpts{
+		ParentGroupID: groupID,
+		FromPort:      22,
+		ToPort:        22,
+		IPProtocol:    "TCP",
+		CIDR:          "0.0.0.0/0",
+	}
+
+	rule, err := secgroups.CreateRule(client.ServiceClient(), opts).Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &secgroups.Rule{
+		FromPort:      22,
+		ToPort:        22,
+		Group:         secgroups.Group{},
+		IPProtocol:    "TCP",
+		ParentGroupID: groupID,
+		IPRange:       secgroups.IPRange{CIDR: "0.0.0.0/0"},
+		ID:            ruleID,
+	}
+
+	th.AssertDeepEquals(t, expected, rule)
+}
+
+func TestAddRuleICMPZero(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockAddRuleResponseICMPZero(t)
+
+	opts := secgroups.CreateRuleOpts{
+		ParentGroupID: groupID,
+		FromPort:      0,
+		ToPort:        0,
+		IPProtocol:    "ICMP",
+		CIDR:          "0.0.0.0/0",
+	}
+
+	rule, err := secgroups.CreateRule(client.ServiceClient(), opts).Extract()
+	th.AssertNoErr(t, err)
+
+	expected := &secgroups.Rule{
+		FromPort:      0,
+		ToPort:        0,
+		Group:         secgroups.Group{},
+		IPProtocol:    "ICMP",
+		ParentGroupID: groupID,
+		IPRange:       secgroups.IPRange{CIDR: "0.0.0.0/0"},
+		ID:            ruleID,
+	}
+
+	th.AssertDeepEquals(t, expected, rule)
+}
+
+func TestDeleteRule(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockDeleteRuleResponse(t, ruleID)
+
+	err := secgroups.DeleteRule(client.ServiceClient(), ruleID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestAddServer(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockAddServerToGroupResponse(t, serverID)
+
+	err := secgroups.AddServer(client.ServiceClient(), serverID, "test").ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestRemoveServer(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockRemoveServerFromGroupResponse(t, serverID)
+
+	err := secgroups.RemoveServer(client.ServiceClient(), serverID, "test").ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/urls.go
new file mode 100644
index 000000000..d99746cae
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups/urls.go
@@ -0,0 +1,32 @@
+package secgroups
+
+import "github.com/gophercloud/gophercloud"
+
+const (
+	secgrouppath = "os-security-groups"
+	rulepath     = "os-security-group-rules"
+)
+
+func resourceURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL(secgrouppath, id)
+}
+
+func rootURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(secgrouppath)
+}
+
+func listByServerURL(c *gophercloud.ServiceClient, serverID string) string {
+	return c.ServiceURL("servers", serverID, secgrouppath)
+}
+
+func rootRuleURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(rulepath)
+}
+
+func resourceRuleURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL(rulepath, id)
+}
+
+func serverActionURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL("servers", id, "action")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/doc.go
new file mode 100644
index 000000000..936674b05
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/doc.go
@@ -0,0 +1,58 @@
+/*
+Package servergroups provides the ability to manage server groups.
+
+Example to List Server Groups
+
+	allpages, err := servergroups.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allServerGroups, err := servergroups.ExtractServerGroups(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, sg := range allServerGroups {
+		fmt.Printf("%#v\n", sg)
+	}
+
+Example to Create a Server Group
+
+	createOpts := servergroups.CreateOpts{
+		Name:     "my_sg",
+		Policies: []string{"anti-affinity"},
+	}
+
+	sg, err := servergroups.Create(computeClient, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Create a Server Group with additional microversion 2.64 fields
+
+	createOpts := servergroups.CreateOpts{
+		Name:   "my_sg",
+		Policy: "anti-affinity",
+        	Rules: &servergroups.Rules{
+            		MaxServerPerHost: 3,
+        	},
+	}
+
+	computeClient.Microversion = "2.64"
+	result := servergroups.Create(computeClient, createOpts)
+
+	serverGroup, err := result.Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Delete a Server Group
+
+	sgID := "7a6f29ad-e34d-4368-951a-58a08f11cfb7"
+	err := servergroups.Delete(computeClient, sgID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package servergroups
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/requests.go
new file mode 100644
index 000000000..5740afaf0
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/requests.go
@@ -0,0 +1,67 @@
+package servergroups
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List returns a Pager that allows you to iterate over a collection of
+// ServerGroups.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, listURL(client), func(r pagination.PageResult) pagination.Page {
+		return ServerGroupPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// CreateOptsBuilder allows extensions to add additional parameters to the
+// Create request.
+type CreateOptsBuilder interface {
+	ToServerGroupCreateMap() (map[string]interface{}, error)
+}
+
+// CreateOpts specifies Server Group creation parameters.
+type CreateOpts struct {
+	// Name is the name of the server group.
+	Name string `json:"name" required:"true"`
+
+	// Policies are the server group policies.
+	Policies []string `json:"policies,omitempty"`
+
+	// Policy specifies the name of a policy.
+	// Requires microversion 2.64 or later.
+	Policy string `json:"policy,omitempty"`
+
+	// Rules specifies the set of rules.
+	// Requires microversion 2.64 or later.
+	Rules *Rules `json:"rules,omitempty"`
+}
+
+// ToServerGroupCreateMap constructs a request body from CreateOpts.
+func (opts CreateOpts) ToServerGroupCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "server_group")
+}
+
+// Create requests the creation of a new Server Group.
+func Create(client *gophercloud.ServiceClient, opts CreateOptsBuilder) (r CreateResult) {
+	b, err := opts.ToServerGroupCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(createURL(client), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Get returns data about a previously created ServerGroup.
+func Get(client *gophercloud.ServiceClient, id string) (r GetResult) {
+	_, r.Err = client.Get(getURL(client, id), &r.Body, nil)
+	return
+}
+
+// Delete requests the deletion of a previously allocated ServerGroup.
+func Delete(client *gophercloud.ServiceClient, id string) (r DeleteResult) {
+	_, r.Err = client.Delete(deleteURL(client, id), nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/results.go
new file mode 100644
index 000000000..de41f1230
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/results.go
@@ -0,0 +1,105 @@
+package servergroups
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// A ServerGroup creates a policy for instance placement in the cloud.
+// You should use extract methods from microversions.go to retrieve additional
+// fields.
+type ServerGroup struct {
+	// ID is the unique ID of the Server Group.
+	ID string `json:"id"`
+
+	// Name is the common name of the server group.
+	Name string `json:"name"`
+
+	// Polices are the group policies.
+	//
+	// Normally a single policy is applied:
+	//
+	// "affinity" will place all servers within the server group on the
+	// same compute node.
+	//
+	// "anti-affinity" will place servers within the server group on different
+	// compute nodes.
+	Policies []string `json:"policies"`
+
+	// Members are the members of the server group.
+	Members []string `json:"members"`
+
+	// Metadata includes a list of all user-specified key-value pairs attached
+	// to the Server Group.
+	Metadata map[string]interface{}
+
+	// Policy is the policy of a server group.
+	// This requires microversion 2.64 or later.
+	Policy *string `json:"policy"`
+
+	// Rules are the rules of the server group.
+	// This requires microversion 2.64 or later.
+	Rules *Rules `json:"rules"`
+}
+
+// Rules represents set of rules for a policy.
+// This requires microversion 2.64 or later.
+type Rules struct {
+	// MaxServerPerHost specifies how many servers can reside on a single compute host.
+	// It can be used only with the "anti-affinity" policy.
+	MaxServerPerHost int `json:"max_server_per_host"`
+}
+
+// ServerGroupPage stores a single page of all ServerGroups results from a
+// List call.
+type ServerGroupPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a ServerGroupsPage is empty.
+func (page ServerGroupPage) IsEmpty() (bool, error) {
+	va, err := ExtractServerGroups(page)
+	return len(va) == 0, err
+}
+
+// ExtractServerGroups interprets a page of results as a slice of
+// ServerGroups.
+func ExtractServerGroups(r pagination.Page) ([]ServerGroup, error) {
+	var s struct {
+		ServerGroups []ServerGroup `json:"server_groups"`
+	}
+	err := (r.(ServerGroupPage)).ExtractInto(&s)
+	return s.ServerGroups, err
+}
+
+type ServerGroupResult struct {
+	gophercloud.Result
+}
+
+// Extract is a method that attempts to interpret any Server Group resource
+// response as a ServerGroup struct.
+func (r ServerGroupResult) Extract() (*ServerGroup, error) {
+	var s struct {
+		ServerGroup *ServerGroup `json:"server_group"`
+	}
+	err := r.ExtractInto(&s)
+	return s.ServerGroup, err
+}
+
+// CreateResult is the response from a Create operation. Call its Extract method
+// to interpret it as a ServerGroup.
+type CreateResult struct {
+	ServerGroupResult
+}
+
+// GetResult is the response from a Get operation. Call its Extract method to
+// interpret it as a ServerGroup.
+type GetResult struct {
+	ServerGroupResult
+}
+
+// DeleteResult is the response from a Delete operation. Call its ExtractErr
+// method to determine if the call succeeded or failed.
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/doc.go
new file mode 100644
index 000000000..644bb49df
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/doc.go
@@ -0,0 +1,2 @@
+// servergroups unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/fixtures.go
new file mode 100644
index 000000000..fc4a4c7bd
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/fixtures.go
@@ -0,0 +1,236 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ListOutput is a sample response to a List call.
+const ListOutput = `
+{
+    "server_groups": [
+        {
+            "id": "616fb98f-46ca-475e-917e-2563e5a8cd19",
+            "name": "test",
+            "policies": [
+                "anti-affinity"
+            ],
+            "members": [],
+            "metadata": {}
+        },
+        {
+            "id": "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+            "name": "test2",
+            "policies": [
+                "affinity"
+            ],
+            "members": [],
+            "metadata": {}
+        }
+    ]
+}
+`
+
+// GetOutput is a sample response to a Get call.
+const GetOutput = `
+{
+    "server_group": {
+        "id": "616fb98f-46ca-475e-917e-2563e5a8cd19",
+        "name": "test",
+        "policies": [
+            "anti-affinity"
+        ],
+        "members": [],
+        "metadata": {}
+    }
+}
+`
+
+// GetOutputMicroversion is a sample response to a Get call with microversion set to 2.64
+const GetOutputMicroversion = `
+{
+    "server_group": {
+        "id": "616fb98f-46ca-475e-917e-2563e5a8cd19",
+        "name": "test",
+        "policies": [
+            "anti-affinity"
+        ],
+        "policy": "anti-affinity",
+        "rules": {
+          "max_server_per_host": 3
+        },
+        "members": [],
+        "metadata": {}
+    }
+}
+`
+
+// CreateOutput is a sample response to a Post call
+const CreateOutput = `
+{
+    "server_group": {
+        "id": "616fb98f-46ca-475e-917e-2563e5a8cd19",
+        "name": "test",
+        "policies": [
+            "anti-affinity"
+        ],
+        "members": [],
+        "metadata": {}
+    }
+}
+`
+
+// CreateOutputMicroversion is a sample response to a Post call with microversion set to 2.64
+const CreateOutputMicroversion = `
+{
+    "server_group": {
+        "id": "616fb98f-46ca-475e-917e-2563e5a8cd19",
+        "name": "test",
+        "policies": [
+            "anti-affinity"
+        ],
+        "policy": "anti-affinity",
+        "rules": {
+          "max_server_per_host": 3
+        },
+        "members": [],
+        "metadata": {}
+    }
+}
+`
+
+// FirstServerGroup is the first result in ListOutput.
+var FirstServerGroup = servergroups.ServerGroup{
+	ID:   "616fb98f-46ca-475e-917e-2563e5a8cd19",
+	Name: "test",
+	Policies: []string{
+		"anti-affinity",
+	},
+	Members:  []string{},
+	Metadata: map[string]interface{}{},
+}
+
+// SecondServerGroup is the second result in ListOutput.
+var SecondServerGroup = servergroups.ServerGroup{
+	ID:   "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+	Name: "test2",
+	Policies: []string{
+		"affinity",
+	},
+	Members:  []string{},
+	Metadata: map[string]interface{}{},
+}
+
+// ExpectedServerGroupSlice is the slice of results that should be parsed
+// from ListOutput, in the expected order.
+var ExpectedServerGroupSlice = []servergroups.ServerGroup{FirstServerGroup, SecondServerGroup}
+
+// CreatedServerGroup is the parsed result from CreateOutput.
+var CreatedServerGroup = servergroups.ServerGroup{
+	ID:   "616fb98f-46ca-475e-917e-2563e5a8cd19",
+	Name: "test",
+	Policies: []string{
+		"anti-affinity",
+	},
+	Members:  []string{},
+	Metadata: map[string]interface{}{},
+}
+
+// HandleListSuccessfully configures the test server to respond to a List request.
+func HandleListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-server-groups", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ListOutput)
+	})
+}
+
+// HandleGetSuccessfully configures the test server to respond to a Get request
+// for an existing server group
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-server-groups/4d8c3732-a248-40ed-bebc-539a6ffd25c0", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
+
+// HandleGetMicroversionSuccessfully configures the test server to respond to a Get request
+// for an existing server group with microversion set to 2.64
+func HandleGetMicroversionSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-server-groups/4d8c3732-a248-40ed-bebc-539a6ffd25c0", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutputMicroversion)
+	})
+}
+
+// HandleCreateSuccessfully configures the test server to respond to a Create request
+// for a new server group
+func HandleCreateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-server-groups", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+{
+    "server_group": {
+        "name": "test",
+        "policies": [
+            "anti-affinity"
+        ]
+    }
+}
+`)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, CreateOutput)
+	})
+}
+
+// HandleCreateMicroversionSuccessfully configures the test server to respond to a Create request
+// for a new server group with microversion set to 2.64
+func HandleCreateMicroversionSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-server-groups", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+{
+    "server_group": {
+        "name": "test",
+        "policies": [
+            "anti-affinity"
+        ],
+        "policy": "anti-affinity",
+        "rules": {
+            "max_server_per_host": 3
+        }
+    }
+}
+`)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, CreateOutputMicroversion)
+	})
+}
+
+// HandleDeleteSuccessfully configures the test server to respond to a Delete request for a
+// an existing server group
+func HandleDeleteSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-server-groups/616fb98f-46ca-475e-917e-2563e5a8cd19", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/requests_test.go
new file mode 100644
index 000000000..cada74fa0
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/testing/requests_test.go
@@ -0,0 +1,104 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleListSuccessfully(t)
+
+	count := 0
+	err := servergroups.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := servergroups.ExtractServerGroups(page)
+		th.AssertNoErr(t, err)
+		th.CheckDeepEquals(t, ExpectedServerGroupSlice, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.CheckEquals(t, 1, count)
+}
+
+func TestCreate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleCreateSuccessfully(t)
+
+	actual, err := servergroups.Create(client.ServiceClient(), servergroups.CreateOpts{
+		Name:     "test",
+		Policies: []string{"anti-affinity"},
+	}).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &CreatedServerGroup, actual)
+}
+
+func TestCreateMicroversion(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleCreateMicroversionSuccessfully(t)
+
+	policy := "anti-affinity"
+	rules := servergroups.Rules{
+		MaxServerPerHost: 3,
+	}
+	CreatedServerGroup.Policy = &policy
+	CreatedServerGroup.Rules = &rules
+
+	result := servergroups.Create(client.ServiceClient(), servergroups.CreateOpts{
+		Name:     "test",
+		Policies: []string{"anti-affinity"},
+		Policy:   policy,
+		Rules:    &rules,
+	})
+
+	actual, err := result.Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &CreatedServerGroup, actual)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSuccessfully(t)
+
+	actual, err := servergroups.Get(client.ServiceClient(), "4d8c3732-a248-40ed-bebc-539a6ffd25c0").Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &FirstServerGroup, actual)
+}
+
+func TestGetMicroversion(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetMicroversionSuccessfully(t)
+
+	policy := "anti-affinity"
+	rules := servergroups.Rules{
+		MaxServerPerHost: 3,
+	}
+	FirstServerGroup.Policy = &policy
+	FirstServerGroup.Rules = &rules
+
+	result := servergroups.Get(client.ServiceClient(), "4d8c3732-a248-40ed-bebc-539a6ffd25c0")
+
+	// Extract basic fields.
+	actual, err := result.Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &FirstServerGroup, actual)
+}
+
+func TestDelete(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleDeleteSuccessfully(t)
+
+	err := servergroups.Delete(client.ServiceClient(), "616fb98f-46ca-475e-917e-2563e5a8cd19").ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/urls.go
new file mode 100644
index 000000000..9a1f99b19
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/servergroups/urls.go
@@ -0,0 +1,25 @@
+package servergroups
+
+import "github.com/gophercloud/gophercloud"
+
+const resourcePath = "os-server-groups"
+
+func resourceURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(resourcePath)
+}
+
+func listURL(c *gophercloud.ServiceClient) string {
+	return resourceURL(c)
+}
+
+func createURL(c *gophercloud.ServiceClient) string {
+	return resourceURL(c)
+}
+
+func getURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL(resourcePath, id)
+}
+
+func deleteURL(c *gophercloud.ServiceClient, id string) string {
+	return getURL(c, id)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/doc.go
new file mode 100644
index 000000000..0f3127f04
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/doc.go
@@ -0,0 +1,20 @@
+/*
+Package serverusage provides the ability the ability to extend a server result
+with the extended usage information.
+
+Example to Get an extended information:
+
+  type serverUsageExt struct {
+    servers.Server
+    serverusage.UsageExt
+  }
+  var serverWithUsageExt serverUsageExt
+
+  err := servers.Get(computeClient, "d650a0ce-17c3-497d-961a-43c4af80998a").ExtractInto(&serverWithUsageExt)
+  if err != nil {
+    panic(err)
+  }
+
+  fmt.Printf("%+v\n", serverWithUsageExt)
+*/
+package serverusage
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/results.go
new file mode 100644
index 000000000..a80abb6bc
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/results.go
@@ -0,0 +1,34 @@
+package serverusage
+
+import (
+	"encoding/json"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+)
+
+// UsageExt represents OS-SRV-USG server response fields.
+type UsageExt struct {
+	LaunchedAt   time.Time `json:"-"`
+	TerminatedAt time.Time `json:"-"`
+}
+
+// UnmarshalJSON helps to unmarshal UsageExt fields into needed values.
+func (r *UsageExt) UnmarshalJSON(b []byte) error {
+	type tmp UsageExt
+	var s struct {
+		tmp
+		LaunchedAt   gophercloud.JSONRFC3339MilliNoZ `json:"OS-SRV-USG:launched_at"`
+		TerminatedAt gophercloud.JSONRFC3339MilliNoZ `json:"OS-SRV-USG:terminated_at"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+	*r = UsageExt(s.tmp)
+
+	r.LaunchedAt = time.Time(s.LaunchedAt)
+	r.TerminatedAt = time.Time(s.TerminatedAt)
+
+	return nil
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/doc.go
new file mode 100644
index 000000000..7603f836a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/doc.go
@@ -0,0 +1 @@
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/fixtures.go
new file mode 100644
index 000000000..2d2cf2ef5
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/fixtures.go
@@ -0,0 +1,20 @@
+package testing
+
+// ServerWithUsageExtResult represents a raw server response from the Compute API
+// with OS-SRV-USG data.
+// Most of the actual fields were deleted from the response.
+const ServerWithUsageExtResult = `
+{
+    "server": {
+        "OS-SRV-USG:launched_at": "2018-07-27T09:15:55.000000",
+        "OS-SRV-USG:terminated_at": null,
+        "created": "2018-07-27T09:15:48Z",
+        "updated": "2018-07-27T09:15:55Z",
+        "id": "d650a0ce-17c3-497d-961a-43c4af80998a",
+        "name": "test_instance",
+        "status": "ACTIVE",
+        "user_id": "0f2f3822679e4b3ea073e5d1c6ed5f02",
+        "tenant_id": "424e7cf0243c468ca61732ba45973b3e"
+    }
+}
+`
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/requests_test.go
new file mode 100644
index 000000000..b05dee578
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage/testing/requests_test.go
@@ -0,0 +1,44 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+	"time"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/serverusage"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	fake "github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestServerWithUsageExt(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/d650a0ce-17c3-497d-961a-43c4af80998a", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", fake.TokenID)
+		th.TestHeader(t, r, "Accept", "application/json")
+
+		fmt.Fprintf(w, ServerWithUsageExtResult)
+	})
+
+	type serverUsageExt struct {
+		servers.Server
+		serverusage.UsageExt
+	}
+	var serverWithUsageExt serverUsageExt
+	err := servers.Get(fake.ServiceClient(), "d650a0ce-17c3-497d-961a-43c4af80998a").ExtractInto(&serverWithUsageExt)
+	th.AssertNoErr(t, err)
+
+	th.AssertEquals(t, serverWithUsageExt.LaunchedAt, time.Date(2018, 07, 27, 9, 15, 55, 0, time.UTC))
+	th.AssertEquals(t, serverWithUsageExt.TerminatedAt, time.Time{})
+	th.AssertEquals(t, serverWithUsageExt.Created, time.Date(2018, 07, 27, 9, 15, 48, 0, time.UTC))
+	th.AssertEquals(t, serverWithUsageExt.Updated, time.Date(2018, 07, 27, 9, 15, 55, 0, time.UTC))
+	th.AssertEquals(t, serverWithUsageExt.ID, "d650a0ce-17c3-497d-961a-43c4af80998a")
+	th.AssertEquals(t, serverWithUsageExt.Name, "test_instance")
+	th.AssertEquals(t, serverWithUsageExt.Status, "ACTIVE")
+	th.AssertEquals(t, serverWithUsageExt.UserID, "0f2f3822679e4b3ea073e5d1c6ed5f02")
+	th.AssertEquals(t, serverWithUsageExt.TenantID, "424e7cf0243c468ca61732ba45973b3e")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/doc.go
new file mode 100644
index 000000000..c960cb164
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/doc.go
@@ -0,0 +1,37 @@
+/*
+Package services returns information about the compute services in the OpenStack
+cloud.
+
+Example of Retrieving list of all services
+
+	opts := services.ListOpts{
+		Binary: "nova-scheduler",
+	}
+
+	allPages, err := services.List(computeClient, opts).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allServices, err := services.ExtractServices(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, service := range allServices {
+		fmt.Printf("%+v\n", service)
+	}
+
+Example of updating a service
+
+	opts := services.UpdateOpts{
+		Status: services.ServiceDisabled,
+	}
+
+	updated, err := services.Update(client, serviceID, opts).Extract()
+	if err != nil {
+		panic(err)
+	}
+*/
+
+package services
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/requests.go
new file mode 100644
index 000000000..ed8907d1d
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/requests.go
@@ -0,0 +1,81 @@
+package services
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// ListOptsBuilder allows extensions to add additional parameters to
+// the List request.
+type ListOptsBuilder interface {
+	ToServicesListQuery() (string, error)
+}
+
+// ListOpts represents options to list services.
+type ListOpts struct {
+	Binary string `q:"binary"`
+	Host   string `q:"host"`
+}
+
+// ToServicesListQuery formats a ListOpts into a query string.
+func (opts ListOpts) ToServicesListQuery() (string, error) {
+	q, err := gophercloud.BuildQueryString(opts)
+	return q.String(), err
+}
+
+// List makes a request against the API to list services.
+func List(client *gophercloud.ServiceClient, opts ListOptsBuilder) pagination.Pager {
+	url := listURL(client)
+	if opts != nil {
+		query, err := opts.ToServicesListQuery()
+		if err != nil {
+			return pagination.Pager{Err: err}
+		}
+		url += query
+	}
+
+	return pagination.NewPager(client, url, func(r pagination.PageResult) pagination.Page {
+		return ServicePage{pagination.SinglePageBase(r)}
+	})
+}
+
+type ServiceStatus string
+
+const (
+	// ServiceEnabled is used to mark a service as being enabled.
+	ServiceEnabled ServiceStatus = "enabled"
+
+	// ServiceDisabled is used to mark a service as being disabled.
+	ServiceDisabled ServiceStatus = "disabled"
+)
+
+// UpdateOpts specifies the base attributes that may be updated on a service.
+type UpdateOpts struct {
+	// Status represents the new service status. One of enabled or disabled.
+	Status ServiceStatus `json:"status,omitempty"`
+
+	// DisabledReason represents the reason for disabling a service.
+	DisabledReason string `json:"disabled_reason,omitempty"`
+
+	// ForcedDown is a manual override to tell nova that the service in question
+	// has been fenced manually by the operations team.
+	ForcedDown bool `json:"forced_down,omitempty"`
+}
+
+// ToServiceUpdateMap formats an UpdateOpts structure into a request body.
+func (opts UpdateOpts) ToServiceUpdateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "")
+}
+
+// Update requests that various attributes of the indicated service be changed.
+func Update(client *gophercloud.ServiceClient, id string, opts UpdateOpts) (r UpdateResult) {
+	b, err := opts.ToServiceUpdateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Put(updateURL(client, id), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/results.go
new file mode 100644
index 000000000..866c54162
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/results.go
@@ -0,0 +1,111 @@
+package services
+
+import (
+	"encoding/json"
+	"fmt"
+	"strconv"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// Service represents a Compute service in the OpenStack cloud.
+type Service struct {
+	// The binary name of the service.
+	Binary string `json:"binary"`
+
+	// The reason for disabling a service.
+	DisabledReason string `json:"disabled_reason"`
+
+	// Whether or not service was forced down manually.
+	ForcedDown bool `json:"forced_down"`
+
+	// The name of the host.
+	Host string `json:"host"`
+
+	// The id of the service.
+	ID string `json:"-"`
+
+	// The state of the service. One of up or down.
+	State string `json:"state"`
+
+	// The status of the service. One of enabled or disabled.
+	Status string `json:"status"`
+
+	// The date and time when the resource was updated.
+	UpdatedAt time.Time `json:"-"`
+
+	// The availability zone name.
+	Zone string `json:"zone"`
+}
+
+// UnmarshalJSON to override default
+func (r *Service) UnmarshalJSON(b []byte) error {
+	type tmp Service
+	var s struct {
+		tmp
+		ID        interface{}                     `json:"id"`
+		UpdatedAt gophercloud.JSONRFC3339MilliNoZ `json:"updated_at"`
+	}
+	err := json.Unmarshal(b, &s)
+	if err != nil {
+		return err
+	}
+	*r = Service(s.tmp)
+
+	r.UpdatedAt = time.Time(s.UpdatedAt)
+
+	// OpenStack Compute service returns ID in string representation since
+	// 2.53 microversion API (Pike release).
+	switch t := s.ID.(type) {
+	case int:
+		r.ID = strconv.Itoa(t)
+	case float64:
+		r.ID = strconv.Itoa(int(t))
+	case string:
+		r.ID = t
+	default:
+		return fmt.Errorf("ID has unexpected type: %T", t)
+	}
+
+	return nil
+}
+
+type serviceResult struct {
+	gophercloud.Result
+}
+
+// Extract interprets any UpdateResult as a service, if possible.
+func (r serviceResult) Extract() (*Service, error) {
+	var s struct {
+		Service Service `json:"service"`
+	}
+	err := r.ExtractInto(&s)
+	return &s.Service, err
+}
+
+// UpdateResult is the response from an Update operation. Call its Extract
+// method to interpret it as a Server.
+type UpdateResult struct {
+	serviceResult
+}
+
+// ServicePage represents a single page of all Services from a List request.
+type ServicePage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a page of Services contains any results.
+func (page ServicePage) IsEmpty() (bool, error) {
+	services, err := ExtractServices(page)
+	return len(services) == 0, err
+}
+
+func ExtractServices(r pagination.Page) ([]Service, error) {
+	var s struct {
+		Service []Service `json:"services"`
+	}
+	err := (r.(ServicePage)).ExtractInto(&s)
+	return s.Service, err
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/testing/fixtures.go
new file mode 100644
index 000000000..876d68a53
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/testing/fixtures.go
@@ -0,0 +1,290 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+	"time"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ServiceListBodyPre253 represents a raw service list from the Compute API
+// with microversion older than 2.53.
+const ServiceListBodyPre253 = `
+{
+    "services": [
+        {
+            "id": 1,
+            "binary": "nova-scheduler",
+            "disabled_reason": "test1",
+            "host": "host1",
+            "state": "up",
+            "status": "disabled",
+            "updated_at": "2012-10-29T13:42:02.000000",
+            "forced_down": false,
+            "zone": "internal"
+        },
+        {
+            "id": 2,
+            "binary": "nova-compute",
+            "disabled_reason": "test2",
+            "host": "host1",
+            "state": "up",
+            "status": "disabled",
+            "updated_at": "2012-10-29T13:42:05.000000",
+            "forced_down": false,
+            "zone": "nova"
+        },
+        {
+            "id": 3,
+            "binary": "nova-scheduler",
+            "disabled_reason": null,
+            "host": "host2",
+            "state": "down",
+            "status": "enabled",
+            "updated_at": "2012-09-19T06:55:34.000000",
+            "forced_down": false,
+            "zone": "internal"
+        },
+        {
+            "id": 4,
+            "binary": "nova-compute",
+            "disabled_reason": "test4",
+            "host": "host2",
+            "state": "down",
+            "status": "disabled",
+            "updated_at": "2012-09-18T08:03:38.000000",
+            "forced_down": false,
+            "zone": "nova"
+        }
+    ]
+}
+`
+
+var (
+	// FirstFakeServicePre253 represents the first service from the
+	// ServiceListBodyPre253.
+	FirstFakeServicePre253 = services.Service{
+		Binary:         "nova-scheduler",
+		DisabledReason: "test1",
+		Host:           "host1",
+		ID:             "1",
+		State:          "up",
+		Status:         "disabled",
+		UpdatedAt:      time.Date(2012, 10, 29, 13, 42, 2, 0, time.UTC),
+		Zone:           "internal",
+	}
+
+	// SecondFakeServicePre253 represents the second service from the
+	// ServiceListBodyPre253.
+	SecondFakeServicePre253 = services.Service{
+		Binary:         "nova-compute",
+		DisabledReason: "test2",
+		Host:           "host1",
+		ID:             "2",
+		State:          "up",
+		Status:         "disabled",
+		UpdatedAt:      time.Date(2012, 10, 29, 13, 42, 5, 0, time.UTC),
+		Zone:           "nova",
+	}
+
+	// ThirdFakeServicePre253 represents the third service from the
+	// ServiceListBodyPre253.
+	ThirdFakeServicePre253 = services.Service{
+		Binary:         "nova-scheduler",
+		DisabledReason: "",
+		Host:           "host2",
+		ID:             "3",
+		State:          "down",
+		Status:         "enabled",
+		UpdatedAt:      time.Date(2012, 9, 19, 6, 55, 34, 0, time.UTC),
+		Zone:           "internal",
+	}
+
+	// FourthFakeServicePre253 represents the fourth service from the
+	// ServiceListBodyPre253.
+	FourthFakeServicePre253 = services.Service{
+		Binary:         "nova-compute",
+		DisabledReason: "test4",
+		Host:           "host2",
+		ID:             "4",
+		State:          "down",
+		Status:         "disabled",
+		UpdatedAt:      time.Date(2012, 9, 18, 8, 3, 38, 0, time.UTC),
+		Zone:           "nova",
+	}
+)
+
+// ServiceListBody represents a raw service list result with Pike+ release.
+const ServiceListBody = `
+{
+    "services": [
+        {
+            "id": "4c720fa0-02c3-4834-8279-9eecf9edb6cb",
+            "binary": "nova-scheduler",
+            "disabled_reason": "test1",
+            "host": "host1",
+            "state": "up",
+            "status": "disabled",
+            "updated_at": "2012-10-29T13:42:02.000000",
+            "forced_down": false,
+            "zone": "internal"
+        },
+        {
+            "id": "1fdfec3e-ee03-4e36-b99b-71cf2967b70c",
+            "binary": "nova-compute",
+            "disabled_reason": "test2",
+            "host": "host1",
+            "state": "up",
+            "status": "disabled",
+            "updated_at": "2012-10-29T13:42:05.000000",
+            "forced_down": false,
+            "zone": "nova"
+        },
+        {
+            "id": "bd0b2e30-809e-4160-bd3d-f23ca30e9b68",
+            "binary": "nova-scheduler",
+            "disabled_reason": null,
+            "host": "host2",
+            "state": "down",
+            "status": "enabled",
+            "updated_at": "2012-09-19T06:55:34.000000",
+            "forced_down": false,
+            "zone": "internal"
+        },
+        {
+            "id": "fe41c476-33e2-4ac3-ad21-3ffaf1b9c644",
+            "binary": "nova-compute",
+            "disabled_reason": "test4",
+            "host": "host2",
+            "state": "down",
+            "status": "disabled",
+            "updated_at": "2012-09-18T08:03:38.000000",
+            "forced_down": false,
+            "zone": "nova"
+        }
+    ]
+}
+`
+
+var (
+	// FirstFakeService represents the first service from the ServiceListBody.
+	FirstFakeService = services.Service{
+		Binary:         "nova-scheduler",
+		DisabledReason: "test1",
+		Host:           "host1",
+		ID:             "4c720fa0-02c3-4834-8279-9eecf9edb6cb",
+		State:          "up",
+		Status:         "disabled",
+		UpdatedAt:      time.Date(2012, 10, 29, 13, 42, 2, 0, time.UTC),
+		Zone:           "internal",
+	}
+
+	// SecondFakeService represents the second service from the ServiceListBody.
+	SecondFakeService = services.Service{
+		Binary:         "nova-compute",
+		DisabledReason: "test2",
+		Host:           "host1",
+		ID:             "1fdfec3e-ee03-4e36-b99b-71cf2967b70c",
+		State:          "up",
+		Status:         "disabled",
+		UpdatedAt:      time.Date(2012, 10, 29, 13, 42, 5, 0, time.UTC),
+		Zone:           "nova",
+	}
+
+	// ThirdFakeService represents the third service from the ServiceListBody.
+	ThirdFakeService = services.Service{
+		Binary:         "nova-scheduler",
+		DisabledReason: "",
+		Host:           "host2",
+		ID:             "bd0b2e30-809e-4160-bd3d-f23ca30e9b68",
+		State:          "down",
+		Status:         "enabled",
+		UpdatedAt:      time.Date(2012, 9, 19, 6, 55, 34, 0, time.UTC),
+		Zone:           "internal",
+	}
+
+	// FourthFakeService represents the fourth service from the ServiceListBody.
+	FourthFakeService = services.Service{
+		Binary:         "nova-compute",
+		DisabledReason: "test4",
+		Host:           "host2",
+		ID:             "fe41c476-33e2-4ac3-ad21-3ffaf1b9c644",
+		State:          "down",
+		Status:         "disabled",
+		UpdatedAt:      time.Date(2012, 9, 18, 8, 3, 38, 0, time.UTC),
+		Zone:           "nova",
+	}
+)
+
+// ServiceUpdate represents a raw service from the Compute service update API
+const ServiceUpdate = `
+{
+	"service":
+	{
+		"id": 1,
+		"binary": "nova-scheduler",
+		"disabled_reason": "test1",
+		"host": "host1",
+		"state": "up",
+		"status": "disabled",
+		"updated_at": "2012-10-29T13:42:02.000000",
+		"forced_down": false,
+		"zone": "internal"
+	}
+}
+`
+
+//FakeServiceUpdateBody represents the updated service
+var FakeServiceUpdateBody = services.Service{
+	Binary:         "nova-scheduler",
+	DisabledReason: "test1",
+	ForcedDown:     false,
+	Host:           "host1",
+	ID:             "1",
+	State:          "up",
+	Status:         "disabled",
+	UpdatedAt:      time.Date(2012, 10, 29, 13, 42, 2, 0, time.UTC),
+	Zone:           "internal",
+}
+
+// HandleListPre253Successfully configures the test server to respond to a List
+// request to a Compute server API pre 2.53 microversion release.
+func HandleListPre253Successfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-services", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ServiceListBodyPre253)
+	})
+}
+
+// HandleListSuccessfully configures the test server to respond to a List
+// request to a Compute server with Pike+ release.
+func HandleListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-services", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ServiceListBody)
+	})
+}
+
+// HandleUpdateSuccessfully configures the test server to respond to a Update
+// request to a Compute server with Pike+ release.
+func HandleUpdateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-services/fake-service-id", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "PUT")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestHeader(t, r, "Accept", "application/json")
+		th.TestHeader(t, r, "Content-Type", "application/json")
+		th.TestJSONRequest(t, r, `{"status": "disabled"}`)
+
+		fmt.Fprintf(w, ServiceUpdate)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/testing/requests_test.go
new file mode 100644
index 000000000..fc75471a7
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/testing/requests_test.go
@@ -0,0 +1,92 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services"
+	"github.com/gophercloud/gophercloud/pagination"
+	"github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestListServicesPre253(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleListPre253Successfully(t)
+
+	pages := 0
+	err := services.List(client.ServiceClient(), nil).EachPage(func(page pagination.Page) (bool, error) {
+		pages++
+
+		actual, err := services.ExtractServices(page)
+		if err != nil {
+			return false, err
+		}
+
+		if len(actual) != 4 {
+			t.Fatalf("Expected 4 services, got %d", len(actual))
+		}
+		testhelper.CheckDeepEquals(t, FirstFakeServicePre253, actual[0])
+		testhelper.CheckDeepEquals(t, SecondFakeServicePre253, actual[1])
+		testhelper.CheckDeepEquals(t, ThirdFakeServicePre253, actual[2])
+		testhelper.CheckDeepEquals(t, FourthFakeServicePre253, actual[3])
+
+		return true, nil
+	})
+
+	testhelper.AssertNoErr(t, err)
+
+	if pages != 1 {
+		t.Errorf("Expected 1 page, saw %d", pages)
+	}
+}
+
+func TestListServices(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleListSuccessfully(t)
+
+	pages := 0
+	opts := services.ListOpts{
+		Binary: "fake-binary",
+		Host:   "host123",
+	}
+	err := services.List(client.ServiceClient(), opts).EachPage(func(page pagination.Page) (bool, error) {
+		pages++
+
+		actual, err := services.ExtractServices(page)
+		if err != nil {
+			return false, err
+		}
+
+		if len(actual) != 4 {
+			t.Fatalf("Expected 4 services, got %d", len(actual))
+		}
+		testhelper.CheckDeepEquals(t, FirstFakeService, actual[0])
+		testhelper.CheckDeepEquals(t, SecondFakeService, actual[1])
+		testhelper.CheckDeepEquals(t, ThirdFakeService, actual[2])
+		testhelper.CheckDeepEquals(t, FourthFakeService, actual[3])
+
+		return true, nil
+	})
+
+	testhelper.AssertNoErr(t, err)
+
+	if pages != 1 {
+		t.Errorf("Expected 1 page, saw %d", pages)
+	}
+}
+
+func TestUpdateService(t *testing.T) {
+	testhelper.SetupHTTP()
+	defer testhelper.TeardownHTTP()
+	HandleUpdateSuccessfully(t)
+
+	client := client.ServiceClient()
+	actual, err := services.Update(client, "fake-service-id", services.UpdateOpts{Status: services.ServiceDisabled}).Extract()
+	if err != nil {
+		t.Fatalf("Unexpected Update error: %v", err)
+	}
+
+	testhelper.CheckDeepEquals(t, FakeServiceUpdateBody, *actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/urls.go
new file mode 100644
index 000000000..49690efb2
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/services/urls.go
@@ -0,0 +1,11 @@
+package services
+
+import "github.com/gophercloud/gophercloud"
+
+func listURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL("os-services")
+}
+
+func updateURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL("os-services", id)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/doc.go
new file mode 100644
index 000000000..0d33f47fc
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/doc.go
@@ -0,0 +1,24 @@
+/*
+Package shelveunshelve provides functionality to start and stop servers that have
+been provisioned by the OpenStack Compute service.
+
+Example to Shelve, Shelve-offload and Unshelve a Server
+
+	serverID := "47b6b7b7-568d-40e4-868c-d5c41735532e"
+
+	err := shelveunshelve.Shelve(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+	err := shelveunshelve.ShelveOffload(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+	err := shelveunshelve.Unshelve(computeClient, serverID, nil).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package shelveunshelve
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/requests.go
new file mode 100644
index 000000000..b238e220c
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/requests.go
@@ -0,0 +1,57 @@
+package shelveunshelve
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// Shelve is the operation responsible for shelving a Compute server.
+func Shelve(client *gophercloud.ServiceClient, id string) (r ShelveResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"shelve": nil}, nil, nil)
+	return
+}
+
+// ShelveOffload is the operation responsible for Shelve-Offload a Compute server.
+func ShelveOffload(client *gophercloud.ServiceClient, id string) (r ShelveOffloadResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"shelveOffload": nil}, nil, nil)
+	return
+}
+
+// UnshelveOptsBuilder allows extensions to add additional parameters to the
+// Unshelve request.
+type UnshelveOptsBuilder interface {
+	ToUnshelveMap() (map[string]interface{}, error)
+}
+
+// UnshelveOpts specifies parameters of shelve-offload action.
+type UnshelveOpts struct {
+	// Sets the availability zone to unshelve a server
+	// Available only after nova 2.77
+	AvailabilityZone string `json:"availability_zone,omitempty"`
+}
+
+func (opts UnshelveOpts) ToUnshelveMap() (map[string]interface{}, error) {
+	// Key 'availabilty_zone' is required if the unshelve action is an object
+	// i.e {"unshelve": {}} will be rejected
+	b, err := gophercloud.BuildRequestBody(opts, "unshelve")
+	if err != nil {
+		return nil, err
+	}
+
+	if _, ok := b["unshelve"].(map[string]interface{})["availability_zone"]; !ok {
+		b["unshelve"] = nil
+	}
+
+	return b, err
+}
+
+// Unshelve is the operation responsible for unshelve a Compute server.
+func Unshelve(client *gophercloud.ServiceClient, id string, opts UnshelveOptsBuilder) (r UnshelveResult) {
+	b, err := opts.ToUnshelveMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(extensions.ActionURL(client, id), b, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/results.go
new file mode 100644
index 000000000..7d2cefffe
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/results.go
@@ -0,0 +1,21 @@
+package shelveunshelve
+
+import "github.com/gophercloud/gophercloud"
+
+// ShelveResult is the response from a Shelve operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type ShelveResult struct {
+	gophercloud.ErrResult
+}
+
+// ShelveOffloadResult is the response from a Shelve operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type ShelveOffloadResult struct {
+	gophercloud.ErrResult
+}
+
+// UnshelveResult is the response from Stop operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type UnshelveResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/testing/fixtures.go
new file mode 100644
index 000000000..0f13cee67
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/testing/fixtures.go
@@ -0,0 +1,50 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func mockShelveServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"shelve": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockShelveOffloadServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"shelveOffload": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockUnshelveServerResponseWithAvailabilityZone(t *testing.T, id string, az string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, fmt.Sprintf(`{
+			"unshelve": {
+				"availability_zone": "%s"
+			} 
+		}`, az))
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockUnshelveServerResponseNoAvailabilityZone(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"unshelve": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/testing/requests_test.go
new file mode 100644
index 000000000..e2a2f8a1e
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve/testing/requests_test.go
@@ -0,0 +1,58 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/shelveunshelve"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const serverID = "{serverId}"
+const availabilityZone = "test-zone"
+
+func TestShelve(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockShelveServerResponse(t, serverID)
+
+	err := shelveunshelve.Shelve(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestShelveOffload(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockShelveOffloadServerResponse(t, serverID)
+
+	err := shelveunshelve.ShelveOffload(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestUnshelveNoAvailabilityZone(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	unshelveOpts := shelveunshelve.UnshelveOpts{}
+
+	mockUnshelveServerResponseNoAvailabilityZone(t, serverID)
+
+	err := shelveunshelve.Unshelve(client.ServiceClient(), serverID, unshelveOpts).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestUnshelveWithAvailabilityZone(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	unshelveOpts := shelveunshelve.UnshelveOpts{
+		AvailabilityZone: availabilityZone,
+	}
+
+	mockUnshelveServerResponseWithAvailabilityZone(t, serverID, availabilityZone)
+
+	err := shelveunshelve.Unshelve(client.ServiceClient(), serverID, unshelveOpts).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/doc.go
new file mode 100644
index 000000000..ab97edb77
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/doc.go
@@ -0,0 +1,19 @@
+/*
+Package startstop provides functionality to start and stop servers that have
+been provisioned by the OpenStack Compute service.
+
+Example to Stop and Start a Server
+
+	serverID := "47b6b7b7-568d-40e4-868c-d5c41735532e"
+
+	err := startstop.Stop(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+	err := startstop.Start(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package startstop
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/requests.go
new file mode 100644
index 000000000..db55a52aa
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/requests.go
@@ -0,0 +1,18 @@
+package startstop
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// Start is the operation responsible for starting a Compute server.
+func Start(client *gophercloud.ServiceClient, id string) (r StartResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"os-start": nil}, nil, nil)
+	return
+}
+
+// Stop is the operation responsible for stopping a Compute server.
+func Stop(client *gophercloud.ServiceClient, id string) (r StopResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"os-stop": nil}, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/results.go
new file mode 100644
index 000000000..834968933
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/results.go
@@ -0,0 +1,15 @@
+package startstop
+
+import "github.com/gophercloud/gophercloud"
+
+// StartResult is the response from a Start operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type StartResult struct {
+	gophercloud.ErrResult
+}
+
+// StopResult is the response from Stop operation. Call its ExtractErr
+// method to determine if the request succeeded or failed.
+type StopResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/doc.go
new file mode 100644
index 000000000..b6c5b8c14
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/doc.go
@@ -0,0 +1,2 @@
+// startstop unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/fixtures.go
new file mode 100644
index 000000000..1086b0e34
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/fixtures.go
@@ -0,0 +1,27 @@
+package testing
+
+import (
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func mockStartServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"os-start": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockStopServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"os-stop": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/requests_test.go
new file mode 100644
index 000000000..be45bf5c7
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop/testing/requests_test.go
@@ -0,0 +1,31 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const serverID = "{serverId}"
+
+func TestStart(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockStartServerResponse(t, serverID)
+
+	err := startstop.Start(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestStop(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockStopServerResponse(t, serverID)
+
+	err := startstop.Stop(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/doc.go
new file mode 100644
index 000000000..9851000e8
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/doc.go
@@ -0,0 +1,19 @@
+/*
+Package suspendresume provides functionality to suspend and resume servers that have
+been provisioned by the OpenStack Compute service.
+
+Example to Suspend and Resume a Server
+
+	serverID := "47b6b7b7-568d-40e4-868c-d5c41735532e"
+
+	err := suspendresume.Suspend(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+
+	err := suspendresume.Resume(computeClient, serverID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package suspendresume
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/requests.go
new file mode 100644
index 000000000..c15448814
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/requests.go
@@ -0,0 +1,18 @@
+package suspendresume
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+)
+
+// Suspend is the operation responsible for suspending a Compute server.
+func Suspend(client *gophercloud.ServiceClient, id string) (r SuspendResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"suspend": nil}, nil, nil)
+	return
+}
+
+// Resume is the operation responsible for resuming a Compute server.
+func Resume(client *gophercloud.ServiceClient, id string) (r UnsuspendResult) {
+	_, r.Err = client.Post(extensions.ActionURL(client, id), map[string]interface{}{"resume": nil}, nil, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/results.go
new file mode 100644
index 000000000..988d83e4a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/results.go
@@ -0,0 +1,15 @@
+package suspendresume
+
+import "github.com/gophercloud/gophercloud"
+
+// SuspendResult is the response from a Suspend operation. Call its
+// ExtractErr method to determine if the request succeeded or failed.
+type SuspendResult struct {
+	gophercloud.ErrResult
+}
+
+// UnsuspendResult is the response from an Unsuspend operation. Call
+// its ExtractErr method to determine if the request succeeded or failed.
+type UnsuspendResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/doc.go
new file mode 100644
index 000000000..834f25516
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/doc.go
@@ -0,0 +1,2 @@
+// suspendresume unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/fixtures.go
new file mode 100644
index 000000000..5c6405dee
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/fixtures.go
@@ -0,0 +1,27 @@
+package testing
+
+import (
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func mockSuspendServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"suspend": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
+
+func mockResumeServerResponse(t *testing.T, id string) {
+	th.Mux.HandleFunc("/servers/"+id+"/action", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `{"resume": null}`)
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/requests_test.go
new file mode 100644
index 000000000..7c8e4ec6b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume/testing/requests_test.go
@@ -0,0 +1,31 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/suspendresume"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const serverID = "{serverId}"
+
+func TestSuspend(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockSuspendServerResponse(t, serverID)
+
+	err := suspendresume.Suspend(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestResume(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	mockResumeServerResponse(t, serverID)
+
+	err := suspendresume.Resume(client.ServiceClient(), serverID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/doc.go
new file mode 100644
index 000000000..f3ef25a15
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/doc.go
@@ -0,0 +1,70 @@
+/*
+Package tags manages Tags on Compute V2 servers.
+
+This extension is available since 2.26 Compute V2 API microversion.
+
+Example to List all server Tags
+
+	client.Microversion = "2.26"
+
+    serverTags, err := tags.List(client, serverID).Extract()
+    if err != nil {
+        log.Fatal(err)
+    }
+
+    fmt.Printf("Tags: %v\n", serverTags)
+
+Example to Check if the specific Tag exists on a server
+
+    client.Microversion = "2.26"
+
+    exists, err := tags.Check(client, serverID, tag).Extract()
+    if err != nil {
+        log.Fatal(err)
+    }
+
+    if exists {
+        log.Printf("Tag %s is set\n", tag)
+    } else {
+        log.Printf("Tag %s is not set\n", tag)
+    }
+
+Example to Replace all Tags on a server
+
+    client.Microversion = "2.26"
+
+    newTags, err := tags.ReplaceAll(client, serverID, tags.ReplaceAllOpts{Tags: []string{"foo", "bar"}}).Extract()
+    if err != nil {
+        log.Fatal(err)
+    }
+
+    fmt.Printf("New tags: %v\n", newTags)
+
+Example to Add a new Tag on a server
+
+    client.Microversion = "2.26"
+
+    err := tags.Add(client, serverID, "foo").ExtractErr()
+    if err != nil {
+        log.Fatal(err)
+    }
+
+Example to Delete a Tag on a server
+
+    client.Microversion = "2.26"
+
+    err := tags.Delete(client, serverID, "foo").ExtractErr()
+    if err != nil {
+        log.Fatal(err)
+    }
+
+Example to Delete all Tags on a server
+
+    client.Microversion = "2.26"
+
+    err := tags.DeleteAll(client, serverID).ExtractErr()
+    if err != nil {
+        log.Fatal(err)
+    }
+*/
+package tags
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/requests.go
new file mode 100644
index 000000000..3b4309641
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/requests.go
@@ -0,0 +1,77 @@
+package tags
+
+import "github.com/gophercloud/gophercloud"
+
+// List all tags on a server.
+func List(client *gophercloud.ServiceClient, serverID string) (r ListResult) {
+	url := listURL(client, serverID)
+	_, r.Err = client.Get(url, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Check if a tag exists on a server.
+func Check(client *gophercloud.ServiceClient, serverID, tag string) (r CheckResult) {
+	url := checkURL(client, serverID, tag)
+	_, r.Err = client.Get(url, nil, &gophercloud.RequestOpts{
+		OkCodes: []int{204},
+	})
+	return
+}
+
+// ReplaceAllOptsBuilder allows to add additional parameters to the ReplaceAll request.
+type ReplaceAllOptsBuilder interface {
+	ToTagsReplaceAllMap() (map[string]interface{}, error)
+}
+
+// ReplaceAllOpts provides options used to replace Tags on a server.
+type ReplaceAllOpts struct {
+	Tags []string `json:"tags" required:"true"`
+}
+
+// ToTagsReplaceAllMap formats a ReplaceALlOpts into the body of the ReplaceAll request.
+func (opts ReplaceAllOpts) ToTagsReplaceAllMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "")
+}
+
+// ReplaceAll replaces all Tags on a server.
+func ReplaceAll(client *gophercloud.ServiceClient, serverID string, opts ReplaceAllOptsBuilder) (r ReplaceAllResult) {
+	b, err := opts.ToTagsReplaceAllMap()
+	url := replaceAllURL(client, serverID)
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Put(url, &b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Add adds a new Tag on a server.
+func Add(client *gophercloud.ServiceClient, serverID, tag string) (r AddResult) {
+	url := addURL(client, serverID, tag)
+	_, r.Err = client.Put(url, nil, nil, &gophercloud.RequestOpts{
+		OkCodes: []int{201, 204},
+	})
+	return
+}
+
+// Delete removes a tag from a server.
+func Delete(client *gophercloud.ServiceClient, serverID, tag string) (r DeleteResult) {
+	url := deleteURL(client, serverID, tag)
+	_, r.Err = client.Delete(url, &gophercloud.RequestOpts{
+		OkCodes: []int{204},
+	})
+	return
+}
+
+// DeleteAll removes all tag from a server.
+func DeleteAll(client *gophercloud.ServiceClient, serverID string) (r DeleteResult) {
+	url := deleteAllURL(client, serverID)
+	_, r.Err = client.Delete(url, &gophercloud.RequestOpts{
+		OkCodes: []int{204},
+	})
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/results.go
new file mode 100644
index 000000000..c73b7a6cb
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/results.go
@@ -0,0 +1,52 @@
+package tags
+
+import "github.com/gophercloud/gophercloud"
+
+type commonResult struct {
+	gophercloud.Result
+}
+
+// Extract is a function that accepts a result and extracts a tags resource.
+func (r commonResult) Extract() ([]string, error) {
+	var s struct {
+		Tags []string `json:"tags"`
+	}
+	err := r.ExtractInto(&s)
+	return s.Tags, err
+}
+
+type ListResult struct {
+	commonResult
+}
+
+// CheckResult is the result from the Check operation.
+type CheckResult struct {
+	gophercloud.Result
+}
+
+func (r CheckResult) Extract() (bool, error) {
+	exists := r.Err == nil
+
+	if r.Err != nil {
+		if _, ok := r.Err.(gophercloud.ErrDefault404); ok {
+			r.Err = nil
+		}
+	}
+
+	return exists, r.Err
+}
+
+// ReplaceAllResult is the result from the ReplaceAll operation.
+type ReplaceAllResult struct {
+	commonResult
+}
+
+// AddResult is the result from the Add operation.
+type AddResult struct {
+	gophercloud.ErrResult
+}
+
+// DeleteResult is the result from the Delete operation.
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/doc.go
new file mode 100644
index 000000000..fce31e522
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/doc.go
@@ -0,0 +1,2 @@
+// tags unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/fixtures.go
new file mode 100644
index 000000000..8b62cda42
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/fixtures.go
@@ -0,0 +1,22 @@
+package testing
+
+// TagsListResponse represents a raw tags response.
+const TagsListResponse = `
+{
+    "tags": ["foo", "bar", "baz"]
+}
+`
+
+// TagsReplaceAllRequest represents a raw tags Replace request.
+const TagsReplaceAllRequest = `
+{
+    "tags": ["tag1", "tag2", "tag3"]
+}
+`
+
+// TagsReplaceAllResponse represents a raw tags Replace response.
+const TagsReplaceAllResponse = `
+{
+    "tags": ["tag1", "tag2", "tag3"]
+}
+`
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/requests_test.go
new file mode 100644
index 000000000..bc0eb8ec5
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/testing/requests_test.go
@@ -0,0 +1,153 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/uuid1/tags", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, http.MethodGet)
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		_, err := fmt.Fprintf(w, TagsListResponse)
+		th.AssertNoErr(t, err)
+	})
+
+	expected := []string{"foo", "bar", "baz"}
+	actual, err := tags.List(client.ServiceClient(), "uuid1").Extract()
+
+	th.AssertNoErr(t, err)
+	th.AssertDeepEquals(t, expected, actual)
+}
+
+func TestCheckOk(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/uuid1/tags/foo", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, http.MethodGet)
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusNoContent)
+	})
+
+	exists, err := tags.Check(client.ServiceClient(), "uuid1", "foo").Extract()
+	th.AssertNoErr(t, err)
+	th.AssertEquals(t, true, exists)
+}
+
+func TestCheckFail(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/uuid1/tags/bar", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, http.MethodGet)
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusNotFound)
+	})
+
+	exists, err := tags.Check(client.ServiceClient(), "uuid1", "bar").Extract()
+	th.AssertNoErr(t, err)
+	th.AssertEquals(t, false, exists)
+}
+
+func TestReplaceAll(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/uuid1/tags", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, http.MethodPut)
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		_, err := fmt.Fprintf(w, TagsReplaceAllResponse)
+		th.AssertNoErr(t, err)
+	})
+
+	expected := []string{"tag1", "tag2", "tag3"}
+	actual, err := tags.ReplaceAll(client.ServiceClient(), "uuid1", tags.ReplaceAllOpts{Tags: []string{"tag1", "tag2", "tag3"}}).Extract()
+
+	th.AssertNoErr(t, err)
+	th.AssertDeepEquals(t, expected, actual)
+}
+
+func TestAddCreated(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/uuid1/tags/foo", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, http.MethodPut)
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusCreated)
+	})
+
+	err := tags.Add(client.ServiceClient(), "uuid1", "foo").ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestAddExists(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/uuid1/tags/foo", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, http.MethodPut)
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusNoContent)
+	})
+
+	err := tags.Add(client.ServiceClient(), "uuid1", "foo").ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestDelete(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/uuid1/tags/foo", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, http.MethodDelete)
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusNoContent)
+	})
+
+	err := tags.Delete(client.ServiceClient(), "uuid1", "foo").ExtractErr()
+	th.AssertNoErr(t, err)
+}
+
+func TestDeleteAll(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	th.Mux.HandleFunc("/servers/uuid1/tags", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, http.MethodDelete)
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusNoContent)
+	})
+
+	err := tags.DeleteAll(client.ServiceClient(), "uuid1").ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/urls.go
new file mode 100644
index 000000000..64296887a
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tags/urls.go
@@ -0,0 +1,40 @@
+package tags
+
+import "github.com/gophercloud/gophercloud"
+
+const (
+	rootResourcePath = "servers"
+	resourcePath     = "tags"
+)
+
+func rootURL(c *gophercloud.ServiceClient, serverID string) string {
+	return c.ServiceURL(rootResourcePath, serverID, resourcePath)
+}
+
+func resourceURL(c *gophercloud.ServiceClient, serverID, tag string) string {
+	return c.ServiceURL(rootResourcePath, serverID, resourcePath, tag)
+}
+
+func listURL(c *gophercloud.ServiceClient, serverID string) string {
+	return rootURL(c, serverID)
+}
+
+func checkURL(c *gophercloud.ServiceClient, serverID, tag string) string {
+	return resourceURL(c, serverID, tag)
+}
+
+func replaceAllURL(c *gophercloud.ServiceClient, serverID string) string {
+	return rootURL(c, serverID)
+}
+
+func addURL(c *gophercloud.ServiceClient, serverID, tag string) string {
+	return resourceURL(c, serverID, tag)
+}
+
+func deleteURL(c *gophercloud.ServiceClient, serverID, tag string) string {
+	return resourceURL(c, serverID, tag)
+}
+
+func deleteAllURL(c *gophercloud.ServiceClient, serverID string) string {
+	return rootURL(c, serverID)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/doc.go
new file mode 100644
index 000000000..a32e8ffd5
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/doc.go
@@ -0,0 +1,26 @@
+/*
+Package tenantnetworks provides the ability for tenants to see information
+about the networks they have access to.
+
+This is a deprecated API and will be removed from the Nova API service in a
+future version.
+
+This API works in both Neutron and nova-network based OpenStack clouds.
+
+Example to List Networks Available to a Tenant
+
+	allPages, err := tenantnetworks.List(computeClient).AllPages()
+	if err != nil {
+		panic(err)
+	}
+
+	allNetworks, err := tenantnetworks.ExtractNetworks(allPages)
+	if err != nil {
+		panic(err)
+	}
+
+	for _, network := range allNetworks {
+		fmt.Printf("%+v\n", network)
+	}
+*/
+package tenantnetworks
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/requests.go
new file mode 100644
index 000000000..00899056f
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/requests.go
@@ -0,0 +1,19 @@
+package tenantnetworks
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List returns a Pager that allows you to iterate over a collection of Networks.
+func List(client *gophercloud.ServiceClient) pagination.Pager {
+	return pagination.NewPager(client, listURL(client), func(r pagination.PageResult) pagination.Page {
+		return NetworkPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// Get returns data about a previously created Network.
+func Get(client *gophercloud.ServiceClient, id string) (r GetResult) {
+	_, r.Err = client.Get(getURL(client, id), &r.Body, nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/results.go
new file mode 100644
index 000000000..bda77d5f5
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/results.go
@@ -0,0 +1,58 @@
+package tenantnetworks
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// A Network represents a network that a server communicates on.
+type Network struct {
+	// CIDR is the IPv4 subnet.
+	CIDR string `json:"cidr"`
+
+	// ID is the UUID of the network.
+	ID string `json:"id"`
+
+	// Name is the common name that the network has.
+	Name string `json:"label"`
+}
+
+// NetworkPage stores a single page of all Networks results from a List call.
+type NetworkPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a NetworkPage is empty.
+func (page NetworkPage) IsEmpty() (bool, error) {
+	va, err := ExtractNetworks(page)
+	return len(va) == 0, err
+}
+
+// ExtractNetworks interprets a page of results as a slice of Network.
+func ExtractNetworks(r pagination.Page) ([]Network, error) {
+	var s struct {
+		Networks []Network `json:"networks"`
+	}
+	err := (r.(NetworkPage)).ExtractInto(&s)
+	return s.Networks, err
+}
+
+type NetworkResult struct {
+	gophercloud.Result
+}
+
+// Extract is a method that attempts to interpret any Network resource response
+// as a Network struct.
+func (r NetworkResult) Extract() (*Network, error) {
+	var s struct {
+		Network *Network `json:"network"`
+	}
+	err := r.ExtractInto(&s)
+	return s.Network, err
+}
+
+// GetResult is the response from a Get operation. Call its Extract method to
+// interpret it as a Network.
+type GetResult struct {
+	NetworkResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/doc.go
new file mode 100644
index 000000000..4639153ff
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/doc.go
@@ -0,0 +1,2 @@
+// tenantnetworks unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/fixtures.go
new file mode 100644
index 000000000..ae679b46e
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/fixtures.go
@@ -0,0 +1,83 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+	"time"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ListOutput is a sample response to a List call.
+const ListOutput = `
+{
+    "networks": [
+        {
+            "cidr": "10.0.0.0/29",
+            "id": "20c8acc0-f747-4d71-a389-46d078ebf047",
+            "label": "mynet_0"
+        },
+        {
+            "cidr": "10.0.0.10/29",
+            "id": "20c8acc0-f747-4d71-a389-46d078ebf000",
+            "label": "mynet_1"
+        }
+    ]
+}
+`
+
+// GetOutput is a sample response to a Get call.
+const GetOutput = `
+{
+    "network": {
+			"cidr": "10.0.0.10/29",
+			"id": "20c8acc0-f747-4d71-a389-46d078ebf000",
+			"label": "mynet_1"
+		}
+}
+`
+
+// FirstNetwork is the first result in ListOutput.
+var nilTime time.Time
+var FirstNetwork = tenantnetworks.Network{
+	CIDR: "10.0.0.0/29",
+	ID:   "20c8acc0-f747-4d71-a389-46d078ebf047",
+	Name: "mynet_0",
+}
+
+// SecondNetwork is the second result in ListOutput.
+var SecondNetwork = tenantnetworks.Network{
+	CIDR: "10.0.0.10/29",
+	ID:   "20c8acc0-f747-4d71-a389-46d078ebf000",
+	Name: "mynet_1",
+}
+
+// ExpectedNetworkSlice is the slice of results that should be parsed
+// from ListOutput, in the expected order.
+var ExpectedNetworkSlice = []tenantnetworks.Network{FirstNetwork, SecondNetwork}
+
+// HandleListSuccessfully configures the test server to respond to a List request.
+func HandleListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-tenant-networks", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ListOutput)
+	})
+}
+
+// HandleGetSuccessfully configures the test server to respond to a Get request
+// for an existing network.
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-tenant-networks/20c8acc0-f747-4d71-a389-46d078ebf000", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/requests_test.go
new file mode 100644
index 000000000..703c8468b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/testing/requests_test.go
@@ -0,0 +1,38 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleListSuccessfully(t)
+
+	count := 0
+	err := tenantnetworks.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := tenantnetworks.ExtractNetworks(page)
+		th.AssertNoErr(t, err)
+		th.CheckDeepEquals(t, ExpectedNetworkSlice, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.CheckEquals(t, 1, count)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSuccessfully(t)
+
+	actual, err := tenantnetworks.Get(client.ServiceClient(), "20c8acc0-f747-4d71-a389-46d078ebf000").Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &SecondNetwork, actual)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/urls.go
new file mode 100644
index 000000000..683041ded
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/tenantnetworks/urls.go
@@ -0,0 +1,17 @@
+package tenantnetworks
+
+import "github.com/gophercloud/gophercloud"
+
+const resourcePath = "os-tenant-networks"
+
+func resourceURL(c *gophercloud.ServiceClient) string {
+	return c.ServiceURL(resourcePath)
+}
+
+func listURL(c *gophercloud.ServiceClient) string {
+	return resourceURL(c)
+}
+
+func getURL(c *gophercloud.ServiceClient, id string) string {
+	return c.ServiceURL(resourcePath, id)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/delegate_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/delegate_test.go
new file mode 100644
index 000000000..822093ff4
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/delegate_test.go
@@ -0,0 +1,56 @@
+package testing
+
+import (
+	"testing"
+
+	common "github.com/gophercloud/gophercloud/openstack/common/extensions"
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleListExtensionsSuccessfully(t)
+
+	count := 0
+	extensions.List(client.ServiceClient()).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := extensions.ExtractExtensions(page)
+		th.AssertNoErr(t, err)
+
+		expected := []common.Extension{
+			common.Extension{
+				Updated:     "2013-01-20T00:00:00-00:00",
+				Name:        "Neutron Service Type Management",
+				Links:       []interface{}{},
+				Namespace:   "http://docs.openstack.org/ext/neutron/service-type/api/v1.0",
+				Alias:       "service-type",
+				Description: "API for retrieving service providers for Neutron advanced services",
+			},
+		}
+		th.AssertDeepEquals(t, expected, actual)
+
+		return true, nil
+	})
+	th.CheckEquals(t, 1, count)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleGetExtensionsSuccessfully(t)
+
+	ext, err := extensions.Get(client.ServiceClient(), "agent").Extract()
+	th.AssertNoErr(t, err)
+
+	th.AssertEquals(t, ext.Updated, "2013-02-03T10:00:00-00:00")
+	th.AssertEquals(t, ext.Name, "agent")
+	th.AssertEquals(t, ext.Namespace, "http://docs.openstack.org/ext/agent/api/v2.0")
+	th.AssertEquals(t, ext.Alias, "agent")
+	th.AssertEquals(t, ext.Description, "The agent management extension.")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/doc.go
new file mode 100644
index 000000000..3c5d45926
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/doc.go
@@ -0,0 +1,2 @@
+// extensions unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/fixtures.go
new file mode 100644
index 000000000..2a3fb6909
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/testing/fixtures.go
@@ -0,0 +1,57 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func HandleListExtensionsSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/extensions", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+
+		fmt.Fprintf(w, `
+{
+		"extensions": [
+				{
+						"updated": "2013-01-20T00:00:00-00:00",
+						"name": "Neutron Service Type Management",
+						"links": [],
+						"namespace": "http://docs.openstack.org/ext/neutron/service-type/api/v1.0",
+						"alias": "service-type",
+						"description": "API for retrieving service providers for Neutron advanced services"
+				}
+		]
+}
+			`)
+	})
+}
+
+func HandleGetExtensionsSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/extensions/agent", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		w.WriteHeader(http.StatusOK)
+
+		fmt.Fprintf(w, `
+{
+		"extension": {
+				"updated": "2013-02-03T10:00:00-00:00",
+				"name": "agent",
+				"links": [],
+				"namespace": "http://docs.openstack.org/ext/agent/api/v2.0",
+				"alias": "agent",
+				"description": "The agent management extension."
+		}
+}
+		`)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/urls.go
new file mode 100644
index 000000000..9d40e4950
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/urls.go
@@ -0,0 +1,7 @@
+package extensions
+
+import "github.com/gophercloud/gophercloud"
+
+func ActionURL(client *gophercloud.ServiceClient, id string) string {
+	return client.ServiceURL("servers", id, "action")
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/doc.go
new file mode 100644
index 000000000..16b3a284b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/doc.go
@@ -0,0 +1,59 @@
+/*
+Package usage provides information and interaction with the
+SimpleTenantUsage extension for the OpenStack Compute service.
+
+Due to the way the API responses are formatted, it is not recommended to
+query by using the AllPages convenience method. Instead, use the EachPage
+method to view each result page-by-page.
+
+This is because the usage calculations are done _per page_ and not as
+an aggregated total of the entire usage set.
+
+Example to Retrieve Usage for a Single Tenant:
+
+	start := time.Date(2017, 01, 21, 10, 4, 20, 0, time.UTC)
+	end := time.Date(2017, 01, 21, 10, 4, 20, 0, time.UTC)
+
+	singleTenantOpts := usage.SingleTenantOpts{
+		Start: &start,
+		End: &end,
+	}
+
+	err := usage.SingleTenant(computeClient, tenantID, singleTenantOpts).EachPage(func(page pagination.Page) (bool, error) {
+		tenantUsage, err := usage.ExtractSingleTenant(page)
+		if err != nil {
+			return false, err
+		}
+
+		fmt.Printf("%+v\n", tenantUsage)
+
+		return true, nil
+	})
+
+	if err != nil {
+		panic(err)
+	}
+
+Example to Retrieve Usage for All Tenants:
+
+	allTenantsOpts := usage.AllTenantsOpts{
+		Detailed: true,
+	}
+
+	err := usage.AllTenants(computeClient, allTenantsOpts).EachPage(func(page pagination.Page) (bool, error) {
+		allTenantsUsage, err := usage.ExtractAllTenants(page)
+		if err != nil {
+			return false, err
+		}
+
+		fmt.Printf("%+v\n", allTenantsUsage)
+
+		return true, nil
+	})
+
+	if err != nil {
+		panic(err)
+	}
+
+*/
+package usage
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/requests.go
new file mode 100644
index 000000000..eb36f59b7
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/requests.go
@@ -0,0 +1,134 @@
+package usage
+
+import (
+	"net/url"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// SingleTenantOpts are options for fetching usage of a single tenant.
+type SingleTenantOpts struct {
+	// The ending time to calculate usage statistics on compute and storage resources.
+	End *time.Time `q:"end"`
+
+	// The beginning time to calculate usage statistics on compute and storage resources.
+	Start *time.Time `q:"start"`
+
+	// Limit limits the amount of results returned by the API.
+	// This requires the client to be set to microversion 2.40 or later.
+	Limit int `q:"limit"`
+
+	// Marker instructs the API call where to start listing from.
+	// This requires the client to be set to microversion 2.40 or later.
+	Marker string `q:"marker"`
+}
+
+// SingleTenantOptsBuilder allows extensions to add additional parameters to the
+// SingleTenant request.
+type SingleTenantOptsBuilder interface {
+	ToUsageSingleTenantQuery() (string, error)
+}
+
+// ToUsageSingleTenantQuery formats a SingleTenantOpts into a query string.
+func (opts SingleTenantOpts) ToUsageSingleTenantQuery() (string, error) {
+	q, err := gophercloud.BuildQueryString(opts)
+	if err != nil {
+		return "", err
+	}
+
+	params := q.Query()
+
+	if opts.Start != nil {
+		params.Add("start", opts.Start.Format(gophercloud.RFC3339MilliNoZ))
+	}
+
+	if opts.End != nil {
+		params.Add("end", opts.End.Format(gophercloud.RFC3339MilliNoZ))
+	}
+
+	q = &url.URL{RawQuery: params.Encode()}
+	return q.String(), nil
+}
+
+// SingleTenant returns usage data about a single tenant.
+func SingleTenant(client *gophercloud.ServiceClient, tenantID string, opts SingleTenantOptsBuilder) pagination.Pager {
+	url := getTenantURL(client, tenantID)
+	if opts != nil {
+		query, err := opts.ToUsageSingleTenantQuery()
+		if err != nil {
+			return pagination.Pager{Err: err}
+		}
+		url += query
+	}
+	return pagination.NewPager(client, url, func(r pagination.PageResult) pagination.Page {
+		return SingleTenantPage{pagination.LinkedPageBase{PageResult: r}}
+	})
+}
+
+// AllTenantsOpts are options for fetching usage of all tenants.
+type AllTenantsOpts struct {
+	// Detailed will return detailed results.
+	Detailed bool
+
+	// The ending time to calculate usage statistics on compute and storage resources.
+	End *time.Time `q:"end"`
+
+	// The beginning time to calculate usage statistics on compute and storage resources.
+	Start *time.Time `q:"start"`
+
+	// Limit limits the amount of results returned by the API.
+	// This requires the client to be set to microversion 2.40 or later.
+	Limit int `q:"limit"`
+
+	// Marker instructs the API call where to start listing from.
+	// This requires the client to be set to microversion 2.40 or later.
+	Marker string `q:"marker"`
+}
+
+// AllTenantsOptsBuilder allows extensions to add additional parameters to the
+// AllTenants request.
+type AllTenantsOptsBuilder interface {
+	ToUsageAllTenantsQuery() (string, error)
+}
+
+// ToUsageAllTenantsQuery formats a AllTenantsOpts into a query string.
+func (opts AllTenantsOpts) ToUsageAllTenantsQuery() (string, error) {
+	q, err := gophercloud.BuildQueryString(opts)
+	if err != nil {
+		return "", err
+	}
+
+	params := q.Query()
+
+	if opts.Start != nil {
+		params.Add("start", opts.Start.Format(gophercloud.RFC3339MilliNoZ))
+	}
+
+	if opts.End != nil {
+		params.Add("end", opts.End.Format(gophercloud.RFC3339MilliNoZ))
+	}
+
+	if opts.Detailed == true {
+		params.Add("detailed", "1")
+	}
+
+	q = &url.URL{RawQuery: params.Encode()}
+	return q.String(), nil
+}
+
+// AllTenants returns usage data about all tenants.
+func AllTenants(client *gophercloud.ServiceClient, opts AllTenantsOptsBuilder) pagination.Pager {
+	url := allTenantsURL(client)
+	if opts != nil {
+		query, err := opts.ToUsageAllTenantsQuery()
+		if err != nil {
+			return pagination.Pager{Err: err}
+		}
+		url += query
+	}
+	return pagination.NewPager(client, url, func(r pagination.PageResult) pagination.Page {
+		return AllTenantsPage{pagination.LinkedPageBase{PageResult: r}}
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/results.go
new file mode 100644
index 000000000..f446730ec
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/results.go
@@ -0,0 +1,183 @@
+package usage
+
+import (
+	"encoding/json"
+	"time"
+
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// TenantUsage is a set of usage information about a tenant over the sampling window
+type TenantUsage struct {
+	// ServerUsages is an array of ServerUsage maps
+	ServerUsages []ServerUsage `json:"server_usages"`
+
+	// Start is the beginning time to calculate usage statistics on compute and storage resources
+	Start time.Time `json:"-"`
+
+	// Stop is the ending time to calculate usage statistics on compute and storage resources
+	Stop time.Time `json:"-"`
+
+	// TenantID is the ID of the tenant whose usage is being reported on
+	TenantID string `json:"tenant_id"`
+
+	// TotalHours is the total duration that servers exist (in hours)
+	TotalHours float64 `json:"total_hours"`
+
+	// TotalLocalGBUsage multiplies the server disk size (in GiB) by hours the server exists, and then adding that all together for each server
+	TotalLocalGBUsage float64 `json:"total_local_gb_usage"`
+
+	// TotalMemoryMBUsage multiplies the server memory size (in MB) by hours the server exists, and then adding that all together for each server
+	TotalMemoryMBUsage float64 `json:"total_memory_mb_usage"`
+
+	// TotalVCPUsUsage multiplies the number of virtual CPUs of the server by hours the server exists, and then adding that all together for each server
+	TotalVCPUsUsage float64 `json:"total_vcpus_usage"`
+}
+
+// UnmarshalJSON sets *u to a copy of data.
+func (u *TenantUsage) UnmarshalJSON(b []byte) error {
+	type tmp TenantUsage
+	var s struct {
+		tmp
+		Start gophercloud.JSONRFC3339MilliNoZ `json:"start"`
+		Stop  gophercloud.JSONRFC3339MilliNoZ `json:"stop"`
+	}
+
+	if err := json.Unmarshal(b, &s); err != nil {
+		return err
+	}
+	*u = TenantUsage(s.tmp)
+
+	u.Start = time.Time(s.Start)
+	u.Stop = time.Time(s.Stop)
+
+	return nil
+}
+
+// ServerUsage is a detailed set of information about a specific instance inside a tenant
+type ServerUsage struct {
+	// EndedAt is the date and time when the server was deleted
+	EndedAt time.Time `json:"-"`
+
+	// Flavor is the display name of a flavor
+	Flavor string `json:"flavor"`
+
+	// Hours is the duration that the server exists in hours
+	Hours float64 `json:"hours"`
+
+	// InstanceID is the UUID of the instance
+	InstanceID string `json:"instance_id"`
+
+	// LocalGB is the sum of the root disk size of the server and the ephemeral disk size of it (in GiB)
+	LocalGB int `json:"local_gb"`
+
+	// MemoryMB is the memory size of the server (in MB)
+	MemoryMB int `json:"memory_mb"`
+
+	// Name is the name assigned to the server when it was created
+	Name string `json:"name"`
+
+	// StartedAt is the date and time when the server was started
+	StartedAt time.Time `json:"-"`
+
+	// State is the VM power state
+	State string `json:"state"`
+
+	// TenantID is the UUID of the tenant in a multi-tenancy cloud
+	TenantID string `json:"tenant_id"`
+
+	// Uptime is the uptime of the server in seconds
+	Uptime int `json:"uptime"`
+
+	// VCPUs is the number of virtual CPUs that the server uses
+	VCPUs int `json:"vcpus"`
+}
+
+// UnmarshalJSON sets *u to a copy of data.
+func (u *ServerUsage) UnmarshalJSON(b []byte) error {
+	type tmp ServerUsage
+	var s struct {
+		tmp
+		EndedAt   gophercloud.JSONRFC3339MilliNoZ `json:"ended_at"`
+		StartedAt gophercloud.JSONRFC3339MilliNoZ `json:"started_at"`
+	}
+
+	if err := json.Unmarshal(b, &s); err != nil {
+		return err
+	}
+	*u = ServerUsage(s.tmp)
+
+	u.EndedAt = time.Time(s.EndedAt)
+	u.StartedAt = time.Time(s.StartedAt)
+
+	return nil
+}
+
+// SingleTenantPage stores a single, only page of TenantUsage results from a
+// SingleTenant call.
+type SingleTenantPage struct {
+	pagination.LinkedPageBase
+}
+
+// IsEmpty determines whether or not a SingleTenantPage is empty.
+func (r SingleTenantPage) IsEmpty() (bool, error) {
+	ks, err := ExtractSingleTenant(r)
+	return ks == nil, err
+}
+
+// NextPageURL uses the response's embedded link reference to navigate to the
+// next page of results.
+func (r SingleTenantPage) NextPageURL() (string, error) {
+	var s struct {
+		Links []gophercloud.Link `json:"tenant_usage_links"`
+	}
+	err := r.ExtractInto(&s)
+	if err != nil {
+		return "", err
+	}
+	return gophercloud.ExtractNextURL(s.Links)
+}
+
+// ExtractSingleTenant interprets a SingleTenantPage as a TenantUsage result.
+func ExtractSingleTenant(page pagination.Page) (*TenantUsage, error) {
+	var s struct {
+		TenantUsage *TenantUsage `json:"tenant_usage"`
+	}
+	err := (page.(SingleTenantPage)).ExtractInto(&s)
+	return s.TenantUsage, err
+}
+
+// AllTenantsPage stores a single, only page of TenantUsage results from a
+// AllTenants call.
+type AllTenantsPage struct {
+	pagination.LinkedPageBase
+}
+
+// ExtractAllTenants interprets a AllTenantsPage as a TenantUsage result.
+func ExtractAllTenants(page pagination.Page) ([]TenantUsage, error) {
+	var s struct {
+		TenantUsages []TenantUsage `json:"tenant_usages"`
+	}
+	err := (page.(AllTenantsPage)).ExtractInto(&s)
+	return s.TenantUsages, err
+}
+
+// IsEmpty determines whether or not an AllTenantsPage is empty.
+func (r AllTenantsPage) IsEmpty() (bool, error) {
+	usages, err := ExtractAllTenants(r)
+	return len(usages) == 0, err
+}
+
+// NextPageURL uses the response's embedded link reference to navigate to the
+// next page of results.
+func (r AllTenantsPage) NextPageURL() (string, error) {
+	var s struct {
+		Links []gophercloud.Link `json:"tenant_usages_links"`
+	}
+	err := r.ExtractInto(&s)
+	if err != nil {
+		return "", err
+	}
+	return gophercloud.ExtractNextURL(s.Links)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/doc.go
new file mode 100644
index 000000000..a3521795b
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/doc.go
@@ -0,0 +1,2 @@
+// simple tenant usage unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/fixtures.go
new file mode 100644
index 000000000..3e37947a4
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/fixtures.go
@@ -0,0 +1,314 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+	"time"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+const FirstTenantID = "aabbccddeeff112233445566"
+const SecondTenantID = "665544332211ffeeddccbbaa"
+
+// GetSingleTenant holds the fixtures for the content of the request for a
+// single tenant.
+const GetSingleTenant = `{
+    "tenant_usage": {
+        "server_usages": [
+            {
+                "ended_at": null,
+                "flavor": "m1.tiny",
+                "hours": 0.021675453333333334,
+                "instance_id": "a70096fd-8196-406b-86c4-045840f53ad7",
+                "local_gb": 1,
+                "memory_mb": 512,
+                "name": "jttest",
+                "started_at": "2017-11-30T03:23:43.000000",
+                "state": "active",
+                "tenant_id": "aabbccddeeff112233445566",
+                "uptime": 78,
+                "vcpus": 1
+            },
+            {
+                "ended_at": "2017-11-21T04:10:11.000000",
+                "flavor": "m1.acctest",
+                "hours": 0.33444444444444443,
+                "instance_id": "c04e38f2-dcee-4ca8-9466-7708d0a9b6dd",
+                "local_gb": 15,
+                "memory_mb": 512,
+                "name": "basic",
+                "started_at": "2017-11-21T03:50:07.000000",
+                "state": "terminated",
+                "tenant_id": "aabbccddeeff112233445566",
+                "uptime": 1204,
+                "vcpus": 1
+            },
+            {
+                "ended_at": "2017-11-30T03:21:21.000000",
+                "flavor": "m1.acctest",
+                "hours": 0.004166666666666667,
+                "instance_id": "ceb654fa-e0e8-44fb-8942-e4d0bfad3941",
+                "local_gb": 15,
+                "memory_mb": 512,
+                "name": "ACPTTESTJSxbPQAC34lTnBE1",
+                "started_at": "2017-11-30T03:21:06.000000",
+                "state": "terminated",
+                "tenant_id": "aabbccddeeff112233445566",
+                "uptime": 15,
+                "vcpus": 1
+            }
+        ],
+        "start": "2017-11-02T03:25:01.000000",
+        "stop": "2017-11-30T03:25:01.000000",
+        "tenant_id": "aabbccddeeff112233445566",
+        "total_hours": 1.25834212,
+        "total_local_gb_usage": 18.571675453333334,
+        "total_memory_mb_usage": 644.27116544,
+        "total_vcpus_usage": 1.25834212
+    }
+}`
+
+// HandleGetSingleTenantSuccessfully configures the test server to respond to a
+// Get request for a single tenant
+func HandleGetSingleTenantSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-simple-tenant-usage/"+FirstTenantID, func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprint(w, GetSingleTenant)
+	})
+}
+
+// SingleTenantUsageResults is the code fixture for GetSingleTenant.
+var SingleTenantUsageResults = usage.TenantUsage{
+	ServerUsages: []usage.ServerUsage{
+		{
+			Flavor:     "m1.tiny",
+			Hours:      0.021675453333333334,
+			InstanceID: "a70096fd-8196-406b-86c4-045840f53ad7",
+			LocalGB:    1,
+			MemoryMB:   512,
+			Name:       "jttest",
+			StartedAt:  time.Date(2017, 11, 30, 3, 23, 43, 0, time.UTC),
+			State:      "active",
+			TenantID:   "aabbccddeeff112233445566",
+			Uptime:     78,
+			VCPUs:      1,
+		},
+		{
+			Flavor:     "m1.acctest",
+			Hours:      0.33444444444444443,
+			InstanceID: "c04e38f2-dcee-4ca8-9466-7708d0a9b6dd",
+			LocalGB:    15,
+			MemoryMB:   512,
+			Name:       "basic",
+			StartedAt:  time.Date(2017, 11, 21, 3, 50, 7, 0, time.UTC),
+			EndedAt:    time.Date(2017, 11, 21, 4, 10, 11, 0, time.UTC),
+			State:      "terminated",
+			TenantID:   "aabbccddeeff112233445566",
+			Uptime:     1204,
+			VCPUs:      1,
+		},
+		{
+			Flavor:     "m1.acctest",
+			Hours:      0.004166666666666667,
+			InstanceID: "ceb654fa-e0e8-44fb-8942-e4d0bfad3941",
+			LocalGB:    15,
+			MemoryMB:   512,
+			Name:       "ACPTTESTJSxbPQAC34lTnBE1",
+			StartedAt:  time.Date(2017, 11, 30, 3, 21, 6, 0, time.UTC),
+			EndedAt:    time.Date(2017, 11, 30, 3, 21, 21, 0, time.UTC),
+			State:      "terminated",
+			TenantID:   "aabbccddeeff112233445566",
+			Uptime:     15,
+			VCPUs:      1,
+		},
+	},
+	Start:              time.Date(2017, 11, 2, 3, 25, 1, 0, time.UTC),
+	Stop:               time.Date(2017, 11, 30, 3, 25, 1, 0, time.UTC),
+	TenantID:           "aabbccddeeff112233445566",
+	TotalHours:         1.25834212,
+	TotalLocalGBUsage:  18.571675453333334,
+	TotalMemoryMBUsage: 644.27116544,
+	TotalVCPUsUsage:    1.25834212,
+}
+
+// GetAllTenants holds the fixtures for the content of the request for
+// all tenants.
+const GetAllTenants = `{
+    "tenant_usages": [
+				{
+					"server_usages": [
+							{
+									"ended_at": null,
+									"flavor": "m1.tiny",
+									"hours": 0.021675453333333334,
+									"instance_id": "a70096fd-8196-406b-86c4-045840f53ad7",
+									"local_gb": 1,
+									"memory_mb": 512,
+									"name": "jttest",
+									"started_at": "2017-11-30T03:23:43.000000",
+									"state": "active",
+									"tenant_id": "aabbccddeeff112233445566",
+									"uptime": 78,
+									"vcpus": 1
+							},
+							{
+									"ended_at": "2017-11-21T04:10:11.000000",
+									"flavor": "m1.acctest",
+									"hours": 0.33444444444444443,
+									"instance_id": "c04e38f2-dcee-4ca8-9466-7708d0a9b6dd",
+									"local_gb": 15,
+									"memory_mb": 512,
+									"name": "basic",
+									"started_at": "2017-11-21T03:50:07.000000",
+									"state": "terminated",
+									"tenant_id": "aabbccddeeff112233445566",
+									"uptime": 1204,
+									"vcpus": 1
+							},
+							{
+									"ended_at": "2017-11-30T03:21:21.000000",
+									"flavor": "m1.acctest",
+									"hours": 0.004166666666666667,
+									"instance_id": "ceb654fa-e0e8-44fb-8942-e4d0bfad3941",
+									"local_gb": 15,
+									"memory_mb": 512,
+									"name": "ACPTTESTJSxbPQAC34lTnBE1",
+									"started_at": "2017-11-30T03:21:06.000000",
+									"state": "terminated",
+									"tenant_id": "aabbccddeeff112233445566",
+									"uptime": 15,
+									"vcpus": 1
+							}
+					],
+					"start": "2017-11-02T03:25:01.000000",
+					"stop": "2017-11-30T03:25:01.000000",
+					"tenant_id": "aabbccddeeff112233445566",
+					"total_hours": 1.25834212,
+					"total_local_gb_usage": 18.571675453333334,
+					"total_memory_mb_usage": 644.27116544,
+					"total_vcpus_usage": 1.25834212
+				},
+				{
+					"server_usages": [
+							{
+									"ended_at": null,
+									"flavor": "m1.tiny",
+									"hours": 0.021675453333333334,
+									"instance_id": "a70096fd-8196-406b-86c4-045840f53ad7",
+									"local_gb": 1,
+									"memory_mb": 512,
+									"name": "test",
+									"started_at": "2017-11-30T03:23:43.000000",
+									"state": "active",
+									"tenant_id": "665544332211ffeeddccbbaa",
+									"uptime": 78,
+									"vcpus": 1
+							}
+					],
+					"start": "2017-11-02T03:25:01.000000",
+					"stop": "2017-11-30T03:25:01.000000",
+					"tenant_id": "665544332211ffeeddccbbaa",
+					"total_hours": 0.021675453333333334,
+					"total_local_gb_usage": 18.571675453333334,
+					"total_memory_mb_usage": 644.27116544,
+					"total_vcpus_usage": 1.25834212
+				}
+		]
+}`
+
+// HandleGetAllTenantsSuccessfully configures the test server to respond to a
+// Get request for all tenants.
+func HandleGetAllTenantsSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/os-simple-tenant-usage", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprint(w, GetAllTenants)
+	})
+}
+
+// AllTenantsUsageResult is the code fixture for GetAllTenants.
+var AllTenantsUsageResult = []usage.TenantUsage{
+	{
+		ServerUsages: []usage.ServerUsage{
+			{
+				Flavor:     "m1.tiny",
+				Hours:      0.021675453333333334,
+				InstanceID: "a70096fd-8196-406b-86c4-045840f53ad7",
+				LocalGB:    1,
+				MemoryMB:   512,
+				Name:       "jttest",
+				StartedAt:  time.Date(2017, 11, 30, 3, 23, 43, 0, time.UTC),
+				State:      "active",
+				TenantID:   "aabbccddeeff112233445566",
+				Uptime:     78,
+				VCPUs:      1,
+			},
+			{
+				Flavor:     "m1.acctest",
+				Hours:      0.33444444444444443,
+				InstanceID: "c04e38f2-dcee-4ca8-9466-7708d0a9b6dd",
+				LocalGB:    15,
+				MemoryMB:   512,
+				Name:       "basic",
+				StartedAt:  time.Date(2017, 11, 21, 3, 50, 7, 0, time.UTC),
+				EndedAt:    time.Date(2017, 11, 21, 4, 10, 11, 0, time.UTC),
+				State:      "terminated",
+				TenantID:   "aabbccddeeff112233445566",
+				Uptime:     1204,
+				VCPUs:      1,
+			},
+			{
+				Flavor:     "m1.acctest",
+				Hours:      0.004166666666666667,
+				InstanceID: "ceb654fa-e0e8-44fb-8942-e4d0bfad3941",
+				LocalGB:    15,
+				MemoryMB:   512,
+				Name:       "ACPTTESTJSxbPQAC34lTnBE1",
+				StartedAt:  time.Date(2017, 11, 30, 3, 21, 6, 0, time.UTC),
+				EndedAt:    time.Date(2017, 11, 30, 3, 21, 21, 0, time.UTC),
+				State:      "terminated",
+				TenantID:   "aabbccddeeff112233445566",
+				Uptime:     15,
+				VCPUs:      1,
+			},
+		},
+		Start:              time.Date(2017, 11, 2, 3, 25, 1, 0, time.UTC),
+		Stop:               time.Date(2017, 11, 30, 3, 25, 1, 0, time.UTC),
+		TenantID:           "aabbccddeeff112233445566",
+		TotalHours:         1.25834212,
+		TotalLocalGBUsage:  18.571675453333334,
+		TotalMemoryMBUsage: 644.27116544,
+		TotalVCPUsUsage:    1.25834212,
+	},
+	{
+		ServerUsages: []usage.ServerUsage{
+			{
+				Flavor:     "m1.tiny",
+				Hours:      0.021675453333333334,
+				InstanceID: "a70096fd-8196-406b-86c4-045840f53ad7",
+				LocalGB:    1,
+				MemoryMB:   512,
+				Name:       "test",
+				StartedAt:  time.Date(2017, 11, 30, 3, 23, 43, 0, time.UTC),
+				State:      "active",
+				TenantID:   "665544332211ffeeddccbbaa",
+				Uptime:     78,
+				VCPUs:      1,
+			},
+		},
+		Start:              time.Date(2017, 11, 2, 3, 25, 1, 0, time.UTC),
+		Stop:               time.Date(2017, 11, 30, 3, 25, 1, 0, time.UTC),
+		TenantID:           "665544332211ffeeddccbbaa",
+		TotalHours:         0.021675453333333334,
+		TotalLocalGBUsage:  18.571675453333334,
+		TotalMemoryMBUsage: 644.27116544,
+		TotalVCPUsUsage:    1.25834212,
+	},
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/requests_test.go
new file mode 100644
index 000000000..1b4f27694
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/testing/requests_test.go
@@ -0,0 +1,52 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+func TestGetTenant(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetSingleTenantSuccessfully(t)
+
+	count := 0
+	err := usage.SingleTenant(client.ServiceClient(), FirstTenantID, nil).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+
+		actual, err := usage.ExtractSingleTenant(page)
+		th.AssertNoErr(t, err)
+		th.AssertDeepEquals(t, &SingleTenantUsageResults, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.AssertEquals(t, count, 1)
+}
+
+func TestAllTenants(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+	HandleGetAllTenantsSuccessfully(t)
+
+	getOpts := usage.AllTenantsOpts{
+		Detailed: true,
+	}
+
+	count := 0
+	err := usage.AllTenants(client.ServiceClient(), getOpts).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+
+		actual, err := usage.ExtractAllTenants(page)
+		th.AssertNoErr(t, err)
+		th.AssertDeepEquals(t, AllTenantsUsageResult, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.AssertEquals(t, count, 1)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/urls.go
new file mode 100644
index 000000000..506361070
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/usage/urls.go
@@ -0,0 +1,13 @@
+package usage
+
+import "github.com/gophercloud/gophercloud"
+
+const resourcePath = "os-simple-tenant-usage"
+
+func allTenantsURL(client *gophercloud.ServiceClient) string {
+	return client.ServiceURL(resourcePath)
+}
+
+func getTenantURL(client *gophercloud.ServiceClient, tenantID string) string {
+	return client.ServiceURL(resourcePath, tenantID)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/doc.go
new file mode 100644
index 000000000..484eb2000
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/doc.go
@@ -0,0 +1,30 @@
+/*
+Package volumeattach provides the ability to attach and detach volumes
+from servers.
+
+Example to Attach a Volume
+
+	serverID := "7ac8686c-de71-4acb-9600-ec18b1a1ed6d"
+	volumeID := "87463836-f0e2-4029-abf6-20c8892a3103"
+
+	createOpts := volumeattach.CreateOpts{
+		Device:   "/dev/vdc",
+		VolumeID: volumeID,
+	}
+
+	result, err := volumeattach.Create(computeClient, serverID, createOpts).Extract()
+	if err != nil {
+		panic(err)
+	}
+
+Example to Detach a Volume
+
+	serverID := "7ac8686c-de71-4acb-9600-ec18b1a1ed6d"
+	attachmentID := "ed081613-1c9b-4231-aa5e-ebfd4d87f983"
+
+	err := volumeattach.Delete(computeClient, serverID, attachmentID).ExtractErr()
+	if err != nil {
+		panic(err)
+	}
+*/
+package volumeattach
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/requests.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/requests.go
new file mode 100644
index 000000000..6a262c212
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/requests.go
@@ -0,0 +1,60 @@
+package volumeattach
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// List returns a Pager that allows you to iterate over a collection of
+// VolumeAttachments.
+func List(client *gophercloud.ServiceClient, serverID string) pagination.Pager {
+	return pagination.NewPager(client, listURL(client, serverID), func(r pagination.PageResult) pagination.Page {
+		return VolumeAttachmentPage{pagination.SinglePageBase(r)}
+	})
+}
+
+// CreateOptsBuilder allows extensions to add parameters to the Create request.
+type CreateOptsBuilder interface {
+	ToVolumeAttachmentCreateMap() (map[string]interface{}, error)
+}
+
+// CreateOpts specifies volume attachment creation or import parameters.
+type CreateOpts struct {
+	// Device is the device that the volume will attach to the instance as.
+	// Omit for "auto".
+	Device string `json:"device,omitempty"`
+
+	// VolumeID is the ID of the volume to attach to the instance.
+	VolumeID string `json:"volumeId" required:"true"`
+}
+
+// ToVolumeAttachmentCreateMap constructs a request body from CreateOpts.
+func (opts CreateOpts) ToVolumeAttachmentCreateMap() (map[string]interface{}, error) {
+	return gophercloud.BuildRequestBody(opts, "volumeAttachment")
+}
+
+// Create requests the creation of a new volume attachment on the server.
+func Create(client *gophercloud.ServiceClient, serverID string, opts CreateOptsBuilder) (r CreateResult) {
+	b, err := opts.ToVolumeAttachmentCreateMap()
+	if err != nil {
+		r.Err = err
+		return
+	}
+	_, r.Err = client.Post(createURL(client, serverID), b, &r.Body, &gophercloud.RequestOpts{
+		OkCodes: []int{200},
+	})
+	return
+}
+
+// Get returns public data about a previously created VolumeAttachment.
+func Get(client *gophercloud.ServiceClient, serverID, attachmentID string) (r GetResult) {
+	_, r.Err = client.Get(getURL(client, serverID, attachmentID), &r.Body, nil)
+	return
+}
+
+// Delete requests the deletion of a previous stored VolumeAttachment from
+// the server.
+func Delete(client *gophercloud.ServiceClient, serverID, attachmentID string) (r DeleteResult) {
+	_, r.Err = client.Delete(deleteURL(client, serverID, attachmentID), nil)
+	return
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/results.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/results.go
new file mode 100644
index 000000000..56d503472
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/results.go
@@ -0,0 +1,77 @@
+package volumeattach
+
+import (
+	"github.com/gophercloud/gophercloud"
+	"github.com/gophercloud/gophercloud/pagination"
+)
+
+// VolumeAttachment contains attachment information between a volume
+// and server.
+type VolumeAttachment struct {
+	// ID is a unique id of the attachment.
+	ID string `json:"id"`
+
+	// Device is what device the volume is attached as.
+	Device string `json:"device"`
+
+	// VolumeID is the ID of the attached volume.
+	VolumeID string `json:"volumeId"`
+
+	// ServerID is the ID of the instance that has the volume attached.
+	ServerID string `json:"serverId"`
+}
+
+// VolumeAttachmentPage stores a single page all of VolumeAttachment
+// results from a List call.
+type VolumeAttachmentPage struct {
+	pagination.SinglePageBase
+}
+
+// IsEmpty determines whether or not a VolumeAttachmentPage is empty.
+func (page VolumeAttachmentPage) IsEmpty() (bool, error) {
+	va, err := ExtractVolumeAttachments(page)
+	return len(va) == 0, err
+}
+
+// ExtractVolumeAttachments interprets a page of results as a slice of
+// VolumeAttachment.
+func ExtractVolumeAttachments(r pagination.Page) ([]VolumeAttachment, error) {
+	var s struct {
+		VolumeAttachments []VolumeAttachment `json:"volumeAttachments"`
+	}
+	err := (r.(VolumeAttachmentPage)).ExtractInto(&s)
+	return s.VolumeAttachments, err
+}
+
+// VolumeAttachmentResult is the result from a volume attachment operation.
+type VolumeAttachmentResult struct {
+	gophercloud.Result
+}
+
+// Extract is a method that attempts to interpret any VolumeAttachment resource
+// response as a VolumeAttachment struct.
+func (r VolumeAttachmentResult) Extract() (*VolumeAttachment, error) {
+	var s struct {
+		VolumeAttachment *VolumeAttachment `json:"volumeAttachment"`
+	}
+	err := r.ExtractInto(&s)
+	return s.VolumeAttachment, err
+}
+
+// CreateResult is the response from a Create operation. Call its Extract method
+// to interpret it as a VolumeAttachment.
+type CreateResult struct {
+	VolumeAttachmentResult
+}
+
+// GetResult is the response from a Get operation. Call its Extract method to
+// interpret it as a VolumeAttachment.
+type GetResult struct {
+	VolumeAttachmentResult
+}
+
+// DeleteResult is the response from a Delete operation. Call its ExtractErr
+// method to determine if the call succeeded or failed.
+type DeleteResult struct {
+	gophercloud.ErrResult
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/doc.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/doc.go
new file mode 100644
index 000000000..11dfc0694
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/doc.go
@@ -0,0 +1,2 @@
+// volumeattach unit tests
+package testing
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/fixtures.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/fixtures.go
new file mode 100644
index 000000000..4f996106e
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/fixtures.go
@@ -0,0 +1,108 @@
+package testing
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// ListOutput is a sample response to a List call.
+const ListOutput = `
+{
+  "volumeAttachments": [
+    {
+      "device": "/dev/vdd",
+      "id": "a26887c6-c47b-4654-abb5-dfadf7d3f803",
+      "serverId": "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+      "volumeId": "a26887c6-c47b-4654-abb5-dfadf7d3f803"
+    },
+    {
+      "device": "/dev/vdc",
+      "id": "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+      "serverId": "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+      "volumeId": "a26887c6-c47b-4654-abb5-dfadf7d3f804"
+    }
+  ]
+}
+`
+
+// GetOutput is a sample response to a Get call.
+const GetOutput = `
+{
+  "volumeAttachment": {
+    "device": "/dev/vdc",
+    "id": "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+    "serverId": "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+    "volumeId": "a26887c6-c47b-4654-abb5-dfadf7d3f804"
+  }
+}
+`
+
+// CreateOutput is a sample response to a Create call.
+const CreateOutput = `
+{
+  "volumeAttachment": {
+    "device": "/dev/vdc",
+    "id": "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+    "serverId": "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+    "volumeId": "a26887c6-c47b-4654-abb5-dfadf7d3f804"
+  }
+}
+`
+
+// HandleListSuccessfully configures the test server to respond to a List request.
+func HandleListSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/4d8c3732-a248-40ed-bebc-539a6ffd25c0/os-volume_attachments", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, ListOutput)
+	})
+}
+
+// HandleGetSuccessfully configures the test server to respond to a Get request
+// for an existing attachment
+func HandleGetSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/4d8c3732-a248-40ed-bebc-539a6ffd25c0/os-volume_attachments/a26887c6-c47b-4654-abb5-dfadf7d3f804", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "GET")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, GetOutput)
+	})
+}
+
+// HandleCreateSuccessfully configures the test server to respond to a Create request
+// for a new attachment
+func HandleCreateSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/4d8c3732-a248-40ed-bebc-539a6ffd25c0/os-volume_attachments", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "POST")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+		th.TestJSONRequest(t, r, `
+{
+  "volumeAttachment": {
+    "volumeId": "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+    "device": "/dev/vdc"
+  }
+}
+`)
+
+		w.Header().Add("Content-Type", "application/json")
+		fmt.Fprintf(w, CreateOutput)
+	})
+}
+
+// HandleDeleteSuccessfully configures the test server to respond to a Delete request for a
+// an existing attachment
+func HandleDeleteSuccessfully(t *testing.T) {
+	th.Mux.HandleFunc("/servers/4d8c3732-a248-40ed-bebc-539a6ffd25c0/os-volume_attachments/a26887c6-c47b-4654-abb5-dfadf7d3f804", func(w http.ResponseWriter, r *http.Request) {
+		th.TestMethod(t, r, "DELETE")
+		th.TestHeader(t, r, "X-Auth-Token", client.TokenID)
+
+		w.WriteHeader(http.StatusAccepted)
+	})
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/requests_test.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/requests_test.go
new file mode 100644
index 000000000..9486f9bb5
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/testing/requests_test.go
@@ -0,0 +1,102 @@
+package testing
+
+import (
+	"testing"
+
+	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach"
+	"github.com/gophercloud/gophercloud/pagination"
+	th "github.com/gophercloud/gophercloud/testhelper"
+	"github.com/gophercloud/gophercloud/testhelper/client"
+)
+
+// FirstVolumeAttachment is the first result in ListOutput.
+var FirstVolumeAttachment = volumeattach.VolumeAttachment{
+	Device:   "/dev/vdd",
+	ID:       "a26887c6-c47b-4654-abb5-dfadf7d3f803",
+	ServerID: "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+	VolumeID: "a26887c6-c47b-4654-abb5-dfadf7d3f803",
+}
+
+// SecondVolumeAttachment is the first result in ListOutput.
+var SecondVolumeAttachment = volumeattach.VolumeAttachment{
+	Device:   "/dev/vdc",
+	ID:       "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+	ServerID: "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+	VolumeID: "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+}
+
+// ExpectedVolumeAttachmentSlide is the slice of results that should be parsed
+// from ListOutput, in the expected order.
+var ExpectedVolumeAttachmentSlice = []volumeattach.VolumeAttachment{FirstVolumeAttachment, SecondVolumeAttachment}
+
+//CreatedVolumeAttachment is the parsed result from CreatedOutput.
+var CreatedVolumeAttachment = volumeattach.VolumeAttachment{
+	Device:   "/dev/vdc",
+	ID:       "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+	ServerID: "4d8c3732-a248-40ed-bebc-539a6ffd25c0",
+	VolumeID: "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+}
+
+func TestList(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleListSuccessfully(t)
+
+	serverID := "4d8c3732-a248-40ed-bebc-539a6ffd25c0"
+
+	count := 0
+	err := volumeattach.List(client.ServiceClient(), serverID).EachPage(func(page pagination.Page) (bool, error) {
+		count++
+		actual, err := volumeattach.ExtractVolumeAttachments(page)
+		th.AssertNoErr(t, err)
+		th.CheckDeepEquals(t, ExpectedVolumeAttachmentSlice, actual)
+
+		return true, nil
+	})
+	th.AssertNoErr(t, err)
+	th.CheckEquals(t, 1, count)
+}
+
+func TestCreate(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleCreateSuccessfully(t)
+
+	serverID := "4d8c3732-a248-40ed-bebc-539a6ffd25c0"
+
+	actual, err := volumeattach.Create(client.ServiceClient(), serverID, volumeattach.CreateOpts{
+		Device:   "/dev/vdc",
+		VolumeID: "a26887c6-c47b-4654-abb5-dfadf7d3f804",
+	}).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &CreatedVolumeAttachment, actual)
+}
+
+func TestGet(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleGetSuccessfully(t)
+
+	aID := "a26887c6-c47b-4654-abb5-dfadf7d3f804"
+	serverID := "4d8c3732-a248-40ed-bebc-539a6ffd25c0"
+
+	actual, err := volumeattach.Get(client.ServiceClient(), serverID, aID).Extract()
+	th.AssertNoErr(t, err)
+	th.CheckDeepEquals(t, &SecondVolumeAttachment, actual)
+}
+
+func TestDelete(t *testing.T) {
+	th.SetupHTTP()
+	defer th.TeardownHTTP()
+
+	HandleDeleteSuccessfully(t)
+
+	aID := "a26887c6-c47b-4654-abb5-dfadf7d3f804"
+	serverID := "4d8c3732-a248-40ed-bebc-539a6ffd25c0"
+
+	err := volumeattach.Delete(client.ServiceClient(), serverID, aID).ExtractErr()
+	th.AssertNoErr(t, err)
+}
diff --git a/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/urls.go b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/urls.go
new file mode 100644
index 000000000..083f8dc45
--- /dev/null
+++ b/vendor/github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach/urls.go
@@ -0,0 +1,25 @@
+package volumeattach
+
+import "github.com/gophercloud/gophercloud"
+
+const resourcePath = "os-volume_attachments"
+
+func resourceURL(c *gophercloud.ServiceClient, serverID string) string {
+	return c.ServiceURL("servers", serverID, resourcePath)
+}
+
+func listURL(c *gophercloud.ServiceClient, serverID string) string {
+	return resourceURL(c, serverID)
+}
+
+func createURL(c *gophercloud.ServiceClient, serverID string) string {
+	return resourceURL(c, serverID)
+}
+
+func getURL(c *gophercloud.ServiceClient, serverID, aID string) string {
+	return c.ServiceURL("servers", serverID, resourcePath, aID)
+}
+
+func deleteURL(c *gophercloud.ServiceClient, serverID, aID string) string {
+	return getURL(c, serverID, aID)
+}
